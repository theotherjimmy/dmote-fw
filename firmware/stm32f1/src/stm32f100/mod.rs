#![deny(unconditional_recursion)]
#![deny(unused_allocation)]
use core::marker::PhantomData;
use core::ops::Deref;
///Number available in the NVIC for configuring priority
pub const NVIC_PRIO_BITS: u8 = 4;
#[cfg(feature = "rt")]
pub use self::Interrupt as interrupt;
pub use cortex_m::peripheral::Peripherals as CorePeripherals;
pub use cortex_m::peripheral::{CBP, CPUID, DCB, DWT, FPB, ITM, MPU, NVIC, SCB, SYST, TPIU};
#[cfg(feature = "rt")]
pub use cortex_m_rt::interrupt;
#[allow(unused_imports)]
use generic::*;
///Common register and bit access and modify traits
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn WWDG();
    fn PVD();
    fn TAMPER_STAMP();
    fn RTC_WKUP();
    fn FLASH();
    fn RCC();
    fn EXTI0();
    fn EXTI1();
    fn EXTI2();
    fn EXTI3();
    fn EXTI4();
    fn DMA1_CHANNEL1();
    fn DMA1_CHANNEL2();
    fn DMA1_CHANNEL3();
    fn DMA1_CHANNEL4();
    fn DMA1_CHANNEL5();
    fn DMA1_CHANNEL6();
    fn DMA1_CHANNEL7();
    fn ADC();
    fn EXTI9_5();
    fn TIM1_BRK_TIM15();
    fn TIM1_UP_TIM16();
    fn TIM1_TRG_COM_TIM17();
    fn TIM1_CC();
    fn TIM2();
    fn TIM3();
    fn TIM4();
    fn I2C1_EV();
    fn I2C1_ER();
    fn I2C2_EV();
    fn I2C2_ER();
    fn SPI1();
    fn SPI2();
    fn USART1();
    fn USART2();
    fn USART3();
    fn EXTI15_10();
    fn RTCALARM();
    fn CEC();
    fn TIM12();
    fn TIM13();
    fn TIM14();
    fn FSMC();
    fn TIM5();
    fn SPI3();
    fn UART4();
    fn UART5();
    fn TIM6_DAC();
    fn TIM7();
    fn DMA2_CHANNEL1();
    fn DMA2_CHANNEL2();
    fn DMA2_CHANNEL3();
    fn DMA2_CHANNEL4_5();
}
#[doc(hidden)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 60] = [
    Vector { _handler: WWDG },
    Vector { _handler: PVD },
    Vector {
        _handler: TAMPER_STAMP,
    },
    Vector { _handler: RTC_WKUP },
    Vector { _handler: FLASH },
    Vector { _handler: RCC },
    Vector { _handler: EXTI0 },
    Vector { _handler: EXTI1 },
    Vector { _handler: EXTI2 },
    Vector { _handler: EXTI3 },
    Vector { _handler: EXTI4 },
    Vector {
        _handler: DMA1_CHANNEL1,
    },
    Vector {
        _handler: DMA1_CHANNEL2,
    },
    Vector {
        _handler: DMA1_CHANNEL3,
    },
    Vector {
        _handler: DMA1_CHANNEL4,
    },
    Vector {
        _handler: DMA1_CHANNEL5,
    },
    Vector {
        _handler: DMA1_CHANNEL6,
    },
    Vector {
        _handler: DMA1_CHANNEL7,
    },
    Vector { _handler: ADC },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: EXTI9_5 },
    Vector {
        _handler: TIM1_BRK_TIM15,
    },
    Vector {
        _handler: TIM1_UP_TIM16,
    },
    Vector {
        _handler: TIM1_TRG_COM_TIM17,
    },
    Vector { _handler: TIM1_CC },
    Vector { _handler: TIM2 },
    Vector { _handler: TIM3 },
    Vector { _handler: TIM4 },
    Vector { _handler: I2C1_EV },
    Vector { _handler: I2C1_ER },
    Vector { _handler: I2C2_EV },
    Vector { _handler: I2C2_ER },
    Vector { _handler: SPI1 },
    Vector { _handler: SPI2 },
    Vector { _handler: USART1 },
    Vector { _handler: USART2 },
    Vector { _handler: USART3 },
    Vector {
        _handler: EXTI15_10,
    },
    Vector { _handler: RTCALARM },
    Vector { _handler: CEC },
    Vector { _handler: TIM12 },
    Vector { _handler: TIM13 },
    Vector { _handler: TIM14 },
    Vector { _reserved: 0 },
    Vector { _reserved: 0 },
    Vector { _handler: FSMC },
    Vector { _reserved: 0 },
    Vector { _handler: TIM5 },
    Vector { _handler: SPI3 },
    Vector { _handler: UART4 },
    Vector { _handler: UART5 },
    Vector { _handler: TIM6_DAC },
    Vector { _handler: TIM7 },
    Vector {
        _handler: DMA2_CHANNEL1,
    },
    Vector {
        _handler: DMA2_CHANNEL2,
    },
    Vector {
        _handler: DMA2_CHANNEL3,
    },
    Vector {
        _handler: DMA2_CHANNEL4_5,
    },
];
///Enumeration of all the interrupts.
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    ///0 - Window Watchdog interrupt
    WWDG = 0,
    ///1 - PVD through EXTI line detection interrupt
    PVD = 1,
    ///2 - Tamper and TimeStamp through EXTI line interrupts
    TAMPER_STAMP = 2,
    ///3 - RTC Wakeup through EXTI line interrupt
    RTC_WKUP = 3,
    ///4 - Flash global interrupt
    FLASH = 4,
    ///5 - RCC global interrupt
    RCC = 5,
    ///6 - EXTI Line0 interrupt
    EXTI0 = 6,
    ///7 - EXTI Line1 interrupt
    EXTI1 = 7,
    ///8 - EXTI Line2 interrupt
    EXTI2 = 8,
    ///9 - EXTI Line3 interrupt
    EXTI3 = 9,
    ///10 - EXTI Line4 interrupt
    EXTI4 = 10,
    ///11 - DMA1 Channel1 global interrupt
    DMA1_CHANNEL1 = 11,
    ///12 - DMA1 Channel2 global interrupt
    DMA1_CHANNEL2 = 12,
    ///13 - DMA1 Channel3 global interrupt
    DMA1_CHANNEL3 = 13,
    ///14 - DMA1 Channel4 global interrupt
    DMA1_CHANNEL4 = 14,
    ///15 - DMA1 Channel5 global interrupt
    DMA1_CHANNEL5 = 15,
    ///16 - DMA1 Channel6 global interrupt
    DMA1_CHANNEL6 = 16,
    ///17 - DMA1 Channel7 global interrupt
    DMA1_CHANNEL7 = 17,
    ///18 - ADC1 global interrupt
    ADC = 18,
    ///23 - EXTI Line\[9:5\]
    ///interrupts
    EXTI9_5 = 23,
    ///24 - TIM1 Break interrupt and TIM15 global interrupt
    TIM1_BRK_TIM15 = 24,
    ///25 - TIM1 Update interrupt and TIM16 global interrupt
    TIM1_UP_TIM16 = 25,
    ///26 - TIM1 Trigger and Commutation interrupts and TIM17 global interrupt
    TIM1_TRG_COM_TIM17 = 26,
    ///27 - TIM1 Capture Compare interrupt
    TIM1_CC = 27,
    ///28 - TIM2 global interrupt
    TIM2 = 28,
    ///29 - TIM3 global interrupt
    TIM3 = 29,
    ///30 - TIM4 global interrupt
    TIM4 = 30,
    ///31 - I2C1 event interrupt
    I2C1_EV = 31,
    ///32 - I2C1 error interrupt
    I2C1_ER = 32,
    ///33 - I2C2 event interrupt
    I2C2_EV = 33,
    ///34 - I2C2 error interrupt
    I2C2_ER = 34,
    ///35 - SPI1 global interrupt
    SPI1 = 35,
    ///36 - SPI2 global interrupt
    SPI2 = 36,
    ///37 - USART1 global interrupt
    USART1 = 37,
    ///38 - USART2 global interrupt
    USART2 = 38,
    ///39 - USART3 global interrupt
    USART3 = 39,
    ///40 - EXTI Line\[15:10\]
    ///interrupts
    EXTI15_10 = 40,
    ///41 - RTC Alarms through EXTI line interrupt
    RTCALARM = 41,
    ///42 - CEC global interrupt
    CEC = 42,
    ///43 - TIM12 global interrupt
    TIM12 = 43,
    ///44 - TIM13 global interrupt
    TIM13 = 44,
    ///45 - TIM14 global interrupt
    TIM14 = 45,
    ///48 - FSMC global interrupt
    FSMC = 48,
    ///50 - TIM5 global interrupt
    TIM5 = 50,
    ///51 - SPI3 global interrupt
    SPI3 = 51,
    ///52 - UART4 global interrupt
    UART4 = 52,
    ///53 - UART5 global interrupt
    UART5 = 53,
    ///54 - TIM6 global and DAC underrun interrupts
    TIM6_DAC = 54,
    ///55 - TIM7 global interrupt
    TIM7 = 55,
    ///56 - DMA2 Channel1 global interrupt
    DMA2_CHANNEL1 = 56,
    ///57 - DMA2 Channel2 global interrupt
    DMA2_CHANNEL2 = 57,
    ///58 - DMA2 Channel3 global interrupt
    DMA2_CHANNEL3 = 58,
    ///59 - DMA2 Channel4 and DMA2 Channel5 global interrupt
    DMA2_CHANNEL4_5 = 59,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
///Flexible static memory controller
pub struct FSMC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FSMC {}
impl FSMC {
    ///Pointer to the register block
    pub const PTR: *const fsmc::RegisterBlock = 0xa000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const fsmc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FSMC {
    type Target = fsmc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FSMC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FSMC").finish()
    }
}
///Flexible static memory controller
pub mod fsmc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - SRAM/NOR-Flash chip-select control register 1
        pub bcr1: crate::Reg<bcr1::BCR1_SPEC>,
        ///0x04 - SRAM/NOR-Flash chip-select timing register 1
        pub btr1: crate::Reg<btr::BTR_SPEC>,
        ///0x08 - SRAM/NOR-Flash chip-select control register 2
        pub bcr2: crate::Reg<bcr::BCR_SPEC>,
        ///0x0c - SRAM/NOR-Flash chip-select timing register 1
        pub btr2: crate::Reg<btr::BTR_SPEC>,
        ///0x10 - SRAM/NOR-Flash chip-select control register 2
        pub bcr3: crate::Reg<bcr::BCR_SPEC>,
        ///0x14 - SRAM/NOR-Flash chip-select timing register 1
        pub btr3: crate::Reg<btr::BTR_SPEC>,
        ///0x18 - SRAM/NOR-Flash chip-select control register 2
        pub bcr4: crate::Reg<bcr::BCR_SPEC>,
        ///0x1c - SRAM/NOR-Flash chip-select timing register 1
        pub btr4: crate::Reg<btr::BTR_SPEC>,
        _reserved8: [u8; 228usize],
        ///0x104 - SRAM/NOR-Flash write timing registers 1
        pub bwtr1: crate::Reg<bwtr::BWTR_SPEC>,
        _reserved9: [u8; 4usize],
        ///0x10c - SRAM/NOR-Flash write timing registers 1
        pub bwtr2: crate::Reg<bwtr::BWTR_SPEC>,
        _reserved10: [u8; 4usize],
        ///0x114 - SRAM/NOR-Flash write timing registers 1
        pub bwtr3: crate::Reg<bwtr::BWTR_SPEC>,
        _reserved11: [u8; 4usize],
        ///0x11c - SRAM/NOR-Flash write timing registers 1
        pub bwtr4: crate::Reg<bwtr::BWTR_SPEC>,
    }
    ///BCR1 register accessor: an alias for `Reg<BCR1_SPEC>`
    pub type BCR1 = crate::Reg<bcr1::BCR1_SPEC>;
    ///SRAM/NOR-Flash chip-select control register 1
    pub mod bcr1 {
        ///Register `BCR1` reader
        pub struct R(crate::R<BCR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BCR1_SPEC>> for R {
            fn from(reader: crate::R<BCR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BCR1` writer
        pub struct W(crate::W<BCR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BCR1_SPEC>> for W {
            fn from(writer: crate::W<BCR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///CBURSTRW
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CBURSTRW_A {
            ///1: Write operations are performed in synchronous mode
            ENABLED = 1,
            ///0: Write operations are always performed in asynchronous mode
            DISABLED = 0,
        }
        impl From<CBURSTRW_A> for bool {
            #[inline(always)]
            fn from(variant: CBURSTRW_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CBURSTRW` reader - CBURSTRW
        pub struct CBURSTRW_R(crate::FieldReader<bool, CBURSTRW_A>);
        impl CBURSTRW_R {
            pub(crate) fn new(bits: bool) -> Self {
                CBURSTRW_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CBURSTRW_A {
                match self.bits {
                    true => CBURSTRW_A::ENABLED,
                    false => CBURSTRW_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CBURSTRW_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CBURSTRW_A::DISABLED
            }
        }
        impl core::ops::Deref for CBURSTRW_R {
            type Target = crate::FieldReader<bool, CBURSTRW_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CBURSTRW` writer - CBURSTRW
        pub struct CBURSTRW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CBURSTRW_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CBURSTRW_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Write operations are performed in synchronous mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::ENABLED)
            }
            ///Write operations are always performed in asynchronous mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///ASYNCWAIT
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASYNCWAIT_A {
            ///0: Wait signal not used in asynchronous mode
            DISABLED = 0,
            ///1: Wait signal used even in asynchronous mode
            ENABLED = 1,
        }
        impl From<ASYNCWAIT_A> for bool {
            #[inline(always)]
            fn from(variant: ASYNCWAIT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ASYNCWAIT` reader - ASYNCWAIT
        pub struct ASYNCWAIT_R(crate::FieldReader<bool, ASYNCWAIT_A>);
        impl ASYNCWAIT_R {
            pub(crate) fn new(bits: bool) -> Self {
                ASYNCWAIT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASYNCWAIT_A {
                match self.bits {
                    false => ASYNCWAIT_A::DISABLED,
                    true => ASYNCWAIT_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ASYNCWAIT_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ASYNCWAIT_A::ENABLED
            }
        }
        impl core::ops::Deref for ASYNCWAIT_R {
            type Target = crate::FieldReader<bool, ASYNCWAIT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ASYNCWAIT` writer - ASYNCWAIT
        pub struct ASYNCWAIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASYNCWAIT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ASYNCWAIT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Wait signal not used in asynchronous mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::DISABLED)
            }
            ///Wait signal used even in asynchronous mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///EXTMOD
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTMOD_A {
            ///0: Values inside the FMC_BWTR are not taken into account
            DISABLED = 0,
            ///1: Values inside the FMC_BWTR are taken into account
            ENABLED = 1,
        }
        impl From<EXTMOD_A> for bool {
            #[inline(always)]
            fn from(variant: EXTMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EXTMOD` reader - EXTMOD
        pub struct EXTMOD_R(crate::FieldReader<bool, EXTMOD_A>);
        impl EXTMOD_R {
            pub(crate) fn new(bits: bool) -> Self {
                EXTMOD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EXTMOD_A {
                match self.bits {
                    false => EXTMOD_A::DISABLED,
                    true => EXTMOD_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EXTMOD_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EXTMOD_A::ENABLED
            }
        }
        impl core::ops::Deref for EXTMOD_R {
            type Target = crate::FieldReader<bool, EXTMOD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTMOD` writer - EXTMOD
        pub struct EXTMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTMOD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EXTMOD_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Values inside the FMC_BWTR are not taken into account
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::DISABLED)
            }
            ///Values inside the FMC_BWTR are taken into account
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///WAITEN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITEN_A {
            ///0: Values inside the FMC_BWTR are taken into account
            DISABLED = 0,
            ///1: NWAIT signal enabled
            ENABLED = 1,
        }
        impl From<WAITEN_A> for bool {
            #[inline(always)]
            fn from(variant: WAITEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITEN` reader - WAITEN
        pub struct WAITEN_R(crate::FieldReader<bool, WAITEN_A>);
        impl WAITEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITEN_A {
                match self.bits {
                    false => WAITEN_A::DISABLED,
                    true => WAITEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WAITEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == WAITEN_A::ENABLED
            }
        }
        impl core::ops::Deref for WAITEN_R {
            type Target = crate::FieldReader<bool, WAITEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITEN` writer - WAITEN
        pub struct WAITEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Values inside the FMC_BWTR are taken into account
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAITEN_A::DISABLED)
            }
            ///NWAIT signal enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAITEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///WREN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WREN_A {
            ///0: Write operations disabled for the bank by the FMC
            DISABLED = 0,
            ///1: Write operations enabled for the bank by the FMC
            ENABLED = 1,
        }
        impl From<WREN_A> for bool {
            #[inline(always)]
            fn from(variant: WREN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WREN` reader - WREN
        pub struct WREN_R(crate::FieldReader<bool, WREN_A>);
        impl WREN_R {
            pub(crate) fn new(bits: bool) -> Self {
                WREN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WREN_A {
                match self.bits {
                    false => WREN_A::DISABLED,
                    true => WREN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WREN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == WREN_A::ENABLED
            }
        }
        impl core::ops::Deref for WREN_R {
            type Target = crate::FieldReader<bool, WREN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WREN` writer - WREN
        pub struct WREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Write operations disabled for the bank by the FMC
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WREN_A::DISABLED)
            }
            ///Write operations enabled for the bank by the FMC
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///WAITCFG
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITCFG_A {
            ///0: NWAIT signal is active one data cycle before wait state
            BEFOREWAITSTATE = 0,
            ///1: NWAIT signal is active during wait state
            DURINGWAITSTATE = 1,
        }
        impl From<WAITCFG_A> for bool {
            #[inline(always)]
            fn from(variant: WAITCFG_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITCFG` reader - WAITCFG
        pub struct WAITCFG_R(crate::FieldReader<bool, WAITCFG_A>);
        impl WAITCFG_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITCFG_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITCFG_A {
                match self.bits {
                    false => WAITCFG_A::BEFOREWAITSTATE,
                    true => WAITCFG_A::DURINGWAITSTATE,
                }
            }
            ///Checks if the value of the field is `BEFOREWAITSTATE`
            #[inline(always)]
            pub fn is_before_wait_state(&self) -> bool {
                **self == WAITCFG_A::BEFOREWAITSTATE
            }
            ///Checks if the value of the field is `DURINGWAITSTATE`
            #[inline(always)]
            pub fn is_during_wait_state(&self) -> bool {
                **self == WAITCFG_A::DURINGWAITSTATE
            }
        }
        impl core::ops::Deref for WAITCFG_R {
            type Target = crate::FieldReader<bool, WAITCFG_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITCFG` writer - WAITCFG
        pub struct WAITCFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITCFG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITCFG_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///NWAIT signal is active one data cycle before wait state
            #[inline(always)]
            pub fn before_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::BEFOREWAITSTATE)
            }
            ///NWAIT signal is active during wait state
            #[inline(always)]
            pub fn during_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::DURINGWAITSTATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///WAITPOL
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITPOL_A {
            ///0: NWAIT active low
            ACTIVELOW = 0,
            ///1: NWAIT active high
            ACTIVEHIGH = 1,
        }
        impl From<WAITPOL_A> for bool {
            #[inline(always)]
            fn from(variant: WAITPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITPOL` reader - WAITPOL
        pub struct WAITPOL_R(crate::FieldReader<bool, WAITPOL_A>);
        impl WAITPOL_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITPOL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITPOL_A {
                match self.bits {
                    false => WAITPOL_A::ACTIVELOW,
                    true => WAITPOL_A::ACTIVEHIGH,
                }
            }
            ///Checks if the value of the field is `ACTIVELOW`
            #[inline(always)]
            pub fn is_active_low(&self) -> bool {
                **self == WAITPOL_A::ACTIVELOW
            }
            ///Checks if the value of the field is `ACTIVEHIGH`
            #[inline(always)]
            pub fn is_active_high(&self) -> bool {
                **self == WAITPOL_A::ACTIVEHIGH
            }
        }
        impl core::ops::Deref for WAITPOL_R {
            type Target = crate::FieldReader<bool, WAITPOL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITPOL` writer - WAITPOL
        pub struct WAITPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITPOL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITPOL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///NWAIT active low
            #[inline(always)]
            pub fn active_low(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVELOW)
            }
            ///NWAIT active high
            #[inline(always)]
            pub fn active_high(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVEHIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///BURSTEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BURSTEN_A {
            ///0: Burst mode disabled
            DISABLED = 0,
            ///1: Burst mode enabled
            ENABLED = 1,
        }
        impl From<BURSTEN_A> for bool {
            #[inline(always)]
            fn from(variant: BURSTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BURSTEN` reader - BURSTEN
        pub struct BURSTEN_R(crate::FieldReader<bool, BURSTEN_A>);
        impl BURSTEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                BURSTEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BURSTEN_A {
                match self.bits {
                    false => BURSTEN_A::DISABLED,
                    true => BURSTEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == BURSTEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == BURSTEN_A::ENABLED
            }
        }
        impl core::ops::Deref for BURSTEN_R {
            type Target = crate::FieldReader<bool, BURSTEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BURSTEN` writer - BURSTEN
        pub struct BURSTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BURSTEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BURSTEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Burst mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::DISABLED)
            }
            ///Burst mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///FACCEN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FACCEN_A {
            ///0: Corresponding NOR Flash memory access is disabled
            DISABLED = 0,
            ///1: Corresponding NOR Flash memory access is enabled
            ENABLED = 1,
        }
        impl From<FACCEN_A> for bool {
            #[inline(always)]
            fn from(variant: FACCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `FACCEN` reader - FACCEN
        pub struct FACCEN_R(crate::FieldReader<bool, FACCEN_A>);
        impl FACCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                FACCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> FACCEN_A {
                match self.bits {
                    false => FACCEN_A::DISABLED,
                    true => FACCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == FACCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == FACCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for FACCEN_R {
            type Target = crate::FieldReader<bool, FACCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FACCEN` writer - FACCEN
        pub struct FACCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FACCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: FACCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Corresponding NOR Flash memory access is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FACCEN_A::DISABLED)
            }
            ///Corresponding NOR Flash memory access is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FACCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///MWID
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MWID_A {
            ///0: Memory data bus width 8 bits
            BITS8 = 0,
            ///1: Memory data bus width 16 bits
            BITS16 = 1,
            ///2: Memory data bus width 32 bits
            BITS32 = 2,
        }
        impl From<MWID_A> for u8 {
            #[inline(always)]
            fn from(variant: MWID_A) -> Self {
                variant as _
            }
        }
        ///Field `MWID` reader - MWID
        pub struct MWID_R(crate::FieldReader<u8, MWID_A>);
        impl MWID_R {
            pub(crate) fn new(bits: u8) -> Self {
                MWID_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MWID_A> {
                match self.bits {
                    0 => Some(MWID_A::BITS8),
                    1 => Some(MWID_A::BITS16),
                    2 => Some(MWID_A::BITS32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `BITS8`
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                **self == MWID_A::BITS8
            }
            ///Checks if the value of the field is `BITS16`
            #[inline(always)]
            pub fn is_bits16(&self) -> bool {
                **self == MWID_A::BITS16
            }
            ///Checks if the value of the field is `BITS32`
            #[inline(always)]
            pub fn is_bits32(&self) -> bool {
                **self == MWID_A::BITS32
            }
        }
        impl core::ops::Deref for MWID_R {
            type Target = crate::FieldReader<u8, MWID_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MWID` writer - MWID
        pub struct MWID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MWID_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MWID_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Memory data bus width 8 bits
            #[inline(always)]
            pub fn bits8(self) -> &'a mut W {
                self.variant(MWID_A::BITS8)
            }
            ///Memory data bus width 16 bits
            #[inline(always)]
            pub fn bits16(self) -> &'a mut W {
                self.variant(MWID_A::BITS16)
            }
            ///Memory data bus width 32 bits
            #[inline(always)]
            pub fn bits32(self) -> &'a mut W {
                self.variant(MWID_A::BITS32)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | ((value as u32 & 0x03) << 4);
                self.w
            }
        }
        ///MTYP
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MTYP_A {
            ///0: SRAM memory type
            SRAM = 0,
            ///1: PSRAM (CRAM) memory type
            PSRAM = 1,
            ///2: NOR Flash/OneNAND Flash
            FLASH = 2,
        }
        impl From<MTYP_A> for u8 {
            #[inline(always)]
            fn from(variant: MTYP_A) -> Self {
                variant as _
            }
        }
        ///Field `MTYP` reader - MTYP
        pub struct MTYP_R(crate::FieldReader<u8, MTYP_A>);
        impl MTYP_R {
            pub(crate) fn new(bits: u8) -> Self {
                MTYP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MTYP_A> {
                match self.bits {
                    0 => Some(MTYP_A::SRAM),
                    1 => Some(MTYP_A::PSRAM),
                    2 => Some(MTYP_A::FLASH),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `SRAM`
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                **self == MTYP_A::SRAM
            }
            ///Checks if the value of the field is `PSRAM`
            #[inline(always)]
            pub fn is_psram(&self) -> bool {
                **self == MTYP_A::PSRAM
            }
            ///Checks if the value of the field is `FLASH`
            #[inline(always)]
            pub fn is_flash(&self) -> bool {
                **self == MTYP_A::FLASH
            }
        }
        impl core::ops::Deref for MTYP_R {
            type Target = crate::FieldReader<u8, MTYP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MTYP` writer - MTYP
        pub struct MTYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MTYP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MTYP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///SRAM memory type
            #[inline(always)]
            pub fn sram(self) -> &'a mut W {
                self.variant(MTYP_A::SRAM)
            }
            ///PSRAM (CRAM) memory type
            #[inline(always)]
            pub fn psram(self) -> &'a mut W {
                self.variant(MTYP_A::PSRAM)
            }
            ///NOR Flash/OneNAND Flash
            #[inline(always)]
            pub fn flash(self) -> &'a mut W {
                self.variant(MTYP_A::FLASH)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///MUXEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXEN_A {
            ///0: Address/Data non-multiplexed
            DISABLED = 0,
            ///1: Address/Data multiplexed on databus
            ENABLED = 1,
        }
        impl From<MUXEN_A> for bool {
            #[inline(always)]
            fn from(variant: MUXEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MUXEN` reader - MUXEN
        pub struct MUXEN_R(crate::FieldReader<bool, MUXEN_A>);
        impl MUXEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                MUXEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MUXEN_A {
                match self.bits {
                    false => MUXEN_A::DISABLED,
                    true => MUXEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == MUXEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == MUXEN_A::ENABLED
            }
        }
        impl core::ops::Deref for MUXEN_R {
            type Target = crate::FieldReader<bool, MUXEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MUXEN` writer - MUXEN
        pub struct MUXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MUXEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MUXEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Address/Data non-multiplexed
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MUXEN_A::DISABLED)
            }
            ///Address/Data multiplexed on databus
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MUXEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///MBKEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MBKEN_A {
            ///0: Corresponding memory bank is disabled
            DISABLED = 0,
            ///1: Corresponding memory bank is enabled
            ENABLED = 1,
        }
        impl From<MBKEN_A> for bool {
            #[inline(always)]
            fn from(variant: MBKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MBKEN` reader - MBKEN
        pub struct MBKEN_R(crate::FieldReader<bool, MBKEN_A>);
        impl MBKEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                MBKEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MBKEN_A {
                match self.bits {
                    false => MBKEN_A::DISABLED,
                    true => MBKEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == MBKEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == MBKEN_A::ENABLED
            }
        }
        impl core::ops::Deref for MBKEN_R {
            type Target = crate::FieldReader<bool, MBKEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MBKEN` writer - MBKEN
        pub struct MBKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MBKEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MBKEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Corresponding memory bank is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MBKEN_A::DISABLED)
            }
            ///Corresponding memory bank is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MBKEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `WRAPMOD` reader - WRAPMOD
        pub struct WRAPMOD_R(crate::FieldReader<bool, bool>);
        impl WRAPMOD_R {
            pub(crate) fn new(bits: bool) -> Self {
                WRAPMOD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WRAPMOD_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WRAPMOD` writer - WRAPMOD
        pub struct WRAPMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRAPMOD_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///CRAM page size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CPSIZE_A {
            ///0: No burst split when crossing page boundary
            NOBURSTSPLIT = 0,
            ///1: 128 bytes CRAM page size
            BYTES128 = 1,
            ///2: 256 bytes CRAM page size
            BYTES256 = 2,
            ///3: 512 bytes CRAM page size
            BYTES512 = 3,
            ///4: 1024 bytes CRAM page size
            BYTES1024 = 4,
        }
        impl From<CPSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CPSIZE_A) -> Self {
                variant as _
            }
        }
        ///Field `CPSIZE` reader - CRAM page size
        pub struct CPSIZE_R(crate::FieldReader<u8, CPSIZE_A>);
        impl CPSIZE_R {
            pub(crate) fn new(bits: u8) -> Self {
                CPSIZE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CPSIZE_A> {
                match self.bits {
                    0 => Some(CPSIZE_A::NOBURSTSPLIT),
                    1 => Some(CPSIZE_A::BYTES128),
                    2 => Some(CPSIZE_A::BYTES256),
                    3 => Some(CPSIZE_A::BYTES512),
                    4 => Some(CPSIZE_A::BYTES1024),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NOBURSTSPLIT`
            #[inline(always)]
            pub fn is_no_burst_split(&self) -> bool {
                **self == CPSIZE_A::NOBURSTSPLIT
            }
            ///Checks if the value of the field is `BYTES128`
            #[inline(always)]
            pub fn is_bytes128(&self) -> bool {
                **self == CPSIZE_A::BYTES128
            }
            ///Checks if the value of the field is `BYTES256`
            #[inline(always)]
            pub fn is_bytes256(&self) -> bool {
                **self == CPSIZE_A::BYTES256
            }
            ///Checks if the value of the field is `BYTES512`
            #[inline(always)]
            pub fn is_bytes512(&self) -> bool {
                **self == CPSIZE_A::BYTES512
            }
            ///Checks if the value of the field is `BYTES1024`
            #[inline(always)]
            pub fn is_bytes1024(&self) -> bool {
                **self == CPSIZE_A::BYTES1024
            }
        }
        impl core::ops::Deref for CPSIZE_R {
            type Target = crate::FieldReader<u8, CPSIZE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPSIZE` writer - CRAM page size
        pub struct CPSIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPSIZE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPSIZE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///No burst split when crossing page boundary
            #[inline(always)]
            pub fn no_burst_split(self) -> &'a mut W {
                self.variant(CPSIZE_A::NOBURSTSPLIT)
            }
            ///128 bytes CRAM page size
            #[inline(always)]
            pub fn bytes128(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES128)
            }
            ///256 bytes CRAM page size
            #[inline(always)]
            pub fn bytes256(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES256)
            }
            ///512 bytes CRAM page size
            #[inline(always)]
            pub fn bytes512(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES512)
            }
            ///1024 bytes CRAM page size
            #[inline(always)]
            pub fn bytes1024(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES1024)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | ((value as u32 & 0x07) << 16);
                self.w
            }
        }
        impl R {
            ///Bit 19 - CBURSTRW
            #[inline(always)]
            pub fn cburstrw(&self) -> CBURSTRW_R {
                CBURSTRW_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 15 - ASYNCWAIT
            #[inline(always)]
            pub fn asyncwait(&self) -> ASYNCWAIT_R {
                ASYNCWAIT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - EXTMOD
            #[inline(always)]
            pub fn extmod(&self) -> EXTMOD_R {
                EXTMOD_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - WAITEN
            #[inline(always)]
            pub fn waiten(&self) -> WAITEN_R {
                WAITEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - WREN
            #[inline(always)]
            pub fn wren(&self) -> WREN_R {
                WREN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - WAITCFG
            #[inline(always)]
            pub fn waitcfg(&self) -> WAITCFG_R {
                WAITCFG_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 9 - WAITPOL
            #[inline(always)]
            pub fn waitpol(&self) -> WAITPOL_R {
                WAITPOL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - BURSTEN
            #[inline(always)]
            pub fn bursten(&self) -> BURSTEN_R {
                BURSTEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 6 - FACCEN
            #[inline(always)]
            pub fn faccen(&self) -> FACCEN_R {
                FACCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bits 4:5 - MWID
            #[inline(always)]
            pub fn mwid(&self) -> MWID_R {
                MWID_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            ///Bits 2:3 - MTYP
            #[inline(always)]
            pub fn mtyp(&self) -> MTYP_R {
                MTYP_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bit 1 - MUXEN
            #[inline(always)]
            pub fn muxen(&self) -> MUXEN_R {
                MUXEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - MBKEN
            #[inline(always)]
            pub fn mbken(&self) -> MBKEN_R {
                MBKEN_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 10 - WRAPMOD
            #[inline(always)]
            pub fn wrapmod(&self) -> WRAPMOD_R {
                WRAPMOD_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 16:18 - CRAM page size
            #[inline(always)]
            pub fn cpsize(&self) -> CPSIZE_R {
                CPSIZE_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            ///Bit 19 - CBURSTRW
            #[inline(always)]
            pub fn cburstrw(&mut self) -> CBURSTRW_W {
                CBURSTRW_W { w: self }
            }
            ///Bit 15 - ASYNCWAIT
            #[inline(always)]
            pub fn asyncwait(&mut self) -> ASYNCWAIT_W {
                ASYNCWAIT_W { w: self }
            }
            ///Bit 14 - EXTMOD
            #[inline(always)]
            pub fn extmod(&mut self) -> EXTMOD_W {
                EXTMOD_W { w: self }
            }
            ///Bit 13 - WAITEN
            #[inline(always)]
            pub fn waiten(&mut self) -> WAITEN_W {
                WAITEN_W { w: self }
            }
            ///Bit 12 - WREN
            #[inline(always)]
            pub fn wren(&mut self) -> WREN_W {
                WREN_W { w: self }
            }
            ///Bit 11 - WAITCFG
            #[inline(always)]
            pub fn waitcfg(&mut self) -> WAITCFG_W {
                WAITCFG_W { w: self }
            }
            ///Bit 9 - WAITPOL
            #[inline(always)]
            pub fn waitpol(&mut self) -> WAITPOL_W {
                WAITPOL_W { w: self }
            }
            ///Bit 8 - BURSTEN
            #[inline(always)]
            pub fn bursten(&mut self) -> BURSTEN_W {
                BURSTEN_W { w: self }
            }
            ///Bit 6 - FACCEN
            #[inline(always)]
            pub fn faccen(&mut self) -> FACCEN_W {
                FACCEN_W { w: self }
            }
            ///Bits 4:5 - MWID
            #[inline(always)]
            pub fn mwid(&mut self) -> MWID_W {
                MWID_W { w: self }
            }
            ///Bits 2:3 - MTYP
            #[inline(always)]
            pub fn mtyp(&mut self) -> MTYP_W {
                MTYP_W { w: self }
            }
            ///Bit 1 - MUXEN
            #[inline(always)]
            pub fn muxen(&mut self) -> MUXEN_W {
                MUXEN_W { w: self }
            }
            ///Bit 0 - MBKEN
            #[inline(always)]
            pub fn mbken(&mut self) -> MBKEN_W {
                MBKEN_W { w: self }
            }
            ///Bit 10 - WRAPMOD
            #[inline(always)]
            pub fn wrapmod(&mut self) -> WRAPMOD_W {
                WRAPMOD_W { w: self }
            }
            ///Bits 16:18 - CRAM page size
            #[inline(always)]
            pub fn cpsize(&mut self) -> CPSIZE_W {
                CPSIZE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SRAM/NOR-Flash chip-select control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bcr1](index.html) module
        pub struct BCR1_SPEC;
        impl crate::RegisterSpec for BCR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bcr1::R](R) reader structure
        impl crate::Readable for BCR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bcr1::W](W) writer structure
        impl crate::Writable for BCR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BCR1 to value 0x30d0
        impl crate::Resettable for BCR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x30d0
            }
        }
    }
    ///BTR register accessor: an alias for `Reg<BTR_SPEC>`
    pub type BTR = crate::Reg<btr::BTR_SPEC>;
    ///SRAM/NOR-Flash chip-select timing register 1
    pub mod btr {
        ///Register `BTR%s` reader
        pub struct R(crate::R<BTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BTR_SPEC>> for R {
            fn from(reader: crate::R<BTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BTR%s` writer
        pub struct W(crate::W<BTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BTR_SPEC>> for W {
            fn from(writer: crate::W<BTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///ACCMOD
        ///
        ///Value on reset: 3
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ACCMOD_A {
            ///0: Access mode A
            A = 0,
            ///1: Access mode B
            B = 1,
            ///2: Access mode C
            C = 2,
            ///3: Access mode D
            D = 3,
        }
        impl From<ACCMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: ACCMOD_A) -> Self {
                variant as _
            }
        }
        ///Field `ACCMOD` reader - ACCMOD
        pub struct ACCMOD_R(crate::FieldReader<u8, ACCMOD_A>);
        impl ACCMOD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ACCMOD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ACCMOD_A {
                match self.bits {
                    0 => ACCMOD_A::A,
                    1 => ACCMOD_A::B,
                    2 => ACCMOD_A::C,
                    3 => ACCMOD_A::D,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `A`
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                **self == ACCMOD_A::A
            }
            ///Checks if the value of the field is `B`
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                **self == ACCMOD_A::B
            }
            ///Checks if the value of the field is `C`
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                **self == ACCMOD_A::C
            }
            ///Checks if the value of the field is `D`
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                **self == ACCMOD_A::D
            }
        }
        impl core::ops::Deref for ACCMOD_R {
            type Target = crate::FieldReader<u8, ACCMOD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ACCMOD` writer - ACCMOD
        pub struct ACCMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACCMOD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ACCMOD_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Access mode A
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(ACCMOD_A::A)
            }
            ///Access mode B
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(ACCMOD_A::B)
            }
            ///Access mode C
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(ACCMOD_A::C)
            }
            ///Access mode D
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(ACCMOD_A::D)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | ((value as u32 & 0x03) << 28);
                self.w
            }
        }
        ///Field `DATLAT` reader - DATLAT
        pub struct DATLAT_R(crate::FieldReader<u8, u8>);
        impl DATLAT_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATLAT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATLAT_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DATLAT` writer - DATLAT
        pub struct DATLAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATLAT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | ((value as u32 & 0x0f) << 24);
                self.w
            }
        }
        ///Field `CLKDIV` reader - CLKDIV
        pub struct CLKDIV_R(crate::FieldReader<u8, u8>);
        impl CLKDIV_R {
            pub(crate) fn new(bits: u8) -> Self {
                CLKDIV_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CLKDIV_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CLKDIV` writer - CLKDIV
        pub struct CLKDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKDIV_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | ((value as u32 & 0x0f) << 20);
                self.w
            }
        }
        ///Field `BUSTURN` reader - BUSTURN
        pub struct BUSTURN_R(crate::FieldReader<u8, u8>);
        impl BUSTURN_R {
            pub(crate) fn new(bits: u8) -> Self {
                BUSTURN_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BUSTURN_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BUSTURN` writer - BUSTURN
        pub struct BUSTURN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BUSTURN_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | ((value as u32 & 0x0f) << 16);
                self.w
            }
        }
        ///Field `DATAST` reader - DATAST
        pub struct DATAST_R(crate::FieldReader<u8, u8>);
        impl DATAST_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATAST_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATAST_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DATAST` writer - DATAST
        pub struct DATAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAST_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | ((value as u32 & 0xff) << 8);
                self.w
            }
        }
        ///Field `ADDHLD` reader - ADDHLD
        pub struct ADDHLD_R(crate::FieldReader<u8, u8>);
        impl ADDHLD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADDHLD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADDHLD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADDHLD` writer - ADDHLD
        pub struct ADDHLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDHLD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `ADDSET` reader - ADDSET
        pub struct ADDSET_R(crate::FieldReader<u8, u8>);
        impl ADDSET_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADDSET_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADDSET_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADDSET` writer - ADDSET
        pub struct ADDSET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDSET_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl R {
            ///Bits 28:29 - ACCMOD
            #[inline(always)]
            pub fn accmod(&self) -> ACCMOD_R {
                ACCMOD_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            ///Bits 24:27 - DATLAT
            #[inline(always)]
            pub fn datlat(&self) -> DATLAT_R {
                DATLAT_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bits 20:23 - CLKDIV
            #[inline(always)]
            pub fn clkdiv(&self) -> CLKDIV_R {
                CLKDIV_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 16:19 - BUSTURN
            #[inline(always)]
            pub fn busturn(&self) -> BUSTURN_R {
                BUSTURN_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
            ///Bits 8:15 - DATAST
            #[inline(always)]
            pub fn datast(&self) -> DATAST_R {
                DATAST_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 4:7 - ADDHLD
            #[inline(always)]
            pub fn addhld(&self) -> ADDHLD_R {
                ADDHLD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 0:3 - ADDSET
            #[inline(always)]
            pub fn addset(&self) -> ADDSET_R {
                ADDSET_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 28:29 - ACCMOD
            #[inline(always)]
            pub fn accmod(&mut self) -> ACCMOD_W {
                ACCMOD_W { w: self }
            }
            ///Bits 24:27 - DATLAT
            #[inline(always)]
            pub fn datlat(&mut self) -> DATLAT_W {
                DATLAT_W { w: self }
            }
            ///Bits 20:23 - CLKDIV
            #[inline(always)]
            pub fn clkdiv(&mut self) -> CLKDIV_W {
                CLKDIV_W { w: self }
            }
            ///Bits 16:19 - BUSTURN
            #[inline(always)]
            pub fn busturn(&mut self) -> BUSTURN_W {
                BUSTURN_W { w: self }
            }
            ///Bits 8:15 - DATAST
            #[inline(always)]
            pub fn datast(&mut self) -> DATAST_W {
                DATAST_W { w: self }
            }
            ///Bits 4:7 - ADDHLD
            #[inline(always)]
            pub fn addhld(&mut self) -> ADDHLD_W {
                ADDHLD_W { w: self }
            }
            ///Bits 0:3 - ADDSET
            #[inline(always)]
            pub fn addset(&mut self) -> ADDSET_W {
                ADDSET_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SRAM/NOR-Flash chip-select timing register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [btr](index.html) module
        pub struct BTR_SPEC;
        impl crate::RegisterSpec for BTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [btr::R](R) reader structure
        impl crate::Readable for BTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [btr::W](W) writer structure
        impl crate::Writable for BTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BTR%s to value 0xffff_ffff
        impl crate::Resettable for BTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xffff_ffff
            }
        }
    }
    ///BCR register accessor: an alias for `Reg<BCR_SPEC>`
    pub type BCR = crate::Reg<bcr::BCR_SPEC>;
    ///SRAM/NOR-Flash chip-select control register 2
    pub mod bcr {
        ///Register `BCR%s` reader
        pub struct R(crate::R<BCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BCR_SPEC>> for R {
            fn from(reader: crate::R<BCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BCR%s` writer
        pub struct W(crate::W<BCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BCR_SPEC>> for W {
            fn from(writer: crate::W<BCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///CBURSTRW
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CBURSTRW_A {
            ///1: Write operations are performed in synchronous mode
            ENABLED = 1,
            ///0: Write operations are always performed in asynchronous mode
            DISABLED = 0,
        }
        impl From<CBURSTRW_A> for bool {
            #[inline(always)]
            fn from(variant: CBURSTRW_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CBURSTRW` reader - CBURSTRW
        pub struct CBURSTRW_R(crate::FieldReader<bool, CBURSTRW_A>);
        impl CBURSTRW_R {
            pub(crate) fn new(bits: bool) -> Self {
                CBURSTRW_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CBURSTRW_A {
                match self.bits {
                    true => CBURSTRW_A::ENABLED,
                    false => CBURSTRW_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CBURSTRW_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CBURSTRW_A::DISABLED
            }
        }
        impl core::ops::Deref for CBURSTRW_R {
            type Target = crate::FieldReader<bool, CBURSTRW_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CBURSTRW` writer - CBURSTRW
        pub struct CBURSTRW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CBURSTRW_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CBURSTRW_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Write operations are performed in synchronous mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::ENABLED)
            }
            ///Write operations are always performed in asynchronous mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CBURSTRW_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///ASYNCWAIT
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASYNCWAIT_A {
            ///0: Wait signal not used in asynchronous mode
            DISABLED = 0,
            ///1: Wait signal used even in asynchronous mode
            ENABLED = 1,
        }
        impl From<ASYNCWAIT_A> for bool {
            #[inline(always)]
            fn from(variant: ASYNCWAIT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ASYNCWAIT` reader - ASYNCWAIT
        pub struct ASYNCWAIT_R(crate::FieldReader<bool, ASYNCWAIT_A>);
        impl ASYNCWAIT_R {
            pub(crate) fn new(bits: bool) -> Self {
                ASYNCWAIT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASYNCWAIT_A {
                match self.bits {
                    false => ASYNCWAIT_A::DISABLED,
                    true => ASYNCWAIT_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ASYNCWAIT_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ASYNCWAIT_A::ENABLED
            }
        }
        impl core::ops::Deref for ASYNCWAIT_R {
            type Target = crate::FieldReader<bool, ASYNCWAIT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ASYNCWAIT` writer - ASYNCWAIT
        pub struct ASYNCWAIT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASYNCWAIT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ASYNCWAIT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Wait signal not used in asynchronous mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::DISABLED)
            }
            ///Wait signal used even in asynchronous mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASYNCWAIT_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///EXTMOD
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTMOD_A {
            ///0: Values inside the FMC_BWTR are not taken into account
            DISABLED = 0,
            ///1: Values inside the FMC_BWTR are taken into account
            ENABLED = 1,
        }
        impl From<EXTMOD_A> for bool {
            #[inline(always)]
            fn from(variant: EXTMOD_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EXTMOD` reader - EXTMOD
        pub struct EXTMOD_R(crate::FieldReader<bool, EXTMOD_A>);
        impl EXTMOD_R {
            pub(crate) fn new(bits: bool) -> Self {
                EXTMOD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EXTMOD_A {
                match self.bits {
                    false => EXTMOD_A::DISABLED,
                    true => EXTMOD_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EXTMOD_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EXTMOD_A::ENABLED
            }
        }
        impl core::ops::Deref for EXTMOD_R {
            type Target = crate::FieldReader<bool, EXTMOD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTMOD` writer - EXTMOD
        pub struct EXTMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTMOD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EXTMOD_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Values inside the FMC_BWTR are not taken into account
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::DISABLED)
            }
            ///Values inside the FMC_BWTR are taken into account
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTMOD_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///WAITEN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITEN_A {
            ///0: Values inside the FMC_BWTR are taken into account
            DISABLED = 0,
            ///1: NWAIT signal enabled
            ENABLED = 1,
        }
        impl From<WAITEN_A> for bool {
            #[inline(always)]
            fn from(variant: WAITEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITEN` reader - WAITEN
        pub struct WAITEN_R(crate::FieldReader<bool, WAITEN_A>);
        impl WAITEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITEN_A {
                match self.bits {
                    false => WAITEN_A::DISABLED,
                    true => WAITEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WAITEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == WAITEN_A::ENABLED
            }
        }
        impl core::ops::Deref for WAITEN_R {
            type Target = crate::FieldReader<bool, WAITEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITEN` writer - WAITEN
        pub struct WAITEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Values inside the FMC_BWTR are taken into account
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAITEN_A::DISABLED)
            }
            ///NWAIT signal enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WAITEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///WREN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WREN_A {
            ///0: Write operations disabled for the bank by the FMC
            DISABLED = 0,
            ///1: Write operations enabled for the bank by the FMC
            ENABLED = 1,
        }
        impl From<WREN_A> for bool {
            #[inline(always)]
            fn from(variant: WREN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WREN` reader - WREN
        pub struct WREN_R(crate::FieldReader<bool, WREN_A>);
        impl WREN_R {
            pub(crate) fn new(bits: bool) -> Self {
                WREN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WREN_A {
                match self.bits {
                    false => WREN_A::DISABLED,
                    true => WREN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WREN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == WREN_A::ENABLED
            }
        }
        impl core::ops::Deref for WREN_R {
            type Target = crate::FieldReader<bool, WREN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WREN` writer - WREN
        pub struct WREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Write operations disabled for the bank by the FMC
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WREN_A::DISABLED)
            }
            ///Write operations enabled for the bank by the FMC
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///WAITCFG
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITCFG_A {
            ///0: NWAIT signal is active one data cycle before wait state
            BEFOREWAITSTATE = 0,
            ///1: NWAIT signal is active during wait state
            DURINGWAITSTATE = 1,
        }
        impl From<WAITCFG_A> for bool {
            #[inline(always)]
            fn from(variant: WAITCFG_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITCFG` reader - WAITCFG
        pub struct WAITCFG_R(crate::FieldReader<bool, WAITCFG_A>);
        impl WAITCFG_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITCFG_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITCFG_A {
                match self.bits {
                    false => WAITCFG_A::BEFOREWAITSTATE,
                    true => WAITCFG_A::DURINGWAITSTATE,
                }
            }
            ///Checks if the value of the field is `BEFOREWAITSTATE`
            #[inline(always)]
            pub fn is_before_wait_state(&self) -> bool {
                **self == WAITCFG_A::BEFOREWAITSTATE
            }
            ///Checks if the value of the field is `DURINGWAITSTATE`
            #[inline(always)]
            pub fn is_during_wait_state(&self) -> bool {
                **self == WAITCFG_A::DURINGWAITSTATE
            }
        }
        impl core::ops::Deref for WAITCFG_R {
            type Target = crate::FieldReader<bool, WAITCFG_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITCFG` writer - WAITCFG
        pub struct WAITCFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITCFG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITCFG_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///NWAIT signal is active one data cycle before wait state
            #[inline(always)]
            pub fn before_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::BEFOREWAITSTATE)
            }
            ///NWAIT signal is active during wait state
            #[inline(always)]
            pub fn during_wait_state(self) -> &'a mut W {
                self.variant(WAITCFG_A::DURINGWAITSTATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `WRAPMOD` reader - WRAPMOD
        pub struct WRAPMOD_R(crate::FieldReader<bool, bool>);
        impl WRAPMOD_R {
            pub(crate) fn new(bits: bool) -> Self {
                WRAPMOD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WRAPMOD_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WRAPMOD` writer - WRAPMOD
        pub struct WRAPMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRAPMOD_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///WAITPOL
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAITPOL_A {
            ///0: NWAIT active low
            ACTIVELOW = 0,
            ///1: NWAIT active high
            ACTIVEHIGH = 1,
        }
        impl From<WAITPOL_A> for bool {
            #[inline(always)]
            fn from(variant: WAITPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAITPOL` reader - WAITPOL
        pub struct WAITPOL_R(crate::FieldReader<bool, WAITPOL_A>);
        impl WAITPOL_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAITPOL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAITPOL_A {
                match self.bits {
                    false => WAITPOL_A::ACTIVELOW,
                    true => WAITPOL_A::ACTIVEHIGH,
                }
            }
            ///Checks if the value of the field is `ACTIVELOW`
            #[inline(always)]
            pub fn is_active_low(&self) -> bool {
                **self == WAITPOL_A::ACTIVELOW
            }
            ///Checks if the value of the field is `ACTIVEHIGH`
            #[inline(always)]
            pub fn is_active_high(&self) -> bool {
                **self == WAITPOL_A::ACTIVEHIGH
            }
        }
        impl core::ops::Deref for WAITPOL_R {
            type Target = crate::FieldReader<bool, WAITPOL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAITPOL` writer - WAITPOL
        pub struct WAITPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAITPOL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAITPOL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///NWAIT active low
            #[inline(always)]
            pub fn active_low(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVELOW)
            }
            ///NWAIT active high
            #[inline(always)]
            pub fn active_high(self) -> &'a mut W {
                self.variant(WAITPOL_A::ACTIVEHIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///BURSTEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BURSTEN_A {
            ///0: Burst mode disabled
            DISABLED = 0,
            ///1: Burst mode enabled
            ENABLED = 1,
        }
        impl From<BURSTEN_A> for bool {
            #[inline(always)]
            fn from(variant: BURSTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BURSTEN` reader - BURSTEN
        pub struct BURSTEN_R(crate::FieldReader<bool, BURSTEN_A>);
        impl BURSTEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                BURSTEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BURSTEN_A {
                match self.bits {
                    false => BURSTEN_A::DISABLED,
                    true => BURSTEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == BURSTEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == BURSTEN_A::ENABLED
            }
        }
        impl core::ops::Deref for BURSTEN_R {
            type Target = crate::FieldReader<bool, BURSTEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BURSTEN` writer - BURSTEN
        pub struct BURSTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BURSTEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BURSTEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Burst mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::DISABLED)
            }
            ///Burst mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BURSTEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///FACCEN
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum FACCEN_A {
            ///0: Corresponding NOR Flash memory access is disabled
            DISABLED = 0,
            ///1: Corresponding NOR Flash memory access is enabled
            ENABLED = 1,
        }
        impl From<FACCEN_A> for bool {
            #[inline(always)]
            fn from(variant: FACCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `FACCEN` reader - FACCEN
        pub struct FACCEN_R(crate::FieldReader<bool, FACCEN_A>);
        impl FACCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                FACCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> FACCEN_A {
                match self.bits {
                    false => FACCEN_A::DISABLED,
                    true => FACCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == FACCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == FACCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for FACCEN_R {
            type Target = crate::FieldReader<bool, FACCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FACCEN` writer - FACCEN
        pub struct FACCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FACCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: FACCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Corresponding NOR Flash memory access is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FACCEN_A::DISABLED)
            }
            ///Corresponding NOR Flash memory access is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FACCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///MWID
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MWID_A {
            ///0: Memory data bus width 8 bits
            BITS8 = 0,
            ///1: Memory data bus width 16 bits
            BITS16 = 1,
            ///2: Memory data bus width 32 bits
            BITS32 = 2,
        }
        impl From<MWID_A> for u8 {
            #[inline(always)]
            fn from(variant: MWID_A) -> Self {
                variant as _
            }
        }
        ///Field `MWID` reader - MWID
        pub struct MWID_R(crate::FieldReader<u8, MWID_A>);
        impl MWID_R {
            pub(crate) fn new(bits: u8) -> Self {
                MWID_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MWID_A> {
                match self.bits {
                    0 => Some(MWID_A::BITS8),
                    1 => Some(MWID_A::BITS16),
                    2 => Some(MWID_A::BITS32),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `BITS8`
            #[inline(always)]
            pub fn is_bits8(&self) -> bool {
                **self == MWID_A::BITS8
            }
            ///Checks if the value of the field is `BITS16`
            #[inline(always)]
            pub fn is_bits16(&self) -> bool {
                **self == MWID_A::BITS16
            }
            ///Checks if the value of the field is `BITS32`
            #[inline(always)]
            pub fn is_bits32(&self) -> bool {
                **self == MWID_A::BITS32
            }
        }
        impl core::ops::Deref for MWID_R {
            type Target = crate::FieldReader<u8, MWID_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MWID` writer - MWID
        pub struct MWID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MWID_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MWID_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Memory data bus width 8 bits
            #[inline(always)]
            pub fn bits8(self) -> &'a mut W {
                self.variant(MWID_A::BITS8)
            }
            ///Memory data bus width 16 bits
            #[inline(always)]
            pub fn bits16(self) -> &'a mut W {
                self.variant(MWID_A::BITS16)
            }
            ///Memory data bus width 32 bits
            #[inline(always)]
            pub fn bits32(self) -> &'a mut W {
                self.variant(MWID_A::BITS32)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | ((value as u32 & 0x03) << 4);
                self.w
            }
        }
        ///MTYP
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MTYP_A {
            ///0: SRAM memory type
            SRAM = 0,
            ///1: PSRAM (CRAM) memory type
            PSRAM = 1,
            ///2: NOR Flash/OneNAND Flash
            FLASH = 2,
        }
        impl From<MTYP_A> for u8 {
            #[inline(always)]
            fn from(variant: MTYP_A) -> Self {
                variant as _
            }
        }
        ///Field `MTYP` reader - MTYP
        pub struct MTYP_R(crate::FieldReader<u8, MTYP_A>);
        impl MTYP_R {
            pub(crate) fn new(bits: u8) -> Self {
                MTYP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MTYP_A> {
                match self.bits {
                    0 => Some(MTYP_A::SRAM),
                    1 => Some(MTYP_A::PSRAM),
                    2 => Some(MTYP_A::FLASH),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `SRAM`
            #[inline(always)]
            pub fn is_sram(&self) -> bool {
                **self == MTYP_A::SRAM
            }
            ///Checks if the value of the field is `PSRAM`
            #[inline(always)]
            pub fn is_psram(&self) -> bool {
                **self == MTYP_A::PSRAM
            }
            ///Checks if the value of the field is `FLASH`
            #[inline(always)]
            pub fn is_flash(&self) -> bool {
                **self == MTYP_A::FLASH
            }
        }
        impl core::ops::Deref for MTYP_R {
            type Target = crate::FieldReader<u8, MTYP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MTYP` writer - MTYP
        pub struct MTYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MTYP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MTYP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///SRAM memory type
            #[inline(always)]
            pub fn sram(self) -> &'a mut W {
                self.variant(MTYP_A::SRAM)
            }
            ///PSRAM (CRAM) memory type
            #[inline(always)]
            pub fn psram(self) -> &'a mut W {
                self.variant(MTYP_A::PSRAM)
            }
            ///NOR Flash/OneNAND Flash
            #[inline(always)]
            pub fn flash(self) -> &'a mut W {
                self.variant(MTYP_A::FLASH)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///MUXEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MUXEN_A {
            ///0: Address/Data non-multiplexed
            DISABLED = 0,
            ///1: Address/Data multiplexed on databus
            ENABLED = 1,
        }
        impl From<MUXEN_A> for bool {
            #[inline(always)]
            fn from(variant: MUXEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MUXEN` reader - MUXEN
        pub struct MUXEN_R(crate::FieldReader<bool, MUXEN_A>);
        impl MUXEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                MUXEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MUXEN_A {
                match self.bits {
                    false => MUXEN_A::DISABLED,
                    true => MUXEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == MUXEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == MUXEN_A::ENABLED
            }
        }
        impl core::ops::Deref for MUXEN_R {
            type Target = crate::FieldReader<bool, MUXEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MUXEN` writer - MUXEN
        pub struct MUXEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MUXEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MUXEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Address/Data non-multiplexed
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MUXEN_A::DISABLED)
            }
            ///Address/Data multiplexed on databus
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MUXEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///MBKEN
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MBKEN_A {
            ///0: Corresponding memory bank is disabled
            DISABLED = 0,
            ///1: Corresponding memory bank is enabled
            ENABLED = 1,
        }
        impl From<MBKEN_A> for bool {
            #[inline(always)]
            fn from(variant: MBKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MBKEN` reader - MBKEN
        pub struct MBKEN_R(crate::FieldReader<bool, MBKEN_A>);
        impl MBKEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                MBKEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MBKEN_A {
                match self.bits {
                    false => MBKEN_A::DISABLED,
                    true => MBKEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == MBKEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == MBKEN_A::ENABLED
            }
        }
        impl core::ops::Deref for MBKEN_R {
            type Target = crate::FieldReader<bool, MBKEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MBKEN` writer - MBKEN
        pub struct MBKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MBKEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MBKEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Corresponding memory bank is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(MBKEN_A::DISABLED)
            }
            ///Corresponding memory bank is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MBKEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///CRAM page size
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CPSIZE_A {
            ///0: No burst split when crossing page boundary
            NOBURSTSPLIT = 0,
            ///1: 128 bytes CRAM page size
            BYTES128 = 1,
            ///2: 256 bytes CRAM page size
            BYTES256 = 2,
            ///3: 512 bytes CRAM page size
            BYTES512 = 3,
            ///4: 1024 bytes CRAM page size
            BYTES1024 = 4,
        }
        impl From<CPSIZE_A> for u8 {
            #[inline(always)]
            fn from(variant: CPSIZE_A) -> Self {
                variant as _
            }
        }
        ///Field `CPSIZE` reader - CRAM page size
        pub struct CPSIZE_R(crate::FieldReader<u8, CPSIZE_A>);
        impl CPSIZE_R {
            pub(crate) fn new(bits: u8) -> Self {
                CPSIZE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CPSIZE_A> {
                match self.bits {
                    0 => Some(CPSIZE_A::NOBURSTSPLIT),
                    1 => Some(CPSIZE_A::BYTES128),
                    2 => Some(CPSIZE_A::BYTES256),
                    3 => Some(CPSIZE_A::BYTES512),
                    4 => Some(CPSIZE_A::BYTES1024),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NOBURSTSPLIT`
            #[inline(always)]
            pub fn is_no_burst_split(&self) -> bool {
                **self == CPSIZE_A::NOBURSTSPLIT
            }
            ///Checks if the value of the field is `BYTES128`
            #[inline(always)]
            pub fn is_bytes128(&self) -> bool {
                **self == CPSIZE_A::BYTES128
            }
            ///Checks if the value of the field is `BYTES256`
            #[inline(always)]
            pub fn is_bytes256(&self) -> bool {
                **self == CPSIZE_A::BYTES256
            }
            ///Checks if the value of the field is `BYTES512`
            #[inline(always)]
            pub fn is_bytes512(&self) -> bool {
                **self == CPSIZE_A::BYTES512
            }
            ///Checks if the value of the field is `BYTES1024`
            #[inline(always)]
            pub fn is_bytes1024(&self) -> bool {
                **self == CPSIZE_A::BYTES1024
            }
        }
        impl core::ops::Deref for CPSIZE_R {
            type Target = crate::FieldReader<u8, CPSIZE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPSIZE` writer - CRAM page size
        pub struct CPSIZE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPSIZE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPSIZE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///No burst split when crossing page boundary
            #[inline(always)]
            pub fn no_burst_split(self) -> &'a mut W {
                self.variant(CPSIZE_A::NOBURSTSPLIT)
            }
            ///128 bytes CRAM page size
            #[inline(always)]
            pub fn bytes128(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES128)
            }
            ///256 bytes CRAM page size
            #[inline(always)]
            pub fn bytes256(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES256)
            }
            ///512 bytes CRAM page size
            #[inline(always)]
            pub fn bytes512(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES512)
            }
            ///1024 bytes CRAM page size
            #[inline(always)]
            pub fn bytes1024(self) -> &'a mut W {
                self.variant(CPSIZE_A::BYTES1024)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 16)) | ((value as u32 & 0x07) << 16);
                self.w
            }
        }
        impl R {
            ///Bit 19 - CBURSTRW
            #[inline(always)]
            pub fn cburstrw(&self) -> CBURSTRW_R {
                CBURSTRW_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 15 - ASYNCWAIT
            #[inline(always)]
            pub fn asyncwait(&self) -> ASYNCWAIT_R {
                ASYNCWAIT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - EXTMOD
            #[inline(always)]
            pub fn extmod(&self) -> EXTMOD_R {
                EXTMOD_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - WAITEN
            #[inline(always)]
            pub fn waiten(&self) -> WAITEN_R {
                WAITEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - WREN
            #[inline(always)]
            pub fn wren(&self) -> WREN_R {
                WREN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - WAITCFG
            #[inline(always)]
            pub fn waitcfg(&self) -> WAITCFG_R {
                WAITCFG_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - WRAPMOD
            #[inline(always)]
            pub fn wrapmod(&self) -> WRAPMOD_R {
                WRAPMOD_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - WAITPOL
            #[inline(always)]
            pub fn waitpol(&self) -> WAITPOL_R {
                WAITPOL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - BURSTEN
            #[inline(always)]
            pub fn bursten(&self) -> BURSTEN_R {
                BURSTEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 6 - FACCEN
            #[inline(always)]
            pub fn faccen(&self) -> FACCEN_R {
                FACCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bits 4:5 - MWID
            #[inline(always)]
            pub fn mwid(&self) -> MWID_R {
                MWID_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            ///Bits 2:3 - MTYP
            #[inline(always)]
            pub fn mtyp(&self) -> MTYP_R {
                MTYP_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bit 1 - MUXEN
            #[inline(always)]
            pub fn muxen(&self) -> MUXEN_R {
                MUXEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - MBKEN
            #[inline(always)]
            pub fn mbken(&self) -> MBKEN_R {
                MBKEN_R::new((self.bits & 0x01) != 0)
            }
            ///Bits 16:18 - CRAM page size
            #[inline(always)]
            pub fn cpsize(&self) -> CPSIZE_R {
                CPSIZE_R::new(((self.bits >> 16) & 0x07) as u8)
            }
        }
        impl W {
            ///Bit 19 - CBURSTRW
            #[inline(always)]
            pub fn cburstrw(&mut self) -> CBURSTRW_W {
                CBURSTRW_W { w: self }
            }
            ///Bit 15 - ASYNCWAIT
            #[inline(always)]
            pub fn asyncwait(&mut self) -> ASYNCWAIT_W {
                ASYNCWAIT_W { w: self }
            }
            ///Bit 14 - EXTMOD
            #[inline(always)]
            pub fn extmod(&mut self) -> EXTMOD_W {
                EXTMOD_W { w: self }
            }
            ///Bit 13 - WAITEN
            #[inline(always)]
            pub fn waiten(&mut self) -> WAITEN_W {
                WAITEN_W { w: self }
            }
            ///Bit 12 - WREN
            #[inline(always)]
            pub fn wren(&mut self) -> WREN_W {
                WREN_W { w: self }
            }
            ///Bit 11 - WAITCFG
            #[inline(always)]
            pub fn waitcfg(&mut self) -> WAITCFG_W {
                WAITCFG_W { w: self }
            }
            ///Bit 10 - WRAPMOD
            #[inline(always)]
            pub fn wrapmod(&mut self) -> WRAPMOD_W {
                WRAPMOD_W { w: self }
            }
            ///Bit 9 - WAITPOL
            #[inline(always)]
            pub fn waitpol(&mut self) -> WAITPOL_W {
                WAITPOL_W { w: self }
            }
            ///Bit 8 - BURSTEN
            #[inline(always)]
            pub fn bursten(&mut self) -> BURSTEN_W {
                BURSTEN_W { w: self }
            }
            ///Bit 6 - FACCEN
            #[inline(always)]
            pub fn faccen(&mut self) -> FACCEN_W {
                FACCEN_W { w: self }
            }
            ///Bits 4:5 - MWID
            #[inline(always)]
            pub fn mwid(&mut self) -> MWID_W {
                MWID_W { w: self }
            }
            ///Bits 2:3 - MTYP
            #[inline(always)]
            pub fn mtyp(&mut self) -> MTYP_W {
                MTYP_W { w: self }
            }
            ///Bit 1 - MUXEN
            #[inline(always)]
            pub fn muxen(&mut self) -> MUXEN_W {
                MUXEN_W { w: self }
            }
            ///Bit 0 - MBKEN
            #[inline(always)]
            pub fn mbken(&mut self) -> MBKEN_W {
                MBKEN_W { w: self }
            }
            ///Bits 16:18 - CRAM page size
            #[inline(always)]
            pub fn cpsize(&mut self) -> CPSIZE_W {
                CPSIZE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SRAM/NOR-Flash chip-select control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bcr](index.html) module
        pub struct BCR_SPEC;
        impl crate::RegisterSpec for BCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bcr::R](R) reader structure
        impl crate::Readable for BCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bcr::W](W) writer structure
        impl crate::Writable for BCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BCR%s to value 0x30d0
        impl crate::Resettable for BCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x30d0
            }
        }
    }
    ///BWTR register accessor: an alias for `Reg<BWTR_SPEC>`
    pub type BWTR = crate::Reg<bwtr::BWTR_SPEC>;
    ///SRAM/NOR-Flash write timing registers 1
    pub mod bwtr {
        ///Register `BWTR%s` reader
        pub struct R(crate::R<BWTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BWTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BWTR_SPEC>> for R {
            fn from(reader: crate::R<BWTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BWTR%s` writer
        pub struct W(crate::W<BWTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BWTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BWTR_SPEC>> for W {
            fn from(writer: crate::W<BWTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///ACCMOD
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ACCMOD_A {
            ///0: Access mode A
            A = 0,
            ///1: Access mode B
            B = 1,
            ///2: Access mode C
            C = 2,
            ///3: Access mode D
            D = 3,
        }
        impl From<ACCMOD_A> for u8 {
            #[inline(always)]
            fn from(variant: ACCMOD_A) -> Self {
                variant as _
            }
        }
        ///Field `ACCMOD` reader - ACCMOD
        pub struct ACCMOD_R(crate::FieldReader<u8, ACCMOD_A>);
        impl ACCMOD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ACCMOD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ACCMOD_A {
                match self.bits {
                    0 => ACCMOD_A::A,
                    1 => ACCMOD_A::B,
                    2 => ACCMOD_A::C,
                    3 => ACCMOD_A::D,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `A`
            #[inline(always)]
            pub fn is_a(&self) -> bool {
                **self == ACCMOD_A::A
            }
            ///Checks if the value of the field is `B`
            #[inline(always)]
            pub fn is_b(&self) -> bool {
                **self == ACCMOD_A::B
            }
            ///Checks if the value of the field is `C`
            #[inline(always)]
            pub fn is_c(&self) -> bool {
                **self == ACCMOD_A::C
            }
            ///Checks if the value of the field is `D`
            #[inline(always)]
            pub fn is_d(&self) -> bool {
                **self == ACCMOD_A::D
            }
        }
        impl core::ops::Deref for ACCMOD_R {
            type Target = crate::FieldReader<u8, ACCMOD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ACCMOD` writer - ACCMOD
        pub struct ACCMOD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACCMOD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ACCMOD_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Access mode A
            #[inline(always)]
            pub fn a(self) -> &'a mut W {
                self.variant(ACCMOD_A::A)
            }
            ///Access mode B
            #[inline(always)]
            pub fn b(self) -> &'a mut W {
                self.variant(ACCMOD_A::B)
            }
            ///Access mode C
            #[inline(always)]
            pub fn c(self) -> &'a mut W {
                self.variant(ACCMOD_A::C)
            }
            ///Access mode D
            #[inline(always)]
            pub fn d(self) -> &'a mut W {
                self.variant(ACCMOD_A::D)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | ((value as u32 & 0x03) << 28);
                self.w
            }
        }
        ///Field `DATLAT` reader - DATLAT
        pub struct DATLAT_R(crate::FieldReader<u8, u8>);
        impl DATLAT_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATLAT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATLAT_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DATLAT` writer - DATLAT
        pub struct DATLAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATLAT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | ((value as u32 & 0x0f) << 24);
                self.w
            }
        }
        ///Field `CLKDIV` reader - CLKDIV
        pub struct CLKDIV_R(crate::FieldReader<u8, u8>);
        impl CLKDIV_R {
            pub(crate) fn new(bits: u8) -> Self {
                CLKDIV_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CLKDIV_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CLKDIV` writer - CLKDIV
        pub struct CLKDIV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKDIV_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | ((value as u32 & 0x0f) << 20);
                self.w
            }
        }
        ///Field `DATAST` reader - DATAST
        pub struct DATAST_R(crate::FieldReader<u8, u8>);
        impl DATAST_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATAST_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATAST_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DATAST` writer - DATAST
        pub struct DATAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DATAST_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | ((value as u32 & 0xff) << 8);
                self.w
            }
        }
        ///Field `ADDHLD` reader - ADDHLD
        pub struct ADDHLD_R(crate::FieldReader<u8, u8>);
        impl ADDHLD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADDHLD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADDHLD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADDHLD` writer - ADDHLD
        pub struct ADDHLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDHLD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `ADDSET` reader - ADDSET
        pub struct ADDSET_R(crate::FieldReader<u8, u8>);
        impl ADDSET_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADDSET_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADDSET_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADDSET` writer - ADDSET
        pub struct ADDSET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDSET_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `BUSTURN` reader - Bus turnaround phase duration
        pub struct BUSTURN_R(crate::FieldReader<u8, u8>);
        impl BUSTURN_R {
            pub(crate) fn new(bits: u8) -> Self {
                BUSTURN_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BUSTURN_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BUSTURN` writer - Bus turnaround phase duration
        pub struct BUSTURN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BUSTURN_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 16)) | ((value as u32 & 0x0f) << 16);
                self.w
            }
        }
        impl R {
            ///Bits 28:29 - ACCMOD
            #[inline(always)]
            pub fn accmod(&self) -> ACCMOD_R {
                ACCMOD_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            ///Bits 24:27 - DATLAT
            #[inline(always)]
            pub fn datlat(&self) -> DATLAT_R {
                DATLAT_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bits 20:23 - CLKDIV
            #[inline(always)]
            pub fn clkdiv(&self) -> CLKDIV_R {
                CLKDIV_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 8:15 - DATAST
            #[inline(always)]
            pub fn datast(&self) -> DATAST_R {
                DATAST_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 4:7 - ADDHLD
            #[inline(always)]
            pub fn addhld(&self) -> ADDHLD_R {
                ADDHLD_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 0:3 - ADDSET
            #[inline(always)]
            pub fn addset(&self) -> ADDSET_R {
                ADDSET_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 16:19 - Bus turnaround phase duration
            #[inline(always)]
            pub fn busturn(&self) -> BUSTURN_R {
                BUSTURN_R::new(((self.bits >> 16) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 28:29 - ACCMOD
            #[inline(always)]
            pub fn accmod(&mut self) -> ACCMOD_W {
                ACCMOD_W { w: self }
            }
            ///Bits 24:27 - DATLAT
            #[inline(always)]
            pub fn datlat(&mut self) -> DATLAT_W {
                DATLAT_W { w: self }
            }
            ///Bits 20:23 - CLKDIV
            #[inline(always)]
            pub fn clkdiv(&mut self) -> CLKDIV_W {
                CLKDIV_W { w: self }
            }
            ///Bits 8:15 - DATAST
            #[inline(always)]
            pub fn datast(&mut self) -> DATAST_W {
                DATAST_W { w: self }
            }
            ///Bits 4:7 - ADDHLD
            #[inline(always)]
            pub fn addhld(&mut self) -> ADDHLD_W {
                ADDHLD_W { w: self }
            }
            ///Bits 0:3 - ADDSET
            #[inline(always)]
            pub fn addset(&mut self) -> ADDSET_W {
                ADDSET_W { w: self }
            }
            ///Bits 16:19 - Bus turnaround phase duration
            #[inline(always)]
            pub fn busturn(&mut self) -> BUSTURN_W {
                BUSTURN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SRAM/NOR-Flash write timing registers 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bwtr](index.html) module
        pub struct BWTR_SPEC;
        impl crate::RegisterSpec for BWTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bwtr::R](R) reader structure
        impl crate::Readable for BWTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bwtr::W](W) writer structure
        impl crate::Writable for BWTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BWTR%s to value 0x0fff_ffff
        impl crate::Resettable for BWTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x0fff_ffff
            }
        }
    }
}
///Power control
pub struct PWR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PWR {}
impl PWR {
    ///Pointer to the register block
    pub const PTR: *const pwr::RegisterBlock = 0x4000_7000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const pwr::RegisterBlock {
        Self::PTR
    }
}
impl Deref for PWR {
    type Target = pwr::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PWR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PWR").finish()
    }
}
///Power control
pub mod pwr {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Power control register (PWR_CR)
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x04 - Power control register (PWR_CR)
        pub csr: crate::Reg<csr::CSR_SPEC>,
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Power control register (PWR_CR)
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LPDS` reader - Low Power Deep Sleep
        pub struct LPDS_R(crate::FieldReader<bool, bool>);
        impl LPDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                LPDS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LPDS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LPDS` writer - Low Power Deep Sleep
        pub struct LPDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPDS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Power Down Deep Sleep
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PDDS_A {
            ///0: Enter Stop mode when the CPU enters deepsleep
            STOP_MODE = 0,
            ///1: Enter Standby mode when the CPU enters deepsleep
            STANDBY_MODE = 1,
        }
        impl From<PDDS_A> for bool {
            #[inline(always)]
            fn from(variant: PDDS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PDDS` reader - Power Down Deep Sleep
        pub struct PDDS_R(crate::FieldReader<bool, PDDS_A>);
        impl PDDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                PDDS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PDDS_A {
                match self.bits {
                    false => PDDS_A::STOP_MODE,
                    true => PDDS_A::STANDBY_MODE,
                }
            }
            ///Checks if the value of the field is `STOP_MODE`
            #[inline(always)]
            pub fn is_stop_mode(&self) -> bool {
                **self == PDDS_A::STOP_MODE
            }
            ///Checks if the value of the field is `STANDBY_MODE`
            #[inline(always)]
            pub fn is_standby_mode(&self) -> bool {
                **self == PDDS_A::STANDBY_MODE
            }
        }
        impl core::ops::Deref for PDDS_R {
            type Target = crate::FieldReader<bool, PDDS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PDDS` writer - Power Down Deep Sleep
        pub struct PDDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PDDS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PDDS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Enter Stop mode when the CPU enters deepsleep
            #[inline(always)]
            pub fn stop_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STOP_MODE)
            }
            ///Enter Standby mode when the CPU enters deepsleep
            #[inline(always)]
            pub fn standby_mode(self) -> &'a mut W {
                self.variant(PDDS_A::STANDBY_MODE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CWUF` reader - Clear Wake-up Flag
        pub struct CWUF_R(crate::FieldReader<bool, bool>);
        impl CWUF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CWUF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CWUF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CWUF` writer - Clear Wake-up Flag
        pub struct CWUF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CWUF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CSBF` reader - Clear STANDBY Flag
        pub struct CSBF_R(crate::FieldReader<bool, bool>);
        impl CSBF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CSBF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CSBF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CSBF` writer - Clear STANDBY Flag
        pub struct CSBF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSBF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `PVDE` reader - Power Voltage Detector Enable
        pub struct PVDE_R(crate::FieldReader<bool, bool>);
        impl PVDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PVDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PVDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PVDE` writer - Power Voltage Detector Enable
        pub struct PVDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PVDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `PLS` reader - PVD Level Selection
        pub struct PLS_R(crate::FieldReader<u8, u8>);
        impl PLS_R {
            pub(crate) fn new(bits: u8) -> Self {
                PLS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PLS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PLS` writer - PVD Level Selection
        pub struct PLS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 5)) | ((value as u32 & 0x07) << 5);
                self.w
            }
        }
        ///Field `DBP` reader - Disable Backup Domain write protection
        pub struct DBP_R(crate::FieldReader<bool, bool>);
        impl DBP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBP` writer - Disable Backup Domain write protection
        pub struct DBP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            pub fn lpds(&self) -> LPDS_R {
                LPDS_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            pub fn pdds(&self) -> PDDS_R {
                PDDS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            pub fn cwuf(&self) -> CWUF_R {
                CWUF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            pub fn csbf(&self) -> CSBF_R {
                CSBF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            pub fn pvde(&self) -> PVDE_R {
                PVDE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            pub fn pls(&self) -> PLS_R {
                PLS_R::new(((self.bits >> 5) & 0x07) as u8)
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            pub fn dbp(&self) -> DBP_R {
                DBP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Low Power Deep Sleep
            #[inline(always)]
            pub fn lpds(&mut self) -> LPDS_W {
                LPDS_W { w: self }
            }
            ///Bit 1 - Power Down Deep Sleep
            #[inline(always)]
            pub fn pdds(&mut self) -> PDDS_W {
                PDDS_W { w: self }
            }
            ///Bit 2 - Clear Wake-up Flag
            #[inline(always)]
            pub fn cwuf(&mut self) -> CWUF_W {
                CWUF_W { w: self }
            }
            ///Bit 3 - Clear STANDBY Flag
            #[inline(always)]
            pub fn csbf(&mut self) -> CSBF_W {
                CSBF_W { w: self }
            }
            ///Bit 4 - Power Voltage Detector Enable
            #[inline(always)]
            pub fn pvde(&mut self) -> PVDE_W {
                PVDE_W { w: self }
            }
            ///Bits 5:7 - PVD Level Selection
            #[inline(always)]
            pub fn pls(&mut self) -> PLS_W {
                PLS_W { w: self }
            }
            ///Bit 8 - Disable Backup Domain write protection
            #[inline(always)]
            pub fn dbp(&mut self) -> DBP_W {
                DBP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Power control register (PWR_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CSR register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///Power control register (PWR_CR)
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CSR_SPEC>> for R {
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CSR` writer
        pub struct W(crate::W<CSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CSR_SPEC>> for W {
            fn from(writer: crate::W<CSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `WUF` reader - Wake-Up Flag
        pub struct WUF_R(crate::FieldReader<bool, bool>);
        impl WUF_R {
            pub(crate) fn new(bits: bool) -> Self {
                WUF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WUF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SBF` reader - STANDBY Flag
        pub struct SBF_R(crate::FieldReader<bool, bool>);
        impl SBF_R {
            pub(crate) fn new(bits: bool) -> Self {
                SBF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SBF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PVDO` reader - PVD Output
        pub struct PVDO_R(crate::FieldReader<bool, bool>);
        impl PVDO_R {
            pub(crate) fn new(bits: bool) -> Self {
                PVDO_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PVDO_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EWUP` reader - Enable WKUP pin
        pub struct EWUP_R(crate::FieldReader<bool, bool>);
        impl EWUP_R {
            pub(crate) fn new(bits: bool) -> Self {
                EWUP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EWUP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EWUP` writer - Enable WKUP pin
        pub struct EWUP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWUP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Wake-Up Flag
            #[inline(always)]
            pub fn wuf(&self) -> WUF_R {
                WUF_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - STANDBY Flag
            #[inline(always)]
            pub fn sbf(&self) -> SBF_R {
                SBF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - PVD Output
            #[inline(always)]
            pub fn pvdo(&self) -> PVDO_R {
                PVDO_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            pub fn ewup(&self) -> EWUP_R {
                EWUP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 8 - Enable WKUP pin
            #[inline(always)]
            pub fn ewup(&mut self) -> EWUP_W {
                EWUP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Power control register (PWR_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [csr::W](W) writer structure
        impl crate::Writable for CSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Reset and clock control
pub struct RCC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RCC {}
impl RCC {
    ///Pointer to the register block
    pub const PTR: *const rcc::RegisterBlock = 0x4002_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rcc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RCC {
    type Target = rcc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RCC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RCC").finish()
    }
}
///Reset and clock control
pub mod rcc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Clock control register
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x04 - Clock configuration register (RCC_CFGR)
        pub cfgr: crate::Reg<cfgr::CFGR_SPEC>,
        ///0x08 - Clock interrupt register (RCC_CIR)
        pub cir: crate::Reg<cir::CIR_SPEC>,
        ///0x0c - APB2 peripheral reset register (RCC_APB2RSTR)
        pub apb2rstr: crate::Reg<apb2rstr::APB2RSTR_SPEC>,
        ///0x10 - APB1 peripheral reset register (RCC_APB1RSTR)
        pub apb1rstr: crate::Reg<apb1rstr::APB1RSTR_SPEC>,
        ///0x14 - AHB Peripheral Clock enable register (RCC_AHBENR)
        pub ahbenr: crate::Reg<ahbenr::AHBENR_SPEC>,
        ///0x18 - APB2 peripheral clock enable register (RCC_APB2ENR)
        pub apb2enr: crate::Reg<apb2enr::APB2ENR_SPEC>,
        ///0x1c - APB1 peripheral clock enable register (RCC_APB1ENR)
        pub apb1enr: crate::Reg<apb1enr::APB1ENR_SPEC>,
        ///0x20 - Backup domain control register (RCC_BDCR)
        pub bdcr: crate::Reg<bdcr::BDCR_SPEC>,
        ///0x24 - Control/status register (RCC_CSR)
        pub csr: crate::Reg<csr::CSR_SPEC>,
        _reserved10: [u8; 4usize],
        ///0x2c - Clock configuration register 2
        pub cfgr2: crate::Reg<cfgr2::CFGR2_SPEC>,
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Clock control register
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Internal High Speed clock enable
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSION_A {
            ///0: Clock Off
            OFF = 0,
            ///1: Clock On
            ON = 1,
        }
        impl From<HSION_A> for bool {
            #[inline(always)]
            fn from(variant: HSION_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HSION` reader - Internal High Speed clock enable
        pub struct HSION_R(crate::FieldReader<bool, HSION_A>);
        impl HSION_R {
            pub(crate) fn new(bits: bool) -> Self {
                HSION_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSION_A {
                match self.bits {
                    false => HSION_A::OFF,
                    true => HSION_A::ON,
                }
            }
            ///Checks if the value of the field is `OFF`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                **self == HSION_A::OFF
            }
            ///Checks if the value of the field is `ON`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                **self == HSION_A::ON
            }
        }
        impl core::ops::Deref for HSION_R {
            type Target = crate::FieldReader<bool, HSION_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HSION` writer - Internal High Speed clock enable
        pub struct HSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSION_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSION_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clock Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSION_A::OFF)
            }
            ///Clock On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSION_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Internal High Speed clock ready flag
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSIRDY_A {
            ///0: Clock not ready
            NOTREADY = 0,
            ///1: Clock ready
            READY = 1,
        }
        impl From<HSIRDY_A> for bool {
            #[inline(always)]
            fn from(variant: HSIRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HSIRDY` reader - Internal High Speed clock ready flag
        pub struct HSIRDY_R(crate::FieldReader<bool, HSIRDY_A>);
        impl HSIRDY_R {
            pub(crate) fn new(bits: bool) -> Self {
                HSIRDY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSIRDY_A {
                match self.bits {
                    false => HSIRDY_A::NOTREADY,
                    true => HSIRDY_A::READY,
                }
            }
            ///Checks if the value of the field is `NOTREADY`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                **self == HSIRDY_A::NOTREADY
            }
            ///Checks if the value of the field is `READY`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                **self == HSIRDY_A::READY
            }
        }
        impl core::ops::Deref for HSIRDY_R {
            type Target = crate::FieldReader<bool, HSIRDY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HSITRIM` reader - Internal High Speed clock trimming
        pub struct HSITRIM_R(crate::FieldReader<u8, u8>);
        impl HSITRIM_R {
            pub(crate) fn new(bits: u8) -> Self {
                HSITRIM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for HSITRIM_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HSITRIM` writer - Internal High Speed clock trimming
        pub struct HSITRIM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSITRIM_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 3)) | ((value as u32 & 0x1f) << 3);
                self.w
            }
        }
        ///Field `HSICAL` reader - Internal High Speed clock Calibration
        pub struct HSICAL_R(crate::FieldReader<u8, u8>);
        impl HSICAL_R {
            pub(crate) fn new(bits: u8) -> Self {
                HSICAL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for HSICAL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///External High Speed clock enable
        pub type HSEON_A = HSION_A;
        ///Field `HSEON` reader - External High Speed clock enable
        pub type HSEON_R = HSION_R;
        ///Field `HSEON` writer - External High Speed clock enable
        pub struct HSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEON_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSEON_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clock Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(HSEON_A::OFF)
            }
            ///Clock On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(HSEON_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///External High Speed clock ready flag
        pub type HSERDY_A = HSIRDY_A;
        ///Field `HSERDY` reader - External High Speed clock ready flag
        pub type HSERDY_R = HSIRDY_R;
        ///External High Speed clock Bypass
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HSEBYP_A {
            ///0: HSE crystal oscillator not bypassed
            NOTBYPASSED = 0,
            ///1: HSE crystal oscillator bypassed with external clock
            BYPASSED = 1,
        }
        impl From<HSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: HSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HSEBYP` reader - External High Speed clock Bypass
        pub struct HSEBYP_R(crate::FieldReader<bool, HSEBYP_A>);
        impl HSEBYP_R {
            pub(crate) fn new(bits: bool) -> Self {
                HSEBYP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HSEBYP_A {
                match self.bits {
                    false => HSEBYP_A::NOTBYPASSED,
                    true => HSEBYP_A::BYPASSED,
                }
            }
            ///Checks if the value of the field is `NOTBYPASSED`
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                **self == HSEBYP_A::NOTBYPASSED
            }
            ///Checks if the value of the field is `BYPASSED`
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                **self == HSEBYP_A::BYPASSED
            }
        }
        impl core::ops::Deref for HSEBYP_R {
            type Target = crate::FieldReader<bool, HSEBYP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HSEBYP` writer - External High Speed clock Bypass
        pub struct HSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSEBYP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSEBYP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///HSE crystal oscillator not bypassed
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::NOTBYPASSED)
            }
            ///HSE crystal oscillator bypassed with external clock
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(HSEBYP_A::BYPASSED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///Clock Security System enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSON_A {
            ///0: Clock security system disabled (clock detector OFF)
            OFF = 0,
            ///1: Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
            ON = 1,
        }
        impl From<CSSON_A> for bool {
            #[inline(always)]
            fn from(variant: CSSON_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CSSON` reader - Clock Security System enable
        pub struct CSSON_R(crate::FieldReader<bool, CSSON_A>);
        impl CSSON_R {
            pub(crate) fn new(bits: bool) -> Self {
                CSSON_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CSSON_A {
                match self.bits {
                    false => CSSON_A::OFF,
                    true => CSSON_A::ON,
                }
            }
            ///Checks if the value of the field is `OFF`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                **self == CSSON_A::OFF
            }
            ///Checks if the value of the field is `ON`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                **self == CSSON_A::ON
            }
        }
        impl core::ops::Deref for CSSON_R {
            type Target = crate::FieldReader<bool, CSSON_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CSSON` writer - Clock Security System enable
        pub struct CSSON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSON_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CSSON_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clock security system disabled (clock detector OFF)
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(CSSON_A::OFF)
            }
            ///Clock security system enable (clock detector ON if the HSE is ready, OFF if not)
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(CSSON_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///PLL enable
        pub type PLLON_A = HSION_A;
        ///Field `PLLON` reader - PLL enable
        pub type PLLON_R = HSION_R;
        ///Field `PLLON` writer - PLL enable
        pub struct PLLON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLON_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLON_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clock Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(PLLON_A::OFF)
            }
            ///Clock On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(PLLON_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | ((value as u32 & 0x01) << 24);
                self.w
            }
        }
        ///PLL clock ready flag
        pub type PLLRDY_A = HSIRDY_A;
        ///Field `PLLRDY` reader - PLL clock ready flag
        pub type PLLRDY_R = HSIRDY_R;
        impl R {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            pub fn hsion(&self) -> HSION_R {
                HSION_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Internal High Speed clock ready flag
            #[inline(always)]
            pub fn hsirdy(&self) -> HSIRDY_R {
                HSIRDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            pub fn hsitrim(&self) -> HSITRIM_R {
                HSITRIM_R::new(((self.bits >> 3) & 0x1f) as u8)
            }
            ///Bits 8:15 - Internal High Speed clock Calibration
            #[inline(always)]
            pub fn hsical(&self) -> HSICAL_R {
                HSICAL_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            pub fn hseon(&self) -> HSEON_R {
                HSEON_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - External High Speed clock ready flag
            #[inline(always)]
            pub fn hserdy(&self) -> HSERDY_R {
                HSERDY_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            pub fn hsebyp(&self) -> HSEBYP_R {
                HSEBYP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            pub fn csson(&self) -> CSSON_R {
                CSSON_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            pub fn pllon(&self) -> PLLON_R {
                PLLON_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            ///Bit 25 - PLL clock ready flag
            #[inline(always)]
            pub fn pllrdy(&self) -> PLLRDY_R {
                PLLRDY_R::new(((self.bits >> 25) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal High Speed clock enable
            #[inline(always)]
            pub fn hsion(&mut self) -> HSION_W {
                HSION_W { w: self }
            }
            ///Bits 3:7 - Internal High Speed clock trimming
            #[inline(always)]
            pub fn hsitrim(&mut self) -> HSITRIM_W {
                HSITRIM_W { w: self }
            }
            ///Bit 16 - External High Speed clock enable
            #[inline(always)]
            pub fn hseon(&mut self) -> HSEON_W {
                HSEON_W { w: self }
            }
            ///Bit 18 - External High Speed clock Bypass
            #[inline(always)]
            pub fn hsebyp(&mut self) -> HSEBYP_W {
                HSEBYP_W { w: self }
            }
            ///Bit 19 - Clock Security System enable
            #[inline(always)]
            pub fn csson(&mut self) -> CSSON_W {
                CSSON_W { w: self }
            }
            ///Bit 24 - PLL enable
            #[inline(always)]
            pub fn pllon(&mut self) -> PLLON_W {
                PLLON_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0x83
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x83
            }
        }
    }
    ///CFGR register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///Clock configuration register (RCC_CFGR)
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CFGR_SPEC>> for R {
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CFGR_SPEC>> for W {
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///System clock Switch
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SW_A {
            ///0: HSI selected as system clock
            HSI = 0,
            ///1: HSE selected as system clock
            HSE = 1,
            ///2: PLL selected as system clock
            PLL = 2,
        }
        impl From<SW_A> for u8 {
            #[inline(always)]
            fn from(variant: SW_A) -> Self {
                variant as _
            }
        }
        ///Field `SW` reader - System clock Switch
        pub struct SW_R(crate::FieldReader<u8, SW_A>);
        impl SW_R {
            pub(crate) fn new(bits: u8) -> Self {
                SW_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SW_A> {
                match self.bits {
                    0 => Some(SW_A::HSI),
                    1 => Some(SW_A::HSE),
                    2 => Some(SW_A::PLL),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `HSI`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                **self == SW_A::HSI
            }
            ///Checks if the value of the field is `HSE`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                **self == SW_A::HSE
            }
            ///Checks if the value of the field is `PLL`
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                **self == SW_A::PLL
            }
        }
        impl core::ops::Deref for SW_R {
            type Target = crate::FieldReader<u8, SW_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SW` writer - System clock Switch
        pub struct SW_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SW_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SW_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///HSI selected as system clock
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(SW_A::HSI)
            }
            ///HSE selected as system clock
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(SW_A::HSE)
            }
            ///PLL selected as system clock
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(SW_A::PLL)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        ///System Clock Switch Status
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SWS_A {
            ///0: HSI oscillator used as system clock
            HSI = 0,
            ///1: HSE oscillator used as system clock
            HSE = 1,
            ///2: PLL used as system clock
            PLL = 2,
        }
        impl From<SWS_A> for u8 {
            #[inline(always)]
            fn from(variant: SWS_A) -> Self {
                variant as _
            }
        }
        ///Field `SWS` reader - System Clock Switch Status
        pub struct SWS_R(crate::FieldReader<u8, SWS_A>);
        impl SWS_R {
            pub(crate) fn new(bits: u8) -> Self {
                SWS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SWS_A> {
                match self.bits {
                    0 => Some(SWS_A::HSI),
                    1 => Some(SWS_A::HSE),
                    2 => Some(SWS_A::PLL),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `HSI`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                **self == SWS_A::HSI
            }
            ///Checks if the value of the field is `HSE`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                **self == SWS_A::HSE
            }
            ///Checks if the value of the field is `PLL`
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                **self == SWS_A::PLL
            }
        }
        impl core::ops::Deref for SWS_R {
            type Target = crate::FieldReader<u8, SWS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///AHB prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum HPRE_A {
            ///0: SYSCLK not divided
            DIV1 = 0,
            ///8: SYSCLK divided by 2
            DIV2 = 8,
            ///9: SYSCLK divided by 4
            DIV4 = 9,
            ///10: SYSCLK divided by 8
            DIV8 = 10,
            ///11: SYSCLK divided by 16
            DIV16 = 11,
            ///12: SYSCLK divided by 64
            DIV64 = 12,
            ///13: SYSCLK divided by 128
            DIV128 = 13,
            ///14: SYSCLK divided by 256
            DIV256 = 14,
            ///15: SYSCLK divided by 512
            DIV512 = 15,
        }
        impl From<HPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: HPRE_A) -> Self {
                variant as _
            }
        }
        ///Field `HPRE` reader - AHB prescaler
        pub struct HPRE_R(crate::FieldReader<u8, HPRE_A>);
        impl HPRE_R {
            pub(crate) fn new(bits: u8) -> Self {
                HPRE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<HPRE_A> {
                match self.bits {
                    0 => Some(HPRE_A::DIV1),
                    8 => Some(HPRE_A::DIV2),
                    9 => Some(HPRE_A::DIV4),
                    10 => Some(HPRE_A::DIV8),
                    11 => Some(HPRE_A::DIV16),
                    12 => Some(HPRE_A::DIV64),
                    13 => Some(HPRE_A::DIV128),
                    14 => Some(HPRE_A::DIV256),
                    15 => Some(HPRE_A::DIV512),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == HPRE_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == HPRE_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == HPRE_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == HPRE_A::DIV8
            }
            ///Checks if the value of the field is `DIV16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                **self == HPRE_A::DIV16
            }
            ///Checks if the value of the field is `DIV64`
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                **self == HPRE_A::DIV64
            }
            ///Checks if the value of the field is `DIV128`
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                **self == HPRE_A::DIV128
            }
            ///Checks if the value of the field is `DIV256`
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                **self == HPRE_A::DIV256
            }
            ///Checks if the value of the field is `DIV512`
            #[inline(always)]
            pub fn is_div512(&self) -> bool {
                **self == HPRE_A::DIV512
            }
        }
        impl core::ops::Deref for HPRE_R {
            type Target = crate::FieldReader<u8, HPRE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HPRE` writer - AHB prescaler
        pub struct HPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HPRE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HPRE_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///SYSCLK not divided
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(HPRE_A::DIV1)
            }
            ///SYSCLK divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(HPRE_A::DIV2)
            }
            ///SYSCLK divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(HPRE_A::DIV4)
            }
            ///SYSCLK divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(HPRE_A::DIV8)
            }
            ///SYSCLK divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(HPRE_A::DIV16)
            }
            ///SYSCLK divided by 64
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(HPRE_A::DIV64)
            }
            ///SYSCLK divided by 128
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(HPRE_A::DIV128)
            }
            ///SYSCLK divided by 256
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(HPRE_A::DIV256)
            }
            ///SYSCLK divided by 512
            #[inline(always)]
            pub fn div512(self) -> &'a mut W {
                self.variant(HPRE_A::DIV512)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///APB Low speed prescaler (APB1)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PPRE1_A {
            ///0: HCLK not divided
            DIV1 = 0,
            ///4: HCLK divided by 2
            DIV2 = 4,
            ///5: HCLK divided by 4
            DIV4 = 5,
            ///6: HCLK divided by 8
            DIV8 = 6,
            ///7: HCLK divided by 16
            DIV16 = 7,
        }
        impl From<PPRE1_A> for u8 {
            #[inline(always)]
            fn from(variant: PPRE1_A) -> Self {
                variant as _
            }
        }
        ///Field `PPRE1` reader - APB Low speed prescaler (APB1)
        pub struct PPRE1_R(crate::FieldReader<u8, PPRE1_A>);
        impl PPRE1_R {
            pub(crate) fn new(bits: u8) -> Self {
                PPRE1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<PPRE1_A> {
                match self.bits {
                    0 => Some(PPRE1_A::DIV1),
                    4 => Some(PPRE1_A::DIV2),
                    5 => Some(PPRE1_A::DIV4),
                    6 => Some(PPRE1_A::DIV8),
                    7 => Some(PPRE1_A::DIV16),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == PPRE1_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == PPRE1_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == PPRE1_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == PPRE1_A::DIV8
            }
            ///Checks if the value of the field is `DIV16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                **self == PPRE1_A::DIV16
            }
        }
        impl core::ops::Deref for PPRE1_R {
            type Target = crate::FieldReader<u8, PPRE1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PPRE1` writer - APB Low speed prescaler (APB1)
        pub struct PPRE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PPRE1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///HCLK not divided
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV1)
            }
            ///HCLK divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV2)
            }
            ///HCLK divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV4)
            }
            ///HCLK divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV8)
            }
            ///HCLK divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE1_A::DIV16)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 8)) | ((value as u32 & 0x07) << 8);
                self.w
            }
        }
        ///APB High speed prescaler (APB2)
        pub type PPRE2_A = PPRE1_A;
        ///Field `PPRE2` reader - APB High speed prescaler (APB2)
        pub type PPRE2_R = PPRE1_R;
        ///Field `PPRE2` writer - APB High speed prescaler (APB2)
        pub struct PPRE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PPRE2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PPRE2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///HCLK not divided
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV1)
            }
            ///HCLK divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV2)
            }
            ///HCLK divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV4)
            }
            ///HCLK divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV8)
            }
            ///HCLK divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PPRE2_A::DIV16)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 11)) | ((value as u32 & 0x07) << 11);
                self.w
            }
        }
        ///ADC prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ADCPRE_A {
            ///0: PCLK2 divided by 2
            DIV2 = 0,
            ///1: PCLK2 divided by 4
            DIV4 = 1,
            ///2: PCLK2 divided by 8
            DIV6 = 2,
            ///3: PCLK2 divided by 16
            DIV8 = 3,
        }
        impl From<ADCPRE_A> for u8 {
            #[inline(always)]
            fn from(variant: ADCPRE_A) -> Self {
                variant as _
            }
        }
        ///Field `ADCPRE` reader - ADC prescaler
        pub struct ADCPRE_R(crate::FieldReader<u8, ADCPRE_A>);
        impl ADCPRE_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADCPRE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADCPRE_A {
                match self.bits {
                    0 => ADCPRE_A::DIV2,
                    1 => ADCPRE_A::DIV4,
                    2 => ADCPRE_A::DIV6,
                    3 => ADCPRE_A::DIV8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == ADCPRE_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == ADCPRE_A::DIV4
            }
            ///Checks if the value of the field is `DIV6`
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                **self == ADCPRE_A::DIV6
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == ADCPRE_A::DIV8
            }
        }
        impl core::ops::Deref for ADCPRE_R {
            type Target = crate::FieldReader<u8, ADCPRE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADCPRE` writer - ADC prescaler
        pub struct ADCPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADCPRE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ADCPRE_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///PCLK2 divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV2)
            }
            ///PCLK2 divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV4)
            }
            ///PCLK2 divided by 8
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV6)
            }
            ///PCLK2 divided by 16
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ADCPRE_A::DIV8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | ((value as u32 & 0x03) << 14);
                self.w
            }
        }
        ///PLL entry clock source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLSRC_A {
            ///0: HSI divided by 2 selected as PLL input clock
            HSI_DIV2 = 0,
            ///1: HSE divided by PREDIV selected as PLL input clock
            HSE_DIV_PREDIV = 1,
        }
        impl From<PLLSRC_A> for bool {
            #[inline(always)]
            fn from(variant: PLLSRC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PLLSRC` reader - PLL entry clock source
        pub struct PLLSRC_R(crate::FieldReader<bool, PLLSRC_A>);
        impl PLLSRC_R {
            pub(crate) fn new(bits: bool) -> Self {
                PLLSRC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLLSRC_A {
                match self.bits {
                    false => PLLSRC_A::HSI_DIV2,
                    true => PLLSRC_A::HSE_DIV_PREDIV,
                }
            }
            ///Checks if the value of the field is `HSI_DIV2`
            #[inline(always)]
            pub fn is_hsi_div2(&self) -> bool {
                **self == PLLSRC_A::HSI_DIV2
            }
            ///Checks if the value of the field is `HSE_DIV_PREDIV`
            #[inline(always)]
            pub fn is_hse_div_prediv(&self) -> bool {
                **self == PLLSRC_A::HSE_DIV_PREDIV
            }
        }
        impl core::ops::Deref for PLLSRC_R {
            type Target = crate::FieldReader<bool, PLLSRC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PLLSRC` writer - PLL entry clock source
        pub struct PLLSRC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLSRC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLSRC_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///HSI divided by 2 selected as PLL input clock
            #[inline(always)]
            pub fn hsi_div2(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSI_DIV2)
            }
            ///HSE divided by PREDIV selected as PLL input clock
            #[inline(always)]
            pub fn hse_div_prediv(self) -> &'a mut W {
                self.variant(PLLSRC_A::HSE_DIV_PREDIV)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///HSE divider for PLL entry
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PLLXTPRE_A {
            ///0: HSE clock not divided
            DIV1 = 0,
            ///1: HSE clock divided by 2
            DIV2 = 1,
        }
        impl From<PLLXTPRE_A> for bool {
            #[inline(always)]
            fn from(variant: PLLXTPRE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PLLXTPRE` reader - HSE divider for PLL entry
        pub struct PLLXTPRE_R(crate::FieldReader<bool, PLLXTPRE_A>);
        impl PLLXTPRE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PLLXTPRE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLLXTPRE_A {
                match self.bits {
                    false => PLLXTPRE_A::DIV1,
                    true => PLLXTPRE_A::DIV2,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == PLLXTPRE_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == PLLXTPRE_A::DIV2
            }
        }
        impl core::ops::Deref for PLLXTPRE_R {
            type Target = crate::FieldReader<bool, PLLXTPRE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PLLXTPRE` writer - HSE divider for PLL entry
        pub struct PLLXTPRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLXTPRE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLXTPRE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///HSE clock not divided
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::DIV1)
            }
            ///HSE clock divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PLLXTPRE_A::DIV2)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///PLL Multiplication Factor
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PLLMUL_A {
            ///0: PLL input clock x2
            MUL2 = 0,
            ///1: PLL input clock x3
            MUL3 = 1,
            ///2: PLL input clock x4
            MUL4 = 2,
            ///3: PLL input clock x5
            MUL5 = 3,
            ///4: PLL input clock x6
            MUL6 = 4,
            ///5: PLL input clock x7
            MUL7 = 5,
            ///6: PLL input clock x8
            MUL8 = 6,
            ///7: PLL input clock x9
            MUL9 = 7,
            ///8: PLL input clock x10
            MUL10 = 8,
            ///9: PLL input clock x11
            MUL11 = 9,
            ///10: PLL input clock x12
            MUL12 = 10,
            ///11: PLL input clock x13
            MUL13 = 11,
            ///12: PLL input clock x14
            MUL14 = 12,
            ///13: PLL input clock x15
            MUL15 = 13,
            ///14: PLL input clock x16
            MUL16 = 14,
            ///15: PLL input clock x16
            MUL16X = 15,
        }
        impl From<PLLMUL_A> for u8 {
            #[inline(always)]
            fn from(variant: PLLMUL_A) -> Self {
                variant as _
            }
        }
        ///Field `PLLMUL` reader - PLL Multiplication Factor
        pub struct PLLMUL_R(crate::FieldReader<u8, PLLMUL_A>);
        impl PLLMUL_R {
            pub(crate) fn new(bits: u8) -> Self {
                PLLMUL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PLLMUL_A {
                match self.bits {
                    0 => PLLMUL_A::MUL2,
                    1 => PLLMUL_A::MUL3,
                    2 => PLLMUL_A::MUL4,
                    3 => PLLMUL_A::MUL5,
                    4 => PLLMUL_A::MUL6,
                    5 => PLLMUL_A::MUL7,
                    6 => PLLMUL_A::MUL8,
                    7 => PLLMUL_A::MUL9,
                    8 => PLLMUL_A::MUL10,
                    9 => PLLMUL_A::MUL11,
                    10 => PLLMUL_A::MUL12,
                    11 => PLLMUL_A::MUL13,
                    12 => PLLMUL_A::MUL14,
                    13 => PLLMUL_A::MUL15,
                    14 => PLLMUL_A::MUL16,
                    15 => PLLMUL_A::MUL16X,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `MUL2`
            #[inline(always)]
            pub fn is_mul2(&self) -> bool {
                **self == PLLMUL_A::MUL2
            }
            ///Checks if the value of the field is `MUL3`
            #[inline(always)]
            pub fn is_mul3(&self) -> bool {
                **self == PLLMUL_A::MUL3
            }
            ///Checks if the value of the field is `MUL4`
            #[inline(always)]
            pub fn is_mul4(&self) -> bool {
                **self == PLLMUL_A::MUL4
            }
            ///Checks if the value of the field is `MUL5`
            #[inline(always)]
            pub fn is_mul5(&self) -> bool {
                **self == PLLMUL_A::MUL5
            }
            ///Checks if the value of the field is `MUL6`
            #[inline(always)]
            pub fn is_mul6(&self) -> bool {
                **self == PLLMUL_A::MUL6
            }
            ///Checks if the value of the field is `MUL7`
            #[inline(always)]
            pub fn is_mul7(&self) -> bool {
                **self == PLLMUL_A::MUL7
            }
            ///Checks if the value of the field is `MUL8`
            #[inline(always)]
            pub fn is_mul8(&self) -> bool {
                **self == PLLMUL_A::MUL8
            }
            ///Checks if the value of the field is `MUL9`
            #[inline(always)]
            pub fn is_mul9(&self) -> bool {
                **self == PLLMUL_A::MUL9
            }
            ///Checks if the value of the field is `MUL10`
            #[inline(always)]
            pub fn is_mul10(&self) -> bool {
                **self == PLLMUL_A::MUL10
            }
            ///Checks if the value of the field is `MUL11`
            #[inline(always)]
            pub fn is_mul11(&self) -> bool {
                **self == PLLMUL_A::MUL11
            }
            ///Checks if the value of the field is `MUL12`
            #[inline(always)]
            pub fn is_mul12(&self) -> bool {
                **self == PLLMUL_A::MUL12
            }
            ///Checks if the value of the field is `MUL13`
            #[inline(always)]
            pub fn is_mul13(&self) -> bool {
                **self == PLLMUL_A::MUL13
            }
            ///Checks if the value of the field is `MUL14`
            #[inline(always)]
            pub fn is_mul14(&self) -> bool {
                **self == PLLMUL_A::MUL14
            }
            ///Checks if the value of the field is `MUL15`
            #[inline(always)]
            pub fn is_mul15(&self) -> bool {
                **self == PLLMUL_A::MUL15
            }
            ///Checks if the value of the field is `MUL16`
            #[inline(always)]
            pub fn is_mul16(&self) -> bool {
                **self == PLLMUL_A::MUL16
            }
            ///Checks if the value of the field is `MUL16X`
            #[inline(always)]
            pub fn is_mul16x(&self) -> bool {
                **self == PLLMUL_A::MUL16X
            }
        }
        impl core::ops::Deref for PLLMUL_R {
            type Target = crate::FieldReader<u8, PLLMUL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PLLMUL` writer - PLL Multiplication Factor
        pub struct PLLMUL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLMUL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLMUL_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///PLL input clock x2
            #[inline(always)]
            pub fn mul2(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL2)
            }
            ///PLL input clock x3
            #[inline(always)]
            pub fn mul3(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL3)
            }
            ///PLL input clock x4
            #[inline(always)]
            pub fn mul4(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL4)
            }
            ///PLL input clock x5
            #[inline(always)]
            pub fn mul5(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL5)
            }
            ///PLL input clock x6
            #[inline(always)]
            pub fn mul6(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL6)
            }
            ///PLL input clock x7
            #[inline(always)]
            pub fn mul7(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL7)
            }
            ///PLL input clock x8
            #[inline(always)]
            pub fn mul8(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL8)
            }
            ///PLL input clock x9
            #[inline(always)]
            pub fn mul9(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL9)
            }
            ///PLL input clock x10
            #[inline(always)]
            pub fn mul10(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL10)
            }
            ///PLL input clock x11
            #[inline(always)]
            pub fn mul11(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL11)
            }
            ///PLL input clock x12
            #[inline(always)]
            pub fn mul12(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL12)
            }
            ///PLL input clock x13
            #[inline(always)]
            pub fn mul13(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL13)
            }
            ///PLL input clock x14
            #[inline(always)]
            pub fn mul14(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL14)
            }
            ///PLL input clock x15
            #[inline(always)]
            pub fn mul15(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL15)
            }
            ///PLL input clock x16
            #[inline(always)]
            pub fn mul16(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL16)
            }
            ///PLL input clock x16
            #[inline(always)]
            pub fn mul16x(self) -> &'a mut W {
                self.variant(PLLMUL_A::MUL16X)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 18)) | ((value as u32 & 0x0f) << 18);
                self.w
            }
        }
        ///Microcontroller clock output
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MCO_A {
            ///0: MCO output disabled, no clock on MCO
            NOMCO = 0,
            ///4: System clock selected
            SYSCLK = 4,
            ///5: HSI oscillator clock selected
            HSI = 5,
            ///6: HSE oscillator clock selected
            HSE = 6,
            ///7: PLL clock selected (divided by 1 or 2, depending en PLLNODIV)
            PLL = 7,
        }
        impl From<MCO_A> for u8 {
            #[inline(always)]
            fn from(variant: MCO_A) -> Self {
                variant as _
            }
        }
        ///Field `MCO` reader - Microcontroller clock output
        pub struct MCO_R(crate::FieldReader<u8, MCO_A>);
        impl MCO_R {
            pub(crate) fn new(bits: u8) -> Self {
                MCO_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MCO_A> {
                match self.bits {
                    0 => Some(MCO_A::NOMCO),
                    4 => Some(MCO_A::SYSCLK),
                    5 => Some(MCO_A::HSI),
                    6 => Some(MCO_A::HSE),
                    7 => Some(MCO_A::PLL),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `NOMCO`
            #[inline(always)]
            pub fn is_no_mco(&self) -> bool {
                **self == MCO_A::NOMCO
            }
            ///Checks if the value of the field is `SYSCLK`
            #[inline(always)]
            pub fn is_sysclk(&self) -> bool {
                **self == MCO_A::SYSCLK
            }
            ///Checks if the value of the field is `HSI`
            #[inline(always)]
            pub fn is_hsi(&self) -> bool {
                **self == MCO_A::HSI
            }
            ///Checks if the value of the field is `HSE`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                **self == MCO_A::HSE
            }
            ///Checks if the value of the field is `PLL`
            #[inline(always)]
            pub fn is_pll(&self) -> bool {
                **self == MCO_A::PLL
            }
        }
        impl core::ops::Deref for MCO_R {
            type Target = crate::FieldReader<u8, MCO_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MCO` writer - Microcontroller clock output
        pub struct MCO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MCO_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MCO_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///MCO output disabled, no clock on MCO
            #[inline(always)]
            pub fn no_mco(self) -> &'a mut W {
                self.variant(MCO_A::NOMCO)
            }
            ///System clock selected
            #[inline(always)]
            pub fn sysclk(self) -> &'a mut W {
                self.variant(MCO_A::SYSCLK)
            }
            ///HSI oscillator clock selected
            #[inline(always)]
            pub fn hsi(self) -> &'a mut W {
                self.variant(MCO_A::HSI)
            }
            ///HSE oscillator clock selected
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(MCO_A::HSE)
            }
            ///PLL clock selected (divided by 1 or 2, depending en PLLNODIV)
            #[inline(always)]
            pub fn pll(self) -> &'a mut W {
                self.variant(MCO_A::PLL)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | ((value as u32 & 0x07) << 24);
                self.w
            }
        }
        impl R {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            pub fn sw(&self) -> SW_R {
                SW_R::new((self.bits & 0x03) as u8)
            }
            ///Bits 2:3 - System Clock Switch Status
            #[inline(always)]
            pub fn sws(&self) -> SWS_R {
                SWS_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            pub fn hpre(&self) -> HPRE_R {
                HPRE_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            pub fn ppre1(&self) -> PPRE1_R {
                PPRE1_R::new(((self.bits >> 8) & 0x07) as u8)
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            pub fn ppre2(&self) -> PPRE2_R {
                PPRE2_R::new(((self.bits >> 11) & 0x07) as u8)
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            pub fn adcpre(&self) -> ADCPRE_R {
                ADCPRE_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            pub fn pllsrc(&self) -> PLLSRC_R {
                PLLSRC_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            pub fn pllxtpre(&self) -> PLLXTPRE_R {
                PLLXTPRE_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            pub fn pllmul(&self) -> PLLMUL_R {
                PLLMUL_R::new(((self.bits >> 18) & 0x0f) as u8)
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            pub fn mco(&self) -> MCO_R {
                MCO_R::new(((self.bits >> 24) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - System clock Switch
            #[inline(always)]
            pub fn sw(&mut self) -> SW_W {
                SW_W { w: self }
            }
            ///Bits 4:7 - AHB prescaler
            #[inline(always)]
            pub fn hpre(&mut self) -> HPRE_W {
                HPRE_W { w: self }
            }
            ///Bits 8:10 - APB Low speed prescaler (APB1)
            #[inline(always)]
            pub fn ppre1(&mut self) -> PPRE1_W {
                PPRE1_W { w: self }
            }
            ///Bits 11:13 - APB High speed prescaler (APB2)
            #[inline(always)]
            pub fn ppre2(&mut self) -> PPRE2_W {
                PPRE2_W { w: self }
            }
            ///Bits 14:15 - ADC prescaler
            #[inline(always)]
            pub fn adcpre(&mut self) -> ADCPRE_W {
                ADCPRE_W { w: self }
            }
            ///Bit 16 - PLL entry clock source
            #[inline(always)]
            pub fn pllsrc(&mut self) -> PLLSRC_W {
                PLLSRC_W { w: self }
            }
            ///Bit 17 - HSE divider for PLL entry
            #[inline(always)]
            pub fn pllxtpre(&mut self) -> PLLXTPRE_W {
                PLLXTPRE_W { w: self }
            }
            ///Bits 18:21 - PLL Multiplication Factor
            #[inline(always)]
            pub fn pllmul(&mut self) -> PLLMUL_W {
                PLLMUL_W { w: self }
            }
            ///Bits 24:26 - Microcontroller clock output
            #[inline(always)]
            pub fn mco(&mut self) -> MCO_W {
                MCO_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock configuration register (RCC_CFGR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CIR register accessor: an alias for `Reg<CIR_SPEC>`
    pub type CIR = crate::Reg<cir::CIR_SPEC>;
    ///Clock interrupt register (RCC_CIR)
    pub mod cir {
        ///Register `CIR` reader
        pub struct R(crate::R<CIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CIR_SPEC>> for R {
            fn from(reader: crate::R<CIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CIR` writer
        pub struct W(crate::W<CIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CIR_SPEC>> for W {
            fn from(writer: crate::W<CIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///LSI Ready Interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYF_A {
            ///0: No clock ready interrupt
            NOTINTERRUPTED = 0,
            ///1: Clock ready interrupt
            INTERRUPTED = 1,
        }
        impl From<LSIRDYF_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSIRDYF` reader - LSI Ready Interrupt flag
        pub struct LSIRDYF_R(crate::FieldReader<bool, LSIRDYF_A>);
        impl LSIRDYF_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSIRDYF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYF_A {
                match self.bits {
                    false => LSIRDYF_A::NOTINTERRUPTED,
                    true => LSIRDYF_A::INTERRUPTED,
                }
            }
            ///Checks if the value of the field is `NOTINTERRUPTED`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                **self == LSIRDYF_A::NOTINTERRUPTED
            }
            ///Checks if the value of the field is `INTERRUPTED`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                **self == LSIRDYF_A::INTERRUPTED
            }
        }
        impl core::ops::Deref for LSIRDYF_R {
            type Target = crate::FieldReader<bool, LSIRDYF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///LSE Ready Interrupt flag
        pub type LSERDYF_A = LSIRDYF_A;
        ///Field `LSERDYF` reader - LSE Ready Interrupt flag
        pub type LSERDYF_R = LSIRDYF_R;
        ///HSI Ready Interrupt flag
        pub type HSIRDYF_A = LSIRDYF_A;
        ///Field `HSIRDYF` reader - HSI Ready Interrupt flag
        pub type HSIRDYF_R = LSIRDYF_R;
        ///HSE Ready Interrupt flag
        pub type HSERDYF_A = LSIRDYF_A;
        ///Field `HSERDYF` reader - HSE Ready Interrupt flag
        pub type HSERDYF_R = LSIRDYF_R;
        ///PLL Ready Interrupt flag
        pub type PLLRDYF_A = LSIRDYF_A;
        ///Field `PLLRDYF` reader - PLL Ready Interrupt flag
        pub type PLLRDYF_R = LSIRDYF_R;
        ///Clock Security System Interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSF_A {
            ///0: No clock security interrupt caused by HSE clock failure
            NOTINTERRUPTED = 0,
            ///1: Clock security interrupt caused by HSE clock failure
            INTERRUPTED = 1,
        }
        impl From<CSSF_A> for bool {
            #[inline(always)]
            fn from(variant: CSSF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CSSF` reader - Clock Security System Interrupt flag
        pub struct CSSF_R(crate::FieldReader<bool, CSSF_A>);
        impl CSSF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CSSF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CSSF_A {
                match self.bits {
                    false => CSSF_A::NOTINTERRUPTED,
                    true => CSSF_A::INTERRUPTED,
                }
            }
            ///Checks if the value of the field is `NOTINTERRUPTED`
            #[inline(always)]
            pub fn is_not_interrupted(&self) -> bool {
                **self == CSSF_A::NOTINTERRUPTED
            }
            ///Checks if the value of the field is `INTERRUPTED`
            #[inline(always)]
            pub fn is_interrupted(&self) -> bool {
                **self == CSSF_A::INTERRUPTED
            }
        }
        impl core::ops::Deref for CSSF_R {
            type Target = crate::FieldReader<bool, CSSF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///LSI Ready Interrupt Enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYIE_A {
            ///0: Interrupt disabled
            DISABLED = 0,
            ///1: Interrupt enabled
            ENABLED = 1,
        }
        impl From<LSIRDYIE_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSIRDYIE` reader - LSI Ready Interrupt Enable
        pub struct LSIRDYIE_R(crate::FieldReader<bool, LSIRDYIE_A>);
        impl LSIRDYIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSIRDYIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDYIE_A {
                match self.bits {
                    false => LSIRDYIE_A::DISABLED,
                    true => LSIRDYIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == LSIRDYIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == LSIRDYIE_A::ENABLED
            }
        }
        impl core::ops::Deref for LSIRDYIE_R {
            type Target = crate::FieldReader<bool, LSIRDYIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LSIRDYIE` writer - LSI Ready Interrupt Enable
        pub struct LSIRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSIRDYIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSIRDYIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::DISABLED)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSIRDYIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///LSE Ready Interrupt Enable
        pub type LSERDYIE_A = LSIRDYIE_A;
        ///Field `LSERDYIE` reader - LSE Ready Interrupt Enable
        pub type LSERDYIE_R = LSIRDYIE_R;
        ///Field `LSERDYIE` writer - LSE Ready Interrupt Enable
        pub struct LSERDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSERDYIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSERDYIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LSERDYIE_A::DISABLED)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LSERDYIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///HSI Ready Interrupt Enable
        pub type HSIRDYIE_A = LSIRDYIE_A;
        ///Field `HSIRDYIE` reader - HSI Ready Interrupt Enable
        pub type HSIRDYIE_R = LSIRDYIE_R;
        ///Field `HSIRDYIE` writer - HSI Ready Interrupt Enable
        pub struct HSIRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSIRDYIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSIRDYIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HSIRDYIE_A::DISABLED)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HSIRDYIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///HSE Ready Interrupt Enable
        pub type HSERDYIE_A = LSIRDYIE_A;
        ///Field `HSERDYIE` reader - HSE Ready Interrupt Enable
        pub type HSERDYIE_R = LSIRDYIE_R;
        ///Field `HSERDYIE` writer - HSE Ready Interrupt Enable
        pub struct HSERDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSERDYIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSERDYIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(HSERDYIE_A::DISABLED)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(HSERDYIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///PLL Ready Interrupt Enable
        pub type PLLRDYIE_A = LSIRDYIE_A;
        ///Field `PLLRDYIE` reader - PLL Ready Interrupt Enable
        pub type PLLRDYIE_R = LSIRDYIE_R;
        ///Field `PLLRDYIE` writer - PLL Ready Interrupt Enable
        pub struct PLLRDYIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLRDYIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLRDYIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PLLRDYIE_A::DISABLED)
            }
            ///Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PLLRDYIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///LSI Ready Interrupt Clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDYC_AW {
            ///1: Clear interrupt flag
            CLEAR = 1,
        }
        impl From<LSIRDYC_AW> for bool {
            #[inline(always)]
            fn from(variant: LSIRDYC_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSIRDYC` writer - LSI Ready Interrupt Clear
        pub struct LSIRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSIRDYC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSIRDYC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSIRDYC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///LSE Ready Interrupt Clear
        pub type LSERDYC_AW = LSIRDYC_AW;
        ///Field `LSERDYC` writer - LSE Ready Interrupt Clear
        pub struct LSERDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSERDYC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSERDYC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(LSERDYC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///HSI Ready Interrupt Clear
        pub type HSIRDYC_AW = LSIRDYC_AW;
        ///Field `HSIRDYC` writer - HSI Ready Interrupt Clear
        pub struct HSIRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSIRDYC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSIRDYC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(HSIRDYC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///HSE Ready Interrupt Clear
        pub type HSERDYC_AW = LSIRDYC_AW;
        ///Field `HSERDYC` writer - HSE Ready Interrupt Clear
        pub struct HSERDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HSERDYC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HSERDYC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(HSERDYC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///PLL Ready Interrupt Clear
        pub type PLLRDYC_AW = LSIRDYC_AW;
        ///Field `PLLRDYC` writer - PLL Ready Interrupt Clear
        pub struct PLLRDYC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PLLRDYC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PLLRDYC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PLLRDYC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///Clock security system interrupt clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CSSC_AW {
            ///1: Clear CSSF flag
            CLEAR = 1,
        }
        impl From<CSSC_AW> for bool {
            #[inline(always)]
            fn from(variant: CSSC_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CSSC` writer - Clock security system interrupt clear
        pub struct CSSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CSSC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CSSC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear CSSF flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CSSC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        impl R {
            ///Bit 0 - LSI Ready Interrupt flag
            #[inline(always)]
            pub fn lsirdyf(&self) -> LSIRDYF_R {
                LSIRDYF_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - LSE Ready Interrupt flag
            #[inline(always)]
            pub fn lserdyf(&self) -> LSERDYF_R {
                LSERDYF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - HSI Ready Interrupt flag
            #[inline(always)]
            pub fn hsirdyf(&self) -> HSIRDYF_R {
                HSIRDYF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - HSE Ready Interrupt flag
            #[inline(always)]
            pub fn hserdyf(&self) -> HSERDYF_R {
                HSERDYF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - PLL Ready Interrupt flag
            #[inline(always)]
            pub fn pllrdyf(&self) -> PLLRDYF_R {
                PLLRDYF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 7 - Clock Security System Interrupt flag
            #[inline(always)]
            pub fn cssf(&self) -> CSSF_R {
                CSSF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            pub fn lsirdyie(&self) -> LSIRDYIE_R {
                LSIRDYIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            pub fn lserdyie(&self) -> LSERDYIE_R {
                LSERDYIE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            pub fn hsirdyie(&self) -> HSIRDYIE_R {
                HSIRDYIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            pub fn hserdyie(&self) -> HSERDYIE_R {
                HSERDYIE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            pub fn pllrdyie(&self) -> PLLRDYIE_R {
                PLLRDYIE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 8 - LSI Ready Interrupt Enable
            #[inline(always)]
            pub fn lsirdyie(&mut self) -> LSIRDYIE_W {
                LSIRDYIE_W { w: self }
            }
            ///Bit 9 - LSE Ready Interrupt Enable
            #[inline(always)]
            pub fn lserdyie(&mut self) -> LSERDYIE_W {
                LSERDYIE_W { w: self }
            }
            ///Bit 10 - HSI Ready Interrupt Enable
            #[inline(always)]
            pub fn hsirdyie(&mut self) -> HSIRDYIE_W {
                HSIRDYIE_W { w: self }
            }
            ///Bit 11 - HSE Ready Interrupt Enable
            #[inline(always)]
            pub fn hserdyie(&mut self) -> HSERDYIE_W {
                HSERDYIE_W { w: self }
            }
            ///Bit 12 - PLL Ready Interrupt Enable
            #[inline(always)]
            pub fn pllrdyie(&mut self) -> PLLRDYIE_W {
                PLLRDYIE_W { w: self }
            }
            ///Bit 16 - LSI Ready Interrupt Clear
            #[inline(always)]
            pub fn lsirdyc(&mut self) -> LSIRDYC_W {
                LSIRDYC_W { w: self }
            }
            ///Bit 17 - LSE Ready Interrupt Clear
            #[inline(always)]
            pub fn lserdyc(&mut self) -> LSERDYC_W {
                LSERDYC_W { w: self }
            }
            ///Bit 18 - HSI Ready Interrupt Clear
            #[inline(always)]
            pub fn hsirdyc(&mut self) -> HSIRDYC_W {
                HSIRDYC_W { w: self }
            }
            ///Bit 19 - HSE Ready Interrupt Clear
            #[inline(always)]
            pub fn hserdyc(&mut self) -> HSERDYC_W {
                HSERDYC_W { w: self }
            }
            ///Bit 20 - PLL Ready Interrupt Clear
            #[inline(always)]
            pub fn pllrdyc(&mut self) -> PLLRDYC_W {
                PLLRDYC_W { w: self }
            }
            ///Bit 23 - Clock security system interrupt clear
            #[inline(always)]
            pub fn cssc(&mut self) -> CSSC_W {
                CSSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock interrupt register (RCC_CIR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cir](index.html) module
        pub struct CIR_SPEC;
        impl crate::RegisterSpec for CIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cir::R](R) reader structure
        impl crate::Readable for CIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cir::W](W) writer structure
        impl crate::Writable for CIR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CIR to value 0
        impl crate::Resettable for CIR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///APB2RSTR register accessor: an alias for `Reg<APB2RSTR_SPEC>`
    pub type APB2RSTR = crate::Reg<apb2rstr::APB2RSTR_SPEC>;
    ///APB2 peripheral reset register (RCC_APB2RSTR)
    pub mod apb2rstr {
        ///Register `APB2RSTR` reader
        pub struct R(crate::R<APB2RSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2RSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<APB2RSTR_SPEC>> for R {
            fn from(reader: crate::R<APB2RSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2RSTR` writer
        pub struct W(crate::W<APB2RSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2RSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<APB2RSTR_SPEC>> for W {
            fn from(writer: crate::W<APB2RSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Alternate function I/O reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIORST_A {
            ///1: Reset the selected module
            RESET = 1,
        }
        impl From<AFIORST_A> for bool {
            #[inline(always)]
            fn from(variant: AFIORST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AFIORST` reader - Alternate function I/O reset
        pub struct AFIORST_R(crate::FieldReader<bool, AFIORST_A>);
        impl AFIORST_R {
            pub(crate) fn new(bits: bool) -> Self {
                AFIORST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<AFIORST_A> {
                match self.bits {
                    true => Some(AFIORST_A::RESET),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == AFIORST_A::RESET
            }
        }
        impl core::ops::Deref for AFIORST_R {
            type Target = crate::FieldReader<bool, AFIORST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AFIORST` writer - Alternate function I/O reset
        pub struct AFIORST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFIORST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AFIORST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(AFIORST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///IO port A reset
        pub type IOPARST_A = AFIORST_A;
        ///Field `IOPARST` reader - IO port A reset
        pub type IOPARST_R = AFIORST_R;
        ///Field `IOPARST` writer - IO port A reset
        pub struct IOPARST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPARST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPARST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPARST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///IO port B reset
        pub type IOPBRST_A = AFIORST_A;
        ///Field `IOPBRST` reader - IO port B reset
        pub type IOPBRST_R = AFIORST_R;
        ///Field `IOPBRST` writer - IO port B reset
        pub struct IOPBRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPBRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPBRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///IO port C reset
        pub type IOPCRST_A = AFIORST_A;
        ///Field `IOPCRST` reader - IO port C reset
        pub type IOPCRST_R = AFIORST_R;
        ///Field `IOPCRST` writer - IO port C reset
        pub struct IOPCRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPCRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPCRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///IO port D reset
        pub type IOPDRST_A = AFIORST_A;
        ///Field `IOPDRST` reader - IO port D reset
        pub type IOPDRST_R = AFIORST_R;
        ///Field `IOPDRST` writer - IO port D reset
        pub struct IOPDRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPDRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPDRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///IO port E reset
        pub type IOPERST_A = AFIORST_A;
        ///Field `IOPERST` reader - IO port E reset
        pub type IOPERST_R = AFIORST_R;
        ///Field `IOPERST` writer - IO port E reset
        pub struct IOPERST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPERST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPERST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPERST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///IO port F reset
        pub type IOPFRST_A = AFIORST_A;
        ///Field `IOPFRST` reader - IO port F reset
        pub type IOPFRST_R = AFIORST_R;
        ///Field `IOPFRST` writer - IO port F reset
        pub struct IOPFRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPFRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPFRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPFRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///IO port G reset
        pub type IOPGRST_A = AFIORST_A;
        ///Field `IOPGRST` reader - IO port G reset
        pub type IOPGRST_R = AFIORST_R;
        ///Field `IOPGRST` writer - IO port G reset
        pub struct IOPGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPGRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPGRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IOPGRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///ADC 1 interface reset
        pub type ADC1RST_A = AFIORST_A;
        ///Field `ADC1RST` reader - ADC 1 interface reset
        pub type ADC1RST_R = AFIORST_R;
        ///Field `ADC1RST` writer - ADC 1 interface reset
        pub struct ADC1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADC1RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ADC1RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(ADC1RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///TIM1 timer reset
        pub type TIM1RST_A = AFIORST_A;
        ///Field `TIM1RST` reader - TIM1 timer reset
        pub type TIM1RST_R = AFIORST_R;
        ///Field `TIM1RST` writer - TIM1 timer reset
        pub struct TIM1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM1RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM1RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///SPI 1 reset
        pub type SPI1RST_A = AFIORST_A;
        ///Field `SPI1RST` reader - SPI 1 reset
        pub type SPI1RST_R = AFIORST_R;
        ///Field `SPI1RST` writer - SPI 1 reset
        pub struct SPI1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI1RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SPI1RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///USART1 reset
        pub type USART1RST_A = AFIORST_A;
        ///Field `USART1RST` reader - USART1 reset
        pub type USART1RST_R = AFIORST_R;
        ///Field `USART1RST` writer - USART1 reset
        pub struct USART1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART1RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(USART1RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///TIM15 timer reset
        pub type TIM15RST_A = AFIORST_A;
        ///Field `TIM15RST` reader - TIM15 timer reset
        pub type TIM15RST_R = AFIORST_R;
        ///Field `TIM15RST` writer - TIM15 timer reset
        pub struct TIM15RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM15RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM15RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///TIM16 timer reset
        pub type TIM16RST_A = AFIORST_A;
        ///Field `TIM16RST` reader - TIM16 timer reset
        pub type TIM16RST_R = AFIORST_R;
        ///Field `TIM16RST` writer - TIM16 timer reset
        pub struct TIM16RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM16RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM16RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///TIM17 timer reset
        pub type TIM17RST_A = AFIORST_A;
        ///Field `TIM17RST` reader - TIM17 timer reset
        pub type TIM17RST_R = AFIORST_R;
        ///Field `TIM17RST` writer - TIM17 timer reset
        pub struct TIM17RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM17RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM17RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            pub fn afiorst(&self) -> AFIORST_R {
                AFIORST_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            pub fn ioparst(&self) -> IOPARST_R {
                IOPARST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            pub fn iopbrst(&self) -> IOPBRST_R {
                IOPBRST_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            pub fn iopcrst(&self) -> IOPCRST_R {
                IOPCRST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            pub fn iopdrst(&self) -> IOPDRST_R {
                IOPDRST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - IO port E reset
            #[inline(always)]
            pub fn ioperst(&self) -> IOPERST_R {
                IOPERST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - IO port F reset
            #[inline(always)]
            pub fn iopfrst(&self) -> IOPFRST_R {
                IOPFRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - IO port G reset
            #[inline(always)]
            pub fn iopgrst(&self) -> IOPGRST_R {
                IOPGRST_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            pub fn adc1rst(&self) -> ADC1RST_R {
                ADC1RST_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            pub fn tim1rst(&self) -> TIM1RST_R {
                TIM1RST_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            pub fn spi1rst(&self) -> SPI1RST_R {
                SPI1RST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            pub fn usart1rst(&self) -> USART1RST_R {
                USART1RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 16 - TIM15 timer reset
            #[inline(always)]
            pub fn tim15rst(&self) -> TIM15RST_R {
                TIM15RST_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - TIM16 timer reset
            #[inline(always)]
            pub fn tim16rst(&self) -> TIM16RST_R {
                TIM16RST_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - TIM17 timer reset
            #[inline(always)]
            pub fn tim17rst(&self) -> TIM17RST_R {
                TIM17RST_R::new(((self.bits >> 18) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O reset
            #[inline(always)]
            pub fn afiorst(&mut self) -> AFIORST_W {
                AFIORST_W { w: self }
            }
            ///Bit 2 - IO port A reset
            #[inline(always)]
            pub fn ioparst(&mut self) -> IOPARST_W {
                IOPARST_W { w: self }
            }
            ///Bit 3 - IO port B reset
            #[inline(always)]
            pub fn iopbrst(&mut self) -> IOPBRST_W {
                IOPBRST_W { w: self }
            }
            ///Bit 4 - IO port C reset
            #[inline(always)]
            pub fn iopcrst(&mut self) -> IOPCRST_W {
                IOPCRST_W { w: self }
            }
            ///Bit 5 - IO port D reset
            #[inline(always)]
            pub fn iopdrst(&mut self) -> IOPDRST_W {
                IOPDRST_W { w: self }
            }
            ///Bit 6 - IO port E reset
            #[inline(always)]
            pub fn ioperst(&mut self) -> IOPERST_W {
                IOPERST_W { w: self }
            }
            ///Bit 7 - IO port F reset
            #[inline(always)]
            pub fn iopfrst(&mut self) -> IOPFRST_W {
                IOPFRST_W { w: self }
            }
            ///Bit 8 - IO port G reset
            #[inline(always)]
            pub fn iopgrst(&mut self) -> IOPGRST_W {
                IOPGRST_W { w: self }
            }
            ///Bit 9 - ADC 1 interface reset
            #[inline(always)]
            pub fn adc1rst(&mut self) -> ADC1RST_W {
                ADC1RST_W { w: self }
            }
            ///Bit 11 - TIM1 timer reset
            #[inline(always)]
            pub fn tim1rst(&mut self) -> TIM1RST_W {
                TIM1RST_W { w: self }
            }
            ///Bit 12 - SPI 1 reset
            #[inline(always)]
            pub fn spi1rst(&mut self) -> SPI1RST_W {
                SPI1RST_W { w: self }
            }
            ///Bit 14 - USART1 reset
            #[inline(always)]
            pub fn usart1rst(&mut self) -> USART1RST_W {
                USART1RST_W { w: self }
            }
            ///Bit 16 - TIM15 timer reset
            #[inline(always)]
            pub fn tim15rst(&mut self) -> TIM15RST_W {
                TIM15RST_W { w: self }
            }
            ///Bit 17 - TIM16 timer reset
            #[inline(always)]
            pub fn tim16rst(&mut self) -> TIM16RST_W {
                TIM16RST_W { w: self }
            }
            ///Bit 18 - TIM17 timer reset
            #[inline(always)]
            pub fn tim17rst(&mut self) -> TIM17RST_W {
                TIM17RST_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral reset register (RCC_APB2RSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2rstr](index.html) module
        pub struct APB2RSTR_SPEC;
        impl crate::RegisterSpec for APB2RSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2rstr::R](R) reader structure
        impl crate::Readable for APB2RSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2rstr::W](W) writer structure
        impl crate::Writable for APB2RSTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets APB2RSTR to value 0
        impl crate::Resettable for APB2RSTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///APB1RSTR register accessor: an alias for `Reg<APB1RSTR_SPEC>`
    pub type APB1RSTR = crate::Reg<apb1rstr::APB1RSTR_SPEC>;
    ///APB1 peripheral reset register (RCC_APB1RSTR)
    pub mod apb1rstr {
        ///Register `APB1RSTR` reader
        pub struct R(crate::R<APB1RSTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1RSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<APB1RSTR_SPEC>> for R {
            fn from(reader: crate::R<APB1RSTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1RSTR` writer
        pub struct W(crate::W<APB1RSTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1RSTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<APB1RSTR_SPEC>> for W {
            fn from(writer: crate::W<APB1RSTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Timer 2 reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2RST_A {
            ///1: Reset the selected module
            RESET = 1,
        }
        impl From<TIM2RST_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2RST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIM2RST` reader - Timer 2 reset
        pub struct TIM2RST_R(crate::FieldReader<bool, TIM2RST_A>);
        impl TIM2RST_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM2RST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TIM2RST_A> {
                match self.bits {
                    true => Some(TIM2RST_A::RESET),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == TIM2RST_A::RESET
            }
        }
        impl core::ops::Deref for TIM2RST_R {
            type Target = crate::FieldReader<bool, TIM2RST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM2RST` writer - Timer 2 reset
        pub struct TIM2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM2RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM2RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Timer 3 reset
        pub type TIM3RST_A = TIM2RST_A;
        ///Field `TIM3RST` reader - Timer 3 reset
        pub type TIM3RST_R = TIM2RST_R;
        ///Field `TIM3RST` writer - Timer 3 reset
        pub struct TIM3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM3RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM3RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Timer 4 reset
        pub type TIM4RST_A = TIM2RST_A;
        ///Field `TIM4RST` reader - Timer 4 reset
        pub type TIM4RST_R = TIM2RST_R;
        ///Field `TIM4RST` writer - Timer 4 reset
        pub struct TIM4RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM4RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM4RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Timer 5 reset
        pub type TIM5RST_A = TIM2RST_A;
        ///Field `TIM5RST` reader - Timer 5 reset
        pub type TIM5RST_R = TIM2RST_R;
        ///Field `TIM5RST` writer - Timer 5 reset
        pub struct TIM5RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM5RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM5RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Timer 6 reset
        pub type TIM6RST_A = TIM2RST_A;
        ///Field `TIM6RST` reader - Timer 6 reset
        pub type TIM6RST_R = TIM2RST_R;
        ///Field `TIM6RST` writer - Timer 6 reset
        pub struct TIM6RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM6RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM6RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Timer 7 reset
        pub type TIM7RST_A = TIM2RST_A;
        ///Field `TIM7RST` reader - Timer 7 reset
        pub type TIM7RST_R = TIM2RST_R;
        ///Field `TIM7RST` writer - Timer 7 reset
        pub struct TIM7RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM7RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM7RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Timer 12 reset
        pub type TIM12RST_A = TIM2RST_A;
        ///Field `TIM12RST` reader - Timer 12 reset
        pub type TIM12RST_R = TIM2RST_R;
        ///Field `TIM12RST` writer - Timer 12 reset
        pub struct TIM12RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM12RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM12RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Timer 13 reset
        pub type TIM13RST_A = TIM2RST_A;
        ///Field `TIM13RST` reader - Timer 13 reset
        pub type TIM13RST_R = TIM2RST_R;
        ///Field `TIM13RST` writer - Timer 13 reset
        pub struct TIM13RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM13RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM13RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Timer 14 reset
        pub type TIM14RST_A = TIM2RST_A;
        ///Field `TIM14RST` reader - Timer 14 reset
        pub type TIM14RST_R = TIM2RST_R;
        ///Field `TIM14RST` writer - Timer 14 reset
        pub struct TIM14RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM14RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(TIM14RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Window watchdog reset
        pub type WWDGRST_A = TIM2RST_A;
        ///Field `WWDGRST` reader - Window watchdog reset
        pub type WWDGRST_R = TIM2RST_R;
        ///Field `WWDGRST` writer - Window watchdog reset
        pub struct WWDGRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WWDGRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(WWDGRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///SPI2 reset
        pub type SPI2RST_A = TIM2RST_A;
        ///Field `SPI2RST` reader - SPI2 reset
        pub type SPI2RST_R = TIM2RST_R;
        ///Field `SPI2RST` writer - SPI2 reset
        pub struct SPI2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI2RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SPI2RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///SPI3 reset
        pub type SPI3RST_A = TIM2RST_A;
        ///Field `SPI3RST` reader - SPI3 reset
        pub type SPI3RST_R = TIM2RST_R;
        ///Field `SPI3RST` writer - SPI3 reset
        pub struct SPI3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI3RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SPI3RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///USART 2 reset
        pub type USART2RST_A = TIM2RST_A;
        ///Field `USART2RST` reader - USART 2 reset
        pub type USART2RST_R = TIM2RST_R;
        ///Field `USART2RST` writer - USART 2 reset
        pub struct USART2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART2RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(USART2RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///USART 3 reset
        pub type USART3RST_A = TIM2RST_A;
        ///Field `USART3RST` reader - USART 3 reset
        pub type USART3RST_R = TIM2RST_R;
        ///Field `USART3RST` writer - USART 3 reset
        pub struct USART3RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART3RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(USART3RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///USART 4 reset
        pub type UART4RST_A = TIM2RST_A;
        ///Field `UART4RST` reader - USART 4 reset
        pub type UART4RST_R = TIM2RST_R;
        ///Field `UART4RST` writer - USART 4 reset
        pub struct UART4RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART4RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UART4RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(UART4RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///USART 5 reset
        pub type UART5RST_A = TIM2RST_A;
        ///Field `UART5RST` reader - USART 5 reset
        pub type UART5RST_R = TIM2RST_R;
        ///Field `UART5RST` writer - USART 5 reset
        pub struct UART5RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART5RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UART5RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(UART5RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///I2C1 reset
        pub type I2C1RST_A = TIM2RST_A;
        ///Field `I2C1RST` reader - I2C1 reset
        pub type I2C1RST_R = TIM2RST_R;
        ///Field `I2C1RST` writer - I2C1 reset
        pub struct I2C1RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: I2C1RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(I2C1RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | ((value as u32 & 0x01) << 21);
                self.w
            }
        }
        ///I2C2 reset
        pub type I2C2RST_A = TIM2RST_A;
        ///Field `I2C2RST` reader - I2C2 reset
        pub type I2C2RST_R = TIM2RST_R;
        ///Field `I2C2RST` writer - I2C2 reset
        pub struct I2C2RST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2RST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: I2C2RST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(I2C2RST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Backup interface reset
        pub type BKPRST_A = TIM2RST_A;
        ///Field `BKPRST` reader - Backup interface reset
        pub type BKPRST_R = TIM2RST_R;
        ///Field `BKPRST` writer - Backup interface reset
        pub struct BKPRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKPRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BKPRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BKPRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        ///Power interface reset
        pub type PWRRST_A = TIM2RST_A;
        ///Field `PWRRST` reader - Power interface reset
        pub type PWRRST_R = TIM2RST_R;
        ///Field `PWRRST` writer - Power interface reset
        pub struct PWRRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWRRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PWRRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PWRRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | ((value as u32 & 0x01) << 28);
                self.w
            }
        }
        ///DAC interface reset
        pub type DACRST_A = TIM2RST_A;
        ///Field `DACRST` reader - DAC interface reset
        pub type DACRST_R = TIM2RST_R;
        ///Field `DACRST` writer - DAC interface reset
        pub struct DACRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DACRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(DACRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        ///CEC reset
        pub type CECRST_A = TIM2RST_A;
        ///Field `CECRST` reader - CEC reset
        pub type CECRST_R = TIM2RST_R;
        ///Field `CECRST` writer - CEC reset
        pub struct CECRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CECRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CECRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the selected module
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CECRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | ((value as u32 & 0x01) << 30);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            pub fn tim2rst(&self) -> TIM2RST_R {
                TIM2RST_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            pub fn tim3rst(&self) -> TIM3RST_R {
                TIM3RST_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            pub fn tim4rst(&self) -> TIM4RST_R {
                TIM4RST_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Timer 5 reset
            #[inline(always)]
            pub fn tim5rst(&self) -> TIM5RST_R {
                TIM5RST_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Timer 6 reset
            #[inline(always)]
            pub fn tim6rst(&self) -> TIM6RST_R {
                TIM6RST_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Timer 7 reset
            #[inline(always)]
            pub fn tim7rst(&self) -> TIM7RST_R {
                TIM7RST_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Timer 12 reset
            #[inline(always)]
            pub fn tim12rst(&self) -> TIM12RST_R {
                TIM12RST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Timer 13 reset
            #[inline(always)]
            pub fn tim13rst(&self) -> TIM13RST_R {
                TIM13RST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Timer 14 reset
            #[inline(always)]
            pub fn tim14rst(&self) -> TIM14RST_R {
                TIM14RST_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            pub fn wwdgrst(&self) -> WWDGRST_R {
                WWDGRST_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            pub fn spi2rst(&self) -> SPI2RST_R {
                SPI2RST_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - SPI3 reset
            #[inline(always)]
            pub fn spi3rst(&self) -> SPI3RST_R {
                SPI3RST_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            pub fn usart2rst(&self) -> USART2RST_R {
                USART2RST_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            pub fn usart3rst(&self) -> USART3RST_R {
                USART3RST_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bit 19 - USART 4 reset
            #[inline(always)]
            pub fn uart4rst(&self) -> UART4RST_R {
                UART4RST_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 20 - USART 5 reset
            #[inline(always)]
            pub fn uart5rst(&self) -> UART5RST_R {
                UART5RST_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            pub fn i2c1rst(&self) -> I2C1RST_R {
                I2C1RST_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            pub fn i2c2rst(&self) -> I2C2RST_R {
                I2C2RST_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            pub fn bkprst(&self) -> BKPRST_R {
                BKPRST_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            pub fn pwrrst(&self) -> PWRRST_R {
                PWRRST_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            ///Bit 29 - DAC interface reset
            #[inline(always)]
            pub fn dacrst(&self) -> DACRST_R {
                DACRST_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            ///Bit 30 - CEC reset
            #[inline(always)]
            pub fn cecrst(&self) -> CECRST_R {
                CECRST_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 reset
            #[inline(always)]
            pub fn tim2rst(&mut self) -> TIM2RST_W {
                TIM2RST_W { w: self }
            }
            ///Bit 1 - Timer 3 reset
            #[inline(always)]
            pub fn tim3rst(&mut self) -> TIM3RST_W {
                TIM3RST_W { w: self }
            }
            ///Bit 2 - Timer 4 reset
            #[inline(always)]
            pub fn tim4rst(&mut self) -> TIM4RST_W {
                TIM4RST_W { w: self }
            }
            ///Bit 3 - Timer 5 reset
            #[inline(always)]
            pub fn tim5rst(&mut self) -> TIM5RST_W {
                TIM5RST_W { w: self }
            }
            ///Bit 4 - Timer 6 reset
            #[inline(always)]
            pub fn tim6rst(&mut self) -> TIM6RST_W {
                TIM6RST_W { w: self }
            }
            ///Bit 5 - Timer 7 reset
            #[inline(always)]
            pub fn tim7rst(&mut self) -> TIM7RST_W {
                TIM7RST_W { w: self }
            }
            ///Bit 6 - Timer 12 reset
            #[inline(always)]
            pub fn tim12rst(&mut self) -> TIM12RST_W {
                TIM12RST_W { w: self }
            }
            ///Bit 7 - Timer 13 reset
            #[inline(always)]
            pub fn tim13rst(&mut self) -> TIM13RST_W {
                TIM13RST_W { w: self }
            }
            ///Bit 8 - Timer 14 reset
            #[inline(always)]
            pub fn tim14rst(&mut self) -> TIM14RST_W {
                TIM14RST_W { w: self }
            }
            ///Bit 11 - Window watchdog reset
            #[inline(always)]
            pub fn wwdgrst(&mut self) -> WWDGRST_W {
                WWDGRST_W { w: self }
            }
            ///Bit 14 - SPI2 reset
            #[inline(always)]
            pub fn spi2rst(&mut self) -> SPI2RST_W {
                SPI2RST_W { w: self }
            }
            ///Bit 15 - SPI3 reset
            #[inline(always)]
            pub fn spi3rst(&mut self) -> SPI3RST_W {
                SPI3RST_W { w: self }
            }
            ///Bit 17 - USART 2 reset
            #[inline(always)]
            pub fn usart2rst(&mut self) -> USART2RST_W {
                USART2RST_W { w: self }
            }
            ///Bit 18 - USART 3 reset
            #[inline(always)]
            pub fn usart3rst(&mut self) -> USART3RST_W {
                USART3RST_W { w: self }
            }
            ///Bit 19 - USART 4 reset
            #[inline(always)]
            pub fn uart4rst(&mut self) -> UART4RST_W {
                UART4RST_W { w: self }
            }
            ///Bit 20 - USART 5 reset
            #[inline(always)]
            pub fn uart5rst(&mut self) -> UART5RST_W {
                UART5RST_W { w: self }
            }
            ///Bit 21 - I2C1 reset
            #[inline(always)]
            pub fn i2c1rst(&mut self) -> I2C1RST_W {
                I2C1RST_W { w: self }
            }
            ///Bit 22 - I2C2 reset
            #[inline(always)]
            pub fn i2c2rst(&mut self) -> I2C2RST_W {
                I2C2RST_W { w: self }
            }
            ///Bit 27 - Backup interface reset
            #[inline(always)]
            pub fn bkprst(&mut self) -> BKPRST_W {
                BKPRST_W { w: self }
            }
            ///Bit 28 - Power interface reset
            #[inline(always)]
            pub fn pwrrst(&mut self) -> PWRRST_W {
                PWRRST_W { w: self }
            }
            ///Bit 29 - DAC interface reset
            #[inline(always)]
            pub fn dacrst(&mut self) -> DACRST_W {
                DACRST_W { w: self }
            }
            ///Bit 30 - CEC reset
            #[inline(always)]
            pub fn cecrst(&mut self) -> CECRST_W {
                CECRST_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral reset register (RCC_APB1RSTR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1rstr](index.html) module
        pub struct APB1RSTR_SPEC;
        impl crate::RegisterSpec for APB1RSTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1rstr::R](R) reader structure
        impl crate::Readable for APB1RSTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1rstr::W](W) writer structure
        impl crate::Writable for APB1RSTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets APB1RSTR to value 0
        impl crate::Resettable for APB1RSTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///AHBENR register accessor: an alias for `Reg<AHBENR_SPEC>`
    pub type AHBENR = crate::Reg<ahbenr::AHBENR_SPEC>;
    ///AHB Peripheral Clock enable register (RCC_AHBENR)
    pub mod ahbenr {
        ///Register `AHBENR` reader
        pub struct R(crate::R<AHBENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<AHBENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<AHBENR_SPEC>> for R {
            fn from(reader: crate::R<AHBENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `AHBENR` writer
        pub struct W(crate::W<AHBENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AHBENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<AHBENR_SPEC>> for W {
            fn from(writer: crate::W<AHBENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///DMA1 clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA1EN_A {
            ///0: The selected clock is disabled
            DISABLED = 0,
            ///1: The selected clock is enabled
            ENABLED = 1,
        }
        impl From<DMA1EN_A> for bool {
            #[inline(always)]
            fn from(variant: DMA1EN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMA1EN` reader - DMA1 clock enable
        pub struct DMA1EN_R(crate::FieldReader<bool, DMA1EN_A>);
        impl DMA1EN_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMA1EN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMA1EN_A {
                match self.bits {
                    false => DMA1EN_A::DISABLED,
                    true => DMA1EN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMA1EN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMA1EN_A::ENABLED
            }
        }
        impl core::ops::Deref for DMA1EN_R {
            type Target = crate::FieldReader<bool, DMA1EN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMA1EN` writer - DMA1 clock enable
        pub struct DMA1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMA1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///DMA2 clock enable
        pub type DMA2EN_A = DMA1EN_A;
        ///Field `DMA2EN` reader - DMA2 clock enable
        pub type DMA2EN_R = DMA1EN_R;
        ///Field `DMA2EN` writer - DMA2 clock enable
        pub struct DMA2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA2EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMA2EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA2EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA2EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///SRAM interface clock enable
        pub type SRAMEN_A = DMA1EN_A;
        ///Field `SRAMEN` reader - SRAM interface clock enable
        pub type SRAMEN_R = DMA1EN_R;
        ///Field `SRAMEN` writer - SRAM interface clock enable
        pub struct SRAMEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SRAMEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SRAMEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SRAMEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SRAMEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///FLITF clock enable
        pub type FLITFEN_A = DMA1EN_A;
        ///Field `FLITFEN` reader - FLITF clock enable
        pub type FLITFEN_R = DMA1EN_R;
        ///Field `FLITFEN` writer - FLITF clock enable
        pub struct FLITFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FLITFEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: FLITFEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FLITFEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FLITFEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///CRC clock enable
        pub type CRCEN_A = DMA1EN_A;
        ///Field `CRCEN` reader - CRC clock enable
        pub type CRCEN_R = DMA1EN_R;
        ///Field `CRCEN` writer - CRC clock enable
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///FSMC clock enable
        pub type FSMCEN_A = DMA1EN_A;
        ///Field `FSMCEN` reader - FSMC clock enable
        pub type FSMCEN_R = DMA1EN_R;
        ///Field `FSMCEN` writer - FSMC clock enable
        pub struct FSMCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FSMCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: FSMCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(FSMCEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(FSMCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        impl R {
            ///Bit 0 - DMA1 clock enable
            #[inline(always)]
            pub fn dma1en(&self) -> DMA1EN_R {
                DMA1EN_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - DMA2 clock enable
            #[inline(always)]
            pub fn dma2en(&self) -> DMA2EN_R {
                DMA2EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            pub fn sramen(&self) -> SRAMEN_R {
                SRAMEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 4 - FLITF clock enable
            #[inline(always)]
            pub fn flitfen(&self) -> FLITFEN_R {
                FLITFEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 8 - FSMC clock enable
            #[inline(always)]
            pub fn fsmcen(&self) -> FSMCEN_R {
                FSMCEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - DMA1 clock enable
            #[inline(always)]
            pub fn dma1en(&mut self) -> DMA1EN_W {
                DMA1EN_W { w: self }
            }
            ///Bit 1 - DMA2 clock enable
            #[inline(always)]
            pub fn dma2en(&mut self) -> DMA2EN_W {
                DMA2EN_W { w: self }
            }
            ///Bit 2 - SRAM interface clock enable
            #[inline(always)]
            pub fn sramen(&mut self) -> SRAMEN_W {
                SRAMEN_W { w: self }
            }
            ///Bit 4 - FLITF clock enable
            #[inline(always)]
            pub fn flitfen(&mut self) -> FLITFEN_W {
                FLITFEN_W { w: self }
            }
            ///Bit 6 - CRC clock enable
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            ///Bit 8 - FSMC clock enable
            #[inline(always)]
            pub fn fsmcen(&mut self) -> FSMCEN_W {
                FSMCEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AHB Peripheral Clock enable register (RCC_AHBENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ahbenr](index.html) module
        pub struct AHBENR_SPEC;
        impl crate::RegisterSpec for AHBENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ahbenr::R](R) reader structure
        impl crate::Readable for AHBENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ahbenr::W](W) writer structure
        impl crate::Writable for AHBENR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets AHBENR to value 0x14
        impl crate::Resettable for AHBENR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x14
            }
        }
    }
    ///APB2ENR register accessor: an alias for `Reg<APB2ENR_SPEC>`
    pub type APB2ENR = crate::Reg<apb2enr::APB2ENR_SPEC>;
    ///APB2 peripheral clock enable register (RCC_APB2ENR)
    pub mod apb2enr {
        ///Register `APB2ENR` reader
        pub struct R(crate::R<APB2ENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB2ENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<APB2ENR_SPEC>> for R {
            fn from(reader: crate::R<APB2ENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB2ENR` writer
        pub struct W(crate::W<APB2ENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB2ENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<APB2ENR_SPEC>> for W {
            fn from(writer: crate::W<APB2ENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Alternate function I/O clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AFIOEN_A {
            ///0: The selected clock is disabled
            DISABLED = 0,
            ///1: The selected clock is enabled
            ENABLED = 1,
        }
        impl From<AFIOEN_A> for bool {
            #[inline(always)]
            fn from(variant: AFIOEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AFIOEN` reader - Alternate function I/O clock enable
        pub struct AFIOEN_R(crate::FieldReader<bool, AFIOEN_A>);
        impl AFIOEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                AFIOEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AFIOEN_A {
                match self.bits {
                    false => AFIOEN_A::DISABLED,
                    true => AFIOEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == AFIOEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == AFIOEN_A::ENABLED
            }
        }
        impl core::ops::Deref for AFIOEN_R {
            type Target = crate::FieldReader<bool, AFIOEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AFIOEN` writer - Alternate function I/O clock enable
        pub struct AFIOEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AFIOEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AFIOEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AFIOEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///I/O port A clock enable
        pub type IOPAEN_A = AFIOEN_A;
        ///Field `IOPAEN` reader - I/O port A clock enable
        pub type IOPAEN_R = AFIOEN_R;
        ///Field `IOPAEN` writer - I/O port A clock enable
        pub struct IOPAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPAEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPAEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPAEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPAEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///I/O port B clock enable
        pub type IOPBEN_A = AFIOEN_A;
        ///Field `IOPBEN` reader - I/O port B clock enable
        pub type IOPBEN_R = AFIOEN_R;
        ///Field `IOPBEN` writer - I/O port B clock enable
        pub struct IOPBEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPBEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPBEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPBEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPBEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///I/O port C clock enable
        pub type IOPCEN_A = AFIOEN_A;
        ///Field `IOPCEN` reader - I/O port C clock enable
        pub type IOPCEN_R = AFIOEN_R;
        ///Field `IOPCEN` writer - I/O port C clock enable
        pub struct IOPCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPCEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///I/O port D clock enable
        pub type IOPDEN_A = AFIOEN_A;
        ///Field `IOPDEN` reader - I/O port D clock enable
        pub type IOPDEN_R = AFIOEN_R;
        ///Field `IOPDEN` writer - I/O port D clock enable
        pub struct IOPDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPDEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPDEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPDEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPDEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///I/O port E clock enable
        pub type IOPEEN_A = AFIOEN_A;
        ///Field `IOPEEN` reader - I/O port E clock enable
        pub type IOPEEN_R = AFIOEN_R;
        ///Field `IOPEEN` writer - I/O port E clock enable
        pub struct IOPEEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPEEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPEEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPEEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPEEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///I/O port F clock enable
        pub type IOPFEN_A = AFIOEN_A;
        ///Field `IOPFEN` reader - I/O port F clock enable
        pub type IOPFEN_R = AFIOEN_R;
        ///Field `IOPFEN` writer - I/O port F clock enable
        pub struct IOPFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPFEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPFEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPFEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPFEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///I/O port G clock enable
        pub type IOPGEN_A = AFIOEN_A;
        ///Field `IOPGEN` reader - I/O port G clock enable
        pub type IOPGEN_R = AFIOEN_R;
        ///Field `IOPGEN` writer - I/O port G clock enable
        pub struct IOPGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IOPGEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IOPGEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IOPGEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IOPGEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///ADC 1 interface clock enable
        pub type ADC1EN_A = AFIOEN_A;
        ///Field `ADC1EN` reader - ADC 1 interface clock enable
        pub type ADC1EN_R = AFIOEN_R;
        ///Field `ADC1EN` writer - ADC 1 interface clock enable
        pub struct ADC1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADC1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ADC1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADC1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADC1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///TIM1 Timer clock enable
        pub type TIM1EN_A = AFIOEN_A;
        ///Field `TIM1EN` reader - TIM1 Timer clock enable
        pub type TIM1EN_R = AFIOEN_R;
        ///Field `TIM1EN` writer - TIM1 Timer clock enable
        pub struct TIM1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///SPI 1 clock enable
        pub type SPI1EN_A = AFIOEN_A;
        ///Field `SPI1EN` reader - SPI 1 clock enable
        pub type SPI1EN_R = AFIOEN_R;
        ///Field `SPI1EN` writer - SPI 1 clock enable
        pub struct SPI1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPI1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPI1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///USART1 clock enable
        pub type USART1EN_A = AFIOEN_A;
        ///Field `USART1EN` reader - USART1 clock enable
        pub type USART1EN_R = AFIOEN_R;
        ///Field `USART1EN` writer - USART1 clock enable
        pub struct USART1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///TIM15 Timer clock enable
        pub type TIM15EN_A = AFIOEN_A;
        ///Field `TIM15EN` reader - TIM15 Timer clock enable
        pub type TIM15EN_R = AFIOEN_R;
        ///Field `TIM15EN` writer - TIM15 Timer clock enable
        pub struct TIM15EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM15EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM15EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM15EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///TIM16 Timer clock enable
        pub type TIM16EN_A = AFIOEN_A;
        ///Field `TIM16EN` reader - TIM16 Timer clock enable
        pub type TIM16EN_R = AFIOEN_R;
        ///Field `TIM16EN` writer - TIM16 Timer clock enable
        pub struct TIM16EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM16EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM16EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM16EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///TIM17 Timer clock enable
        pub type TIM17EN_A = AFIOEN_A;
        ///Field `TIM17EN` reader - TIM17 Timer clock enable
        pub type TIM17EN_R = AFIOEN_R;
        ///Field `TIM17EN` writer - TIM17 Timer clock enable
        pub struct TIM17EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM17EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM17EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM17EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            pub fn afioen(&self) -> AFIOEN_R {
                AFIOEN_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            pub fn iopaen(&self) -> IOPAEN_R {
                IOPAEN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            pub fn iopben(&self) -> IOPBEN_R {
                IOPBEN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            pub fn iopcen(&self) -> IOPCEN_R {
                IOPCEN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            pub fn iopden(&self) -> IOPDEN_R {
                IOPDEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - I/O port E clock enable
            #[inline(always)]
            pub fn iopeen(&self) -> IOPEEN_R {
                IOPEEN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - I/O port F clock enable
            #[inline(always)]
            pub fn iopfen(&self) -> IOPFEN_R {
                IOPFEN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - I/O port G clock enable
            #[inline(always)]
            pub fn iopgen(&self) -> IOPGEN_R {
                IOPGEN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - ADC 1 interface clock enable
            #[inline(always)]
            pub fn adc1en(&self) -> ADC1EN_R {
                ADC1EN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            pub fn tim1en(&self) -> TIM1EN_R {
                TIM1EN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            pub fn spi1en(&self) -> SPI1EN_R {
                SPI1EN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            pub fn usart1en(&self) -> USART1EN_R {
                USART1EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 16 - TIM15 Timer clock enable
            #[inline(always)]
            pub fn tim15en(&self) -> TIM15EN_R {
                TIM15EN_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - TIM16 Timer clock enable
            #[inline(always)]
            pub fn tim16en(&self) -> TIM16EN_R {
                TIM16EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - TIM17 Timer clock enable
            #[inline(always)]
            pub fn tim17en(&self) -> TIM17EN_R {
                TIM17EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Alternate function I/O clock enable
            #[inline(always)]
            pub fn afioen(&mut self) -> AFIOEN_W {
                AFIOEN_W { w: self }
            }
            ///Bit 2 - I/O port A clock enable
            #[inline(always)]
            pub fn iopaen(&mut self) -> IOPAEN_W {
                IOPAEN_W { w: self }
            }
            ///Bit 3 - I/O port B clock enable
            #[inline(always)]
            pub fn iopben(&mut self) -> IOPBEN_W {
                IOPBEN_W { w: self }
            }
            ///Bit 4 - I/O port C clock enable
            #[inline(always)]
            pub fn iopcen(&mut self) -> IOPCEN_W {
                IOPCEN_W { w: self }
            }
            ///Bit 5 - I/O port D clock enable
            #[inline(always)]
            pub fn iopden(&mut self) -> IOPDEN_W {
                IOPDEN_W { w: self }
            }
            ///Bit 6 - I/O port E clock enable
            #[inline(always)]
            pub fn iopeen(&mut self) -> IOPEEN_W {
                IOPEEN_W { w: self }
            }
            ///Bit 7 - I/O port F clock enable
            #[inline(always)]
            pub fn iopfen(&mut self) -> IOPFEN_W {
                IOPFEN_W { w: self }
            }
            ///Bit 8 - I/O port G clock enable
            #[inline(always)]
            pub fn iopgen(&mut self) -> IOPGEN_W {
                IOPGEN_W { w: self }
            }
            ///Bit 9 - ADC 1 interface clock enable
            #[inline(always)]
            pub fn adc1en(&mut self) -> ADC1EN_W {
                ADC1EN_W { w: self }
            }
            ///Bit 11 - TIM1 Timer clock enable
            #[inline(always)]
            pub fn tim1en(&mut self) -> TIM1EN_W {
                TIM1EN_W { w: self }
            }
            ///Bit 12 - SPI 1 clock enable
            #[inline(always)]
            pub fn spi1en(&mut self) -> SPI1EN_W {
                SPI1EN_W { w: self }
            }
            ///Bit 14 - USART1 clock enable
            #[inline(always)]
            pub fn usart1en(&mut self) -> USART1EN_W {
                USART1EN_W { w: self }
            }
            ///Bit 16 - TIM15 Timer clock enable
            #[inline(always)]
            pub fn tim15en(&mut self) -> TIM15EN_W {
                TIM15EN_W { w: self }
            }
            ///Bit 17 - TIM16 Timer clock enable
            #[inline(always)]
            pub fn tim16en(&mut self) -> TIM16EN_W {
                TIM16EN_W { w: self }
            }
            ///Bit 18 - TIM17 Timer clock enable
            #[inline(always)]
            pub fn tim17en(&mut self) -> TIM17EN_W {
                TIM17EN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB2 peripheral clock enable register (RCC_APB2ENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb2enr](index.html) module
        pub struct APB2ENR_SPEC;
        impl crate::RegisterSpec for APB2ENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb2enr::R](R) reader structure
        impl crate::Readable for APB2ENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb2enr::W](W) writer structure
        impl crate::Writable for APB2ENR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets APB2ENR to value 0
        impl crate::Resettable for APB2ENR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///APB1ENR register accessor: an alias for `Reg<APB1ENR_SPEC>`
    pub type APB1ENR = crate::Reg<apb1enr::APB1ENR_SPEC>;
    ///APB1 peripheral clock enable register (RCC_APB1ENR)
    pub mod apb1enr {
        ///Register `APB1ENR` reader
        pub struct R(crate::R<APB1ENR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<APB1ENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<APB1ENR_SPEC>> for R {
            fn from(reader: crate::R<APB1ENR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `APB1ENR` writer
        pub struct W(crate::W<APB1ENR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<APB1ENR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<APB1ENR_SPEC>> for W {
            fn from(writer: crate::W<APB1ENR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Timer 2 clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIM2EN_A {
            ///0: The selected clock is disabled
            DISABLED = 0,
            ///1: The selected clock is enabled
            ENABLED = 1,
        }
        impl From<TIM2EN_A> for bool {
            #[inline(always)]
            fn from(variant: TIM2EN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIM2EN` reader - Timer 2 clock enable
        pub struct TIM2EN_R(crate::FieldReader<bool, TIM2EN_A>);
        impl TIM2EN_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM2EN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIM2EN_A {
                match self.bits {
                    false => TIM2EN_A::DISABLED,
                    true => TIM2EN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TIM2EN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TIM2EN_A::ENABLED
            }
        }
        impl core::ops::Deref for TIM2EN_R {
            type Target = crate::FieldReader<bool, TIM2EN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM2EN` writer - Timer 2 clock enable
        pub struct TIM2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM2EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM2EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Timer 3 clock enable
        pub type TIM3EN_A = TIM2EN_A;
        ///Field `TIM3EN` reader - Timer 3 clock enable
        pub type TIM3EN_R = TIM2EN_R;
        ///Field `TIM3EN` writer - Timer 3 clock enable
        pub struct TIM3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM3EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM3EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM3EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Timer 4 clock enable
        pub type TIM4EN_A = TIM2EN_A;
        ///Field `TIM4EN` reader - Timer 4 clock enable
        pub type TIM4EN_R = TIM2EN_R;
        ///Field `TIM4EN` writer - Timer 4 clock enable
        pub struct TIM4EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM4EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM4EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM4EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Timer 5 clock enable
        pub type TIM5EN_A = TIM2EN_A;
        ///Field `TIM5EN` reader - Timer 5 clock enable
        pub type TIM5EN_R = TIM2EN_R;
        ///Field `TIM5EN` writer - Timer 5 clock enable
        pub struct TIM5EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM5EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM5EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM5EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Timer 6 clock enable
        pub type TIM6EN_A = TIM2EN_A;
        ///Field `TIM6EN` reader - Timer 6 clock enable
        pub type TIM6EN_R = TIM2EN_R;
        ///Field `TIM6EN` writer - Timer 6 clock enable
        pub struct TIM6EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM6EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM6EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM6EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM6EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Timer 7 clock enable
        pub type TIM7EN_A = TIM2EN_A;
        ///Field `TIM7EN` reader - Timer 7 clock enable
        pub type TIM7EN_R = TIM2EN_R;
        ///Field `TIM7EN` writer - Timer 7 clock enable
        pub struct TIM7EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM7EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM7EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM7EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM7EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Timer 12 clock enable
        pub type TIM12EN_A = TIM2EN_A;
        ///Field `TIM12EN` reader - Timer 12 clock enable
        pub type TIM12EN_R = TIM2EN_R;
        ///Field `TIM12EN` writer - Timer 12 clock enable
        pub struct TIM12EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM12EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM12EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM12EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Timer 13 clock enable
        pub type TIM13EN_A = TIM2EN_A;
        ///Field `TIM13EN` reader - Timer 13 clock enable
        pub type TIM13EN_R = TIM2EN_R;
        ///Field `TIM13EN` writer - Timer 13 clock enable
        pub struct TIM13EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM13EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM13EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM13EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Timer 14 clock enable
        pub type TIM14EN_A = TIM2EN_A;
        ///Field `TIM14EN` reader - Timer 14 clock enable
        pub type TIM14EN_R = TIM2EN_R;
        ///Field `TIM14EN` writer - Timer 14 clock enable
        pub struct TIM14EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIM14EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIM14EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIM14EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Window watchdog clock enable
        pub type WWDGEN_A = TIM2EN_A;
        ///Field `WWDGEN` reader - Window watchdog clock enable
        pub type WWDGEN_R = TIM2EN_R;
        ///Field `WWDGEN` writer - Window watchdog clock enable
        pub struct WWDGEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WWDGEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WWDGEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WWDGEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///SPI 2 clock enable
        pub type SPI2EN_A = TIM2EN_A;
        ///Field `SPI2EN` reader - SPI 2 clock enable
        pub type SPI2EN_R = TIM2EN_R;
        ///Field `SPI2EN` writer - SPI 2 clock enable
        pub struct SPI2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI2EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI2EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPI2EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPI2EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///SPI 3 clock enable
        pub type SPI3EN_A = TIM2EN_A;
        ///Field `SPI3EN` reader - SPI 3 clock enable
        pub type SPI3EN_R = TIM2EN_R;
        ///Field `SPI3EN` writer - SPI 3 clock enable
        pub struct SPI3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI3EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPI3EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPI3EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPI3EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///USART 2 clock enable
        pub type USART2EN_A = TIM2EN_A;
        ///Field `USART2EN` reader - USART 2 clock enable
        pub type USART2EN_R = TIM2EN_R;
        ///Field `USART2EN` writer - USART 2 clock enable
        pub struct USART2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART2EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART2EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART2EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///USART 3 clock enable
        pub type USART3EN_A = TIM2EN_A;
        ///Field `USART3EN` reader - USART 3 clock enable
        pub type USART3EN_R = TIM2EN_R;
        ///Field `USART3EN` writer - USART 3 clock enable
        pub struct USART3EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: USART3EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(USART3EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(USART3EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///UART 4 clock enable
        pub type UART4EN_A = TIM2EN_A;
        ///Field `UART4EN` reader - UART 4 clock enable
        pub type UART4EN_R = TIM2EN_R;
        ///Field `UART4EN` writer - UART 4 clock enable
        pub struct UART4EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART4EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UART4EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UART4EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UART4EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///UART 5 clock enable
        pub type UART5EN_A = TIM2EN_A;
        ///Field `UART5EN` reader - UART 5 clock enable
        pub type UART5EN_R = TIM2EN_R;
        ///Field `UART5EN` writer - UART 5 clock enable
        pub struct UART5EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UART5EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UART5EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UART5EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UART5EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///I2C 1 clock enable
        pub type I2C1EN_A = TIM2EN_A;
        ///Field `I2C1EN` reader - I2C 1 clock enable
        pub type I2C1EN_R = TIM2EN_R;
        ///Field `I2C1EN` writer - I2C 1 clock enable
        pub struct I2C1EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: I2C1EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C1EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C1EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | ((value as u32 & 0x01) << 21);
                self.w
            }
        }
        ///I2C 2 clock enable
        pub type I2C2EN_A = TIM2EN_A;
        ///Field `I2C2EN` reader - I2C 2 clock enable
        pub type I2C2EN_R = TIM2EN_R;
        ///Field `I2C2EN` writer - I2C 2 clock enable
        pub struct I2C2EN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C2EN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: I2C2EN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(I2C2EN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(I2C2EN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Backup interface clock enable
        pub type BKPEN_A = TIM2EN_A;
        ///Field `BKPEN` reader - Backup interface clock enable
        pub type BKPEN_R = TIM2EN_R;
        ///Field `BKPEN` writer - Backup interface clock enable
        pub struct BKPEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKPEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BKPEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BKPEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BKPEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        ///Power interface clock enable
        pub type PWREN_A = TIM2EN_A;
        ///Field `PWREN` reader - Power interface clock enable
        pub type PWREN_R = TIM2EN_R;
        ///Field `PWREN` writer - Power interface clock enable
        pub struct PWREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PWREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PWREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PWREN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PWREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | ((value as u32 & 0x01) << 28);
                self.w
            }
        }
        ///DAC interface clock enable
        pub type DACEN_A = TIM2EN_A;
        ///Field `DACEN` reader - DAC interface clock enable
        pub type DACEN_R = TIM2EN_R;
        ///Field `DACEN` writer - DAC interface clock enable
        pub struct DACEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DACEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DACEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DACEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        ///CEC clock enable
        pub type CECEN_A = TIM2EN_A;
        ///Field `CECEN` reader - CEC clock enable
        pub type CECEN_R = TIM2EN_R;
        ///Field `CECEN` writer - CEC clock enable
        pub struct CECEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CECEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CECEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The selected clock is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CECEN_A::DISABLED)
            }
            ///The selected clock is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CECEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | ((value as u32 & 0x01) << 30);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            pub fn tim2en(&self) -> TIM2EN_R {
                TIM2EN_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            pub fn tim3en(&self) -> TIM3EN_R {
                TIM3EN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            pub fn tim4en(&self) -> TIM4EN_R {
                TIM4EN_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Timer 5 clock enable
            #[inline(always)]
            pub fn tim5en(&self) -> TIM5EN_R {
                TIM5EN_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Timer 6 clock enable
            #[inline(always)]
            pub fn tim6en(&self) -> TIM6EN_R {
                TIM6EN_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Timer 7 clock enable
            #[inline(always)]
            pub fn tim7en(&self) -> TIM7EN_R {
                TIM7EN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Timer 12 clock enable
            #[inline(always)]
            pub fn tim12en(&self) -> TIM12EN_R {
                TIM12EN_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Timer 13 clock enable
            #[inline(always)]
            pub fn tim13en(&self) -> TIM13EN_R {
                TIM13EN_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Timer 14 clock enable
            #[inline(always)]
            pub fn tim14en(&self) -> TIM14EN_R {
                TIM14EN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            pub fn wwdgen(&self) -> WWDGEN_R {
                WWDGEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            pub fn spi2en(&self) -> SPI2EN_R {
                SPI2EN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - SPI 3 clock enable
            #[inline(always)]
            pub fn spi3en(&self) -> SPI3EN_R {
                SPI3EN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            pub fn usart2en(&self) -> USART2EN_R {
                USART2EN_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            pub fn usart3en(&self) -> USART3EN_R {
                USART3EN_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bit 19 - UART 4 clock enable
            #[inline(always)]
            pub fn uart4en(&self) -> UART4EN_R {
                UART4EN_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 20 - UART 5 clock enable
            #[inline(always)]
            pub fn uart5en(&self) -> UART5EN_R {
                UART5EN_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            pub fn i2c1en(&self) -> I2C1EN_R {
                I2C1EN_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            pub fn i2c2en(&self) -> I2C2EN_R {
                I2C2EN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            pub fn bkpen(&self) -> BKPEN_R {
                BKPEN_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            pub fn pwren(&self) -> PWREN_R {
                PWREN_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            ///Bit 29 - DAC interface clock enable
            #[inline(always)]
            pub fn dacen(&self) -> DACEN_R {
                DACEN_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            ///Bit 30 - CEC clock enable
            #[inline(always)]
            pub fn cecen(&self) -> CECEN_R {
                CECEN_R::new(((self.bits >> 30) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Timer 2 clock enable
            #[inline(always)]
            pub fn tim2en(&mut self) -> TIM2EN_W {
                TIM2EN_W { w: self }
            }
            ///Bit 1 - Timer 3 clock enable
            #[inline(always)]
            pub fn tim3en(&mut self) -> TIM3EN_W {
                TIM3EN_W { w: self }
            }
            ///Bit 2 - Timer 4 clock enable
            #[inline(always)]
            pub fn tim4en(&mut self) -> TIM4EN_W {
                TIM4EN_W { w: self }
            }
            ///Bit 3 - Timer 5 clock enable
            #[inline(always)]
            pub fn tim5en(&mut self) -> TIM5EN_W {
                TIM5EN_W { w: self }
            }
            ///Bit 4 - Timer 6 clock enable
            #[inline(always)]
            pub fn tim6en(&mut self) -> TIM6EN_W {
                TIM6EN_W { w: self }
            }
            ///Bit 5 - Timer 7 clock enable
            #[inline(always)]
            pub fn tim7en(&mut self) -> TIM7EN_W {
                TIM7EN_W { w: self }
            }
            ///Bit 6 - Timer 12 clock enable
            #[inline(always)]
            pub fn tim12en(&mut self) -> TIM12EN_W {
                TIM12EN_W { w: self }
            }
            ///Bit 7 - Timer 13 clock enable
            #[inline(always)]
            pub fn tim13en(&mut self) -> TIM13EN_W {
                TIM13EN_W { w: self }
            }
            ///Bit 8 - Timer 14 clock enable
            #[inline(always)]
            pub fn tim14en(&mut self) -> TIM14EN_W {
                TIM14EN_W { w: self }
            }
            ///Bit 11 - Window watchdog clock enable
            #[inline(always)]
            pub fn wwdgen(&mut self) -> WWDGEN_W {
                WWDGEN_W { w: self }
            }
            ///Bit 14 - SPI 2 clock enable
            #[inline(always)]
            pub fn spi2en(&mut self) -> SPI2EN_W {
                SPI2EN_W { w: self }
            }
            ///Bit 15 - SPI 3 clock enable
            #[inline(always)]
            pub fn spi3en(&mut self) -> SPI3EN_W {
                SPI3EN_W { w: self }
            }
            ///Bit 17 - USART 2 clock enable
            #[inline(always)]
            pub fn usart2en(&mut self) -> USART2EN_W {
                USART2EN_W { w: self }
            }
            ///Bit 18 - USART 3 clock enable
            #[inline(always)]
            pub fn usart3en(&mut self) -> USART3EN_W {
                USART3EN_W { w: self }
            }
            ///Bit 19 - UART 4 clock enable
            #[inline(always)]
            pub fn uart4en(&mut self) -> UART4EN_W {
                UART4EN_W { w: self }
            }
            ///Bit 20 - UART 5 clock enable
            #[inline(always)]
            pub fn uart5en(&mut self) -> UART5EN_W {
                UART5EN_W { w: self }
            }
            ///Bit 21 - I2C 1 clock enable
            #[inline(always)]
            pub fn i2c1en(&mut self) -> I2C1EN_W {
                I2C1EN_W { w: self }
            }
            ///Bit 22 - I2C 2 clock enable
            #[inline(always)]
            pub fn i2c2en(&mut self) -> I2C2EN_W {
                I2C2EN_W { w: self }
            }
            ///Bit 27 - Backup interface clock enable
            #[inline(always)]
            pub fn bkpen(&mut self) -> BKPEN_W {
                BKPEN_W { w: self }
            }
            ///Bit 28 - Power interface clock enable
            #[inline(always)]
            pub fn pwren(&mut self) -> PWREN_W {
                PWREN_W { w: self }
            }
            ///Bit 29 - DAC interface clock enable
            #[inline(always)]
            pub fn dacen(&mut self) -> DACEN_W {
                DACEN_W { w: self }
            }
            ///Bit 30 - CEC clock enable
            #[inline(always)]
            pub fn cecen(&mut self) -> CECEN_W {
                CECEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///APB1 peripheral clock enable register (RCC_APB1ENR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [apb1enr](index.html) module
        pub struct APB1ENR_SPEC;
        impl crate::RegisterSpec for APB1ENR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [apb1enr::R](R) reader structure
        impl crate::Readable for APB1ENR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [apb1enr::W](W) writer structure
        impl crate::Writable for APB1ENR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets APB1ENR to value 0
        impl crate::Resettable for APB1ENR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BDCR register accessor: an alias for `Reg<BDCR_SPEC>`
    pub type BDCR = crate::Reg<bdcr::BDCR_SPEC>;
    ///Backup domain control register (RCC_BDCR)
    pub mod bdcr {
        ///Register `BDCR` reader
        pub struct R(crate::R<BDCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BDCR_SPEC>> for R {
            fn from(reader: crate::R<BDCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDCR` writer
        pub struct W(crate::W<BDCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BDCR_SPEC>> for W {
            fn from(writer: crate::W<BDCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///External Low Speed oscillator enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEON_A {
            ///0: LSE oscillator Off
            OFF = 0,
            ///1: LSE oscillator On
            ON = 1,
        }
        impl From<LSEON_A> for bool {
            #[inline(always)]
            fn from(variant: LSEON_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSEON` reader - External Low Speed oscillator enable
        pub struct LSEON_R(crate::FieldReader<bool, LSEON_A>);
        impl LSEON_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSEON_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSEON_A {
                match self.bits {
                    false => LSEON_A::OFF,
                    true => LSEON_A::ON,
                }
            }
            ///Checks if the value of the field is `OFF`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                **self == LSEON_A::OFF
            }
            ///Checks if the value of the field is `ON`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                **self == LSEON_A::ON
            }
        }
        impl core::ops::Deref for LSEON_R {
            type Target = crate::FieldReader<bool, LSEON_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LSEON` writer - External Low Speed oscillator enable
        pub struct LSEON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEON_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSEON_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LSE oscillator Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSEON_A::OFF)
            }
            ///LSE oscillator On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSEON_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///External Low Speed oscillator ready
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSERDY_A {
            ///0: LSE oscillator not ready
            NOTREADY = 0,
            ///1: LSE oscillator ready
            READY = 1,
        }
        impl From<LSERDY_A> for bool {
            #[inline(always)]
            fn from(variant: LSERDY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSERDY` reader - External Low Speed oscillator ready
        pub struct LSERDY_R(crate::FieldReader<bool, LSERDY_A>);
        impl LSERDY_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSERDY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSERDY_A {
                match self.bits {
                    false => LSERDY_A::NOTREADY,
                    true => LSERDY_A::READY,
                }
            }
            ///Checks if the value of the field is `NOTREADY`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                **self == LSERDY_A::NOTREADY
            }
            ///Checks if the value of the field is `READY`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                **self == LSERDY_A::READY
            }
        }
        impl core::ops::Deref for LSERDY_R {
            type Target = crate::FieldReader<bool, LSERDY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///External Low Speed oscillator bypass
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSEBYP_A {
            ///0: LSE crystal oscillator not bypassed
            NOTBYPASSED = 0,
            ///1: LSE crystal oscillator bypassed with external clock
            BYPASSED = 1,
        }
        impl From<LSEBYP_A> for bool {
            #[inline(always)]
            fn from(variant: LSEBYP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSEBYP` reader - External Low Speed oscillator bypass
        pub struct LSEBYP_R(crate::FieldReader<bool, LSEBYP_A>);
        impl LSEBYP_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSEBYP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSEBYP_A {
                match self.bits {
                    false => LSEBYP_A::NOTBYPASSED,
                    true => LSEBYP_A::BYPASSED,
                }
            }
            ///Checks if the value of the field is `NOTBYPASSED`
            #[inline(always)]
            pub fn is_not_bypassed(&self) -> bool {
                **self == LSEBYP_A::NOTBYPASSED
            }
            ///Checks if the value of the field is `BYPASSED`
            #[inline(always)]
            pub fn is_bypassed(&self) -> bool {
                **self == LSEBYP_A::BYPASSED
            }
        }
        impl core::ops::Deref for LSEBYP_R {
            type Target = crate::FieldReader<bool, LSEBYP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LSEBYP` writer - External Low Speed oscillator bypass
        pub struct LSEBYP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSEBYP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSEBYP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LSE crystal oscillator not bypassed
            #[inline(always)]
            pub fn not_bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::NOTBYPASSED)
            }
            ///LSE crystal oscillator bypassed with external clock
            #[inline(always)]
            pub fn bypassed(self) -> &'a mut W {
                self.variant(LSEBYP_A::BYPASSED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///RTC clock source selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum RTCSEL_A {
            ///0: No clock
            NOCLOCK = 0,
            ///1: LSE oscillator clock used as RTC clock
            LSE = 1,
            ///2: LSI oscillator clock used as RTC clock
            LSI = 2,
            ///3: HSE oscillator clock divided by a prescaler used as RTC clock
            HSE = 3,
        }
        impl From<RTCSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: RTCSEL_A) -> Self {
                variant as _
            }
        }
        ///Field `RTCSEL` reader - RTC clock source selection
        pub struct RTCSEL_R(crate::FieldReader<u8, RTCSEL_A>);
        impl RTCSEL_R {
            pub(crate) fn new(bits: u8) -> Self {
                RTCSEL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTCSEL_A {
                match self.bits {
                    0 => RTCSEL_A::NOCLOCK,
                    1 => RTCSEL_A::LSE,
                    2 => RTCSEL_A::LSI,
                    3 => RTCSEL_A::HSE,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NOCLOCK`
            #[inline(always)]
            pub fn is_no_clock(&self) -> bool {
                **self == RTCSEL_A::NOCLOCK
            }
            ///Checks if the value of the field is `LSE`
            #[inline(always)]
            pub fn is_lse(&self) -> bool {
                **self == RTCSEL_A::LSE
            }
            ///Checks if the value of the field is `LSI`
            #[inline(always)]
            pub fn is_lsi(&self) -> bool {
                **self == RTCSEL_A::LSI
            }
            ///Checks if the value of the field is `HSE`
            #[inline(always)]
            pub fn is_hse(&self) -> bool {
                **self == RTCSEL_A::HSE
            }
        }
        impl core::ops::Deref for RTCSEL_R {
            type Target = crate::FieldReader<u8, RTCSEL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RTCSEL` writer - RTC clock source selection
        pub struct RTCSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCSEL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RTCSEL_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///No clock
            #[inline(always)]
            pub fn no_clock(self) -> &'a mut W {
                self.variant(RTCSEL_A::NOCLOCK)
            }
            ///LSE oscillator clock used as RTC clock
            #[inline(always)]
            pub fn lse(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSE)
            }
            ///LSI oscillator clock used as RTC clock
            #[inline(always)]
            pub fn lsi(self) -> &'a mut W {
                self.variant(RTCSEL_A::LSI)
            }
            ///HSE oscillator clock divided by a prescaler used as RTC clock
            #[inline(always)]
            pub fn hse(self) -> &'a mut W {
                self.variant(RTCSEL_A::HSE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///RTC clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTCEN_A {
            ///0: RTC clock disabled
            DISABLED = 0,
            ///1: RTC clock enabled
            ENABLED = 1,
        }
        impl From<RTCEN_A> for bool {
            #[inline(always)]
            fn from(variant: RTCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RTCEN` reader - RTC clock enable
        pub struct RTCEN_R(crate::FieldReader<bool, RTCEN_A>);
        impl RTCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                RTCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTCEN_A {
                match self.bits {
                    false => RTCEN_A::DISABLED,
                    true => RTCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RTCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RTCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for RTCEN_R {
            type Target = crate::FieldReader<bool, RTCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RTCEN` writer - RTC clock enable
        pub struct RTCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RTCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RTC clock disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTCEN_A::DISABLED)
            }
            ///RTC clock enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Backup domain software reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BDRST_A {
            ///0: Reset not activated
            DISABLED = 0,
            ///1: Reset the entire RTC domain
            ENABLED = 1,
        }
        impl From<BDRST_A> for bool {
            #[inline(always)]
            fn from(variant: BDRST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BDRST` reader - Backup domain software reset
        pub struct BDRST_R(crate::FieldReader<bool, BDRST_A>);
        impl BDRST_R {
            pub(crate) fn new(bits: bool) -> Self {
                BDRST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BDRST_A {
                match self.bits {
                    false => BDRST_A::DISABLED,
                    true => BDRST_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == BDRST_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == BDRST_A::ENABLED
            }
        }
        impl core::ops::Deref for BDRST_R {
            type Target = crate::FieldReader<bool, BDRST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BDRST` writer - Backup domain software reset
        pub struct BDRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BDRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BDRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset not activated
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BDRST_A::DISABLED)
            }
            ///Reset the entire RTC domain
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BDRST_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        impl R {
            ///Bit 0 - External Low Speed oscillator enable
            #[inline(always)]
            pub fn lseon(&self) -> LSEON_R {
                LSEON_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - External Low Speed oscillator ready
            #[inline(always)]
            pub fn lserdy(&self) -> LSERDY_R {
                LSERDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - External Low Speed oscillator bypass
            #[inline(always)]
            pub fn lsebyp(&self) -> LSEBYP_R {
                LSEBYP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 8:9 - RTC clock source selection
            #[inline(always)]
            pub fn rtcsel(&self) -> RTCSEL_R {
                RTCSEL_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 15 - RTC clock enable
            #[inline(always)]
            pub fn rtcen(&self) -> RTCEN_R {
                RTCEN_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            pub fn bdrst(&self) -> BDRST_R {
                BDRST_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - External Low Speed oscillator enable
            #[inline(always)]
            pub fn lseon(&mut self) -> LSEON_W {
                LSEON_W { w: self }
            }
            ///Bit 2 - External Low Speed oscillator bypass
            #[inline(always)]
            pub fn lsebyp(&mut self) -> LSEBYP_W {
                LSEBYP_W { w: self }
            }
            ///Bits 8:9 - RTC clock source selection
            #[inline(always)]
            pub fn rtcsel(&mut self) -> RTCSEL_W {
                RTCSEL_W { w: self }
            }
            ///Bit 15 - RTC clock enable
            #[inline(always)]
            pub fn rtcen(&mut self) -> RTCEN_W {
                RTCEN_W { w: self }
            }
            ///Bit 16 - Backup domain software reset
            #[inline(always)]
            pub fn bdrst(&mut self) -> BDRST_W {
                BDRST_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup domain control register (RCC_BDCR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdcr](index.html) module
        pub struct BDCR_SPEC;
        impl crate::RegisterSpec for BDCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdcr::R](R) reader structure
        impl crate::Readable for BDCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdcr::W](W) writer structure
        impl crate::Writable for BDCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BDCR to value 0
        impl crate::Resettable for BDCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CSR register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///Control/status register (RCC_CSR)
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CSR_SPEC>> for R {
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CSR` writer
        pub struct W(crate::W<CSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CSR_SPEC>> for W {
            fn from(writer: crate::W<CSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Internal low speed oscillator enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSION_A {
            ///0: LSI oscillator Off
            OFF = 0,
            ///1: LSI oscillator On
            ON = 1,
        }
        impl From<LSION_A> for bool {
            #[inline(always)]
            fn from(variant: LSION_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSION` reader - Internal low speed oscillator enable
        pub struct LSION_R(crate::FieldReader<bool, LSION_A>);
        impl LSION_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSION_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSION_A {
                match self.bits {
                    false => LSION_A::OFF,
                    true => LSION_A::ON,
                }
            }
            ///Checks if the value of the field is `OFF`
            #[inline(always)]
            pub fn is_off(&self) -> bool {
                **self == LSION_A::OFF
            }
            ///Checks if the value of the field is `ON`
            #[inline(always)]
            pub fn is_on(&self) -> bool {
                **self == LSION_A::ON
            }
        }
        impl core::ops::Deref for LSION_R {
            type Target = crate::FieldReader<bool, LSION_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LSION` writer - Internal low speed oscillator enable
        pub struct LSION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSION_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSION_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LSI oscillator Off
            #[inline(always)]
            pub fn off(self) -> &'a mut W {
                self.variant(LSION_A::OFF)
            }
            ///LSI oscillator On
            #[inline(always)]
            pub fn on(self) -> &'a mut W {
                self.variant(LSION_A::ON)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Internal low speed oscillator ready
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSIRDY_A {
            ///0: LSI oscillator not ready
            NOTREADY = 0,
            ///1: LSI oscillator ready
            READY = 1,
        }
        impl From<LSIRDY_A> for bool {
            #[inline(always)]
            fn from(variant: LSIRDY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSIRDY` reader - Internal low speed oscillator ready
        pub struct LSIRDY_R(crate::FieldReader<bool, LSIRDY_A>);
        impl LSIRDY_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSIRDY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSIRDY_A {
                match self.bits {
                    false => LSIRDY_A::NOTREADY,
                    true => LSIRDY_A::READY,
                }
            }
            ///Checks if the value of the field is `NOTREADY`
            #[inline(always)]
            pub fn is_not_ready(&self) -> bool {
                **self == LSIRDY_A::NOTREADY
            }
            ///Checks if the value of the field is `READY`
            #[inline(always)]
            pub fn is_ready(&self) -> bool {
                **self == LSIRDY_A::READY
            }
        }
        impl core::ops::Deref for LSIRDY_R {
            type Target = crate::FieldReader<bool, LSIRDY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Remove reset flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RMVF_A {
            ///1: Clears the reset flag
            CLEAR = 1,
        }
        impl From<RMVF_A> for bool {
            #[inline(always)]
            fn from(variant: RMVF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RMVF` reader - Remove reset flag
        pub struct RMVF_R(crate::FieldReader<bool, RMVF_A>);
        impl RMVF_R {
            pub(crate) fn new(bits: bool) -> Self {
                RMVF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<RMVF_A> {
                match self.bits {
                    true => Some(RMVF_A::CLEAR),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == RMVF_A::CLEAR
            }
        }
        impl core::ops::Deref for RMVF_R {
            type Target = crate::FieldReader<bool, RMVF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RMVF` writer - Remove reset flag
        pub struct RMVF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RMVF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RMVF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the reset flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(RMVF_A::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | ((value as u32 & 0x01) << 24);
                self.w
            }
        }
        ///PIN reset flag
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PINRSTF_A {
            ///0: No reset has occured
            NORESET = 0,
            ///1: A reset has occured
            RESET = 1,
        }
        impl From<PINRSTF_A> for bool {
            #[inline(always)]
            fn from(variant: PINRSTF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PINRSTF` reader - PIN reset flag
        pub struct PINRSTF_R(crate::FieldReader<bool, PINRSTF_A>);
        impl PINRSTF_R {
            pub(crate) fn new(bits: bool) -> Self {
                PINRSTF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PINRSTF_A {
                match self.bits {
                    false => PINRSTF_A::NORESET,
                    true => PINRSTF_A::RESET,
                }
            }
            ///Checks if the value of the field is `NORESET`
            #[inline(always)]
            pub fn is_no_reset(&self) -> bool {
                **self == PINRSTF_A::NORESET
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == PINRSTF_A::RESET
            }
        }
        impl core::ops::Deref for PINRSTF_R {
            type Target = crate::FieldReader<bool, PINRSTF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PINRSTF` writer - PIN reset flag
        pub struct PINRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PINRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PINRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PINRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | ((value as u32 & 0x01) << 26);
                self.w
            }
        }
        ///POR/PDR reset flag
        pub type PORRSTF_A = PINRSTF_A;
        ///Field `PORRSTF` reader - POR/PDR reset flag
        pub type PORRSTF_R = PINRSTF_R;
        ///Field `PORRSTF` writer - POR/PDR reset flag
        pub struct PORRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PORRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PORRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(PORRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(PORRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        ///Software reset flag
        pub type SFTRSTF_A = PINRSTF_A;
        ///Field `SFTRSTF` reader - Software reset flag
        pub type SFTRSTF_R = PINRSTF_R;
        ///Field `SFTRSTF` writer - Software reset flag
        pub struct SFTRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SFTRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SFTRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(SFTRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SFTRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | ((value as u32 & 0x01) << 28);
                self.w
            }
        }
        ///Independent watchdog reset flag
        pub type IWDGRSTF_A = PINRSTF_A;
        ///Field `IWDGRSTF` reader - Independent watchdog reset flag
        pub type IWDGRSTF_R = PINRSTF_R;
        ///Field `IWDGRSTF` writer - Independent watchdog reset flag
        pub struct IWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IWDGRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IWDGRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(IWDGRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(IWDGRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        ///Window watchdog reset flag
        pub type WWDGRSTF_A = PINRSTF_A;
        ///Field `WWDGRSTF` reader - Window watchdog reset flag
        pub type WWDGRSTF_R = PINRSTF_R;
        ///Field `WWDGRSTF` writer - Window watchdog reset flag
        pub struct WWDGRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WWDGRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WWDGRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(WWDGRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(WWDGRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | ((value as u32 & 0x01) << 30);
                self.w
            }
        }
        ///Low-power reset flag
        pub type LPWRRSTF_A = PINRSTF_A;
        ///Field `LPWRRSTF` reader - Low-power reset flag
        pub type LPWRRSTF_R = PINRSTF_R;
        ///Field `LPWRRSTF` writer - Low-power reset flag
        pub struct LPWRRSTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LPWRRSTF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LPWRRSTF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No reset has occured
            #[inline(always)]
            pub fn no_reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::NORESET)
            }
            ///A reset has occured
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(LPWRRSTF_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | ((value as u32 & 0x01) << 31);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            pub fn lsion(&self) -> LSION_R {
                LSION_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Internal low speed oscillator ready
            #[inline(always)]
            pub fn lsirdy(&self) -> LSIRDY_R {
                LSIRDY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            pub fn rmvf(&self) -> RMVF_R {
                RMVF_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            pub fn pinrstf(&self) -> PINRSTF_R {
                PINRSTF_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            pub fn porrstf(&self) -> PORRSTF_R {
                PORRSTF_R::new(((self.bits >> 27) & 0x01) != 0)
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            pub fn sftrstf(&self) -> SFTRSTF_R {
                SFTRSTF_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            pub fn iwdgrstf(&self) -> IWDGRSTF_R {
                IWDGRSTF_R::new(((self.bits >> 29) & 0x01) != 0)
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            pub fn wwdgrstf(&self) -> WWDGRSTF_R {
                WWDGRSTF_R::new(((self.bits >> 30) & 0x01) != 0)
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            pub fn lpwrrstf(&self) -> LPWRRSTF_R {
                LPWRRSTF_R::new(((self.bits >> 31) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Internal low speed oscillator enable
            #[inline(always)]
            pub fn lsion(&mut self) -> LSION_W {
                LSION_W { w: self }
            }
            ///Bit 24 - Remove reset flag
            #[inline(always)]
            pub fn rmvf(&mut self) -> RMVF_W {
                RMVF_W { w: self }
            }
            ///Bit 26 - PIN reset flag
            #[inline(always)]
            pub fn pinrstf(&mut self) -> PINRSTF_W {
                PINRSTF_W { w: self }
            }
            ///Bit 27 - POR/PDR reset flag
            #[inline(always)]
            pub fn porrstf(&mut self) -> PORRSTF_W {
                PORRSTF_W { w: self }
            }
            ///Bit 28 - Software reset flag
            #[inline(always)]
            pub fn sftrstf(&mut self) -> SFTRSTF_W {
                SFTRSTF_W { w: self }
            }
            ///Bit 29 - Independent watchdog reset flag
            #[inline(always)]
            pub fn iwdgrstf(&mut self) -> IWDGRSTF_W {
                IWDGRSTF_W { w: self }
            }
            ///Bit 30 - Window watchdog reset flag
            #[inline(always)]
            pub fn wwdgrstf(&mut self) -> WWDGRSTF_W {
                WWDGRSTF_W { w: self }
            }
            ///Bit 31 - Low-power reset flag
            #[inline(always)]
            pub fn lpwrrstf(&mut self) -> LPWRRSTF_W {
                LPWRRSTF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control/status register (RCC_CSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [csr::W](W) writer structure
        impl crate::Writable for CSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CSR to value 0x0c00_0000
        impl crate::Resettable for CSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x0c00_0000
            }
        }
    }
    ///CFGR2 register accessor: an alias for `Reg<CFGR2_SPEC>`
    pub type CFGR2 = crate::Reg<cfgr2::CFGR2_SPEC>;
    ///Clock configuration register 2
    pub mod cfgr2 {
        ///Register `CFGR2` reader
        pub struct R(crate::R<CFGR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CFGR2_SPEC>> for R {
            fn from(reader: crate::R<CFGR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR2` writer
        pub struct W(crate::W<CFGR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CFGR2_SPEC>> for W {
            fn from(writer: crate::W<CFGR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///PREDIV1 division factor
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PREDIV1_A {
            ///0: PREDIV input clock not divided
            DIV1 = 0,
            ///1: PREDIV input clock divided by 2
            DIV2 = 1,
            ///2: PREDIV input clock divided by 3
            DIV3 = 2,
            ///3: PREDIV input clock divided by 4
            DIV4 = 3,
            ///4: PREDIV input clock divided by 5
            DIV5 = 4,
            ///5: PREDIV input clock divided by 6
            DIV6 = 5,
            ///6: PREDIV input clock divided by 7
            DIV7 = 6,
            ///7: PREDIV input clock divided by 8
            DIV8 = 7,
            ///8: PREDIV input clock divided by 9
            DIV9 = 8,
            ///9: PREDIV input clock divided by 10
            DIV10 = 9,
            ///10: PREDIV input clock divided by 11
            DIV11 = 10,
            ///11: PREDIV input clock divided by 12
            DIV12 = 11,
            ///12: PREDIV input clock divided by 13
            DIV13 = 12,
            ///13: PREDIV input clock divided by 14
            DIV14 = 13,
            ///14: PREDIV input clock divided by 15
            DIV15 = 14,
            ///15: PREDIV input clock divided by 16
            DIV16 = 15,
        }
        impl From<PREDIV1_A> for u8 {
            #[inline(always)]
            fn from(variant: PREDIV1_A) -> Self {
                variant as _
            }
        }
        ///Field `PREDIV1` reader - PREDIV1 division factor
        pub struct PREDIV1_R(crate::FieldReader<u8, PREDIV1_A>);
        impl PREDIV1_R {
            pub(crate) fn new(bits: u8) -> Self {
                PREDIV1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PREDIV1_A {
                match self.bits {
                    0 => PREDIV1_A::DIV1,
                    1 => PREDIV1_A::DIV2,
                    2 => PREDIV1_A::DIV3,
                    3 => PREDIV1_A::DIV4,
                    4 => PREDIV1_A::DIV5,
                    5 => PREDIV1_A::DIV6,
                    6 => PREDIV1_A::DIV7,
                    7 => PREDIV1_A::DIV8,
                    8 => PREDIV1_A::DIV9,
                    9 => PREDIV1_A::DIV10,
                    10 => PREDIV1_A::DIV11,
                    11 => PREDIV1_A::DIV12,
                    12 => PREDIV1_A::DIV13,
                    13 => PREDIV1_A::DIV14,
                    14 => PREDIV1_A::DIV15,
                    15 => PREDIV1_A::DIV16,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == PREDIV1_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == PREDIV1_A::DIV2
            }
            ///Checks if the value of the field is `DIV3`
            #[inline(always)]
            pub fn is_div3(&self) -> bool {
                **self == PREDIV1_A::DIV3
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == PREDIV1_A::DIV4
            }
            ///Checks if the value of the field is `DIV5`
            #[inline(always)]
            pub fn is_div5(&self) -> bool {
                **self == PREDIV1_A::DIV5
            }
            ///Checks if the value of the field is `DIV6`
            #[inline(always)]
            pub fn is_div6(&self) -> bool {
                **self == PREDIV1_A::DIV6
            }
            ///Checks if the value of the field is `DIV7`
            #[inline(always)]
            pub fn is_div7(&self) -> bool {
                **self == PREDIV1_A::DIV7
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == PREDIV1_A::DIV8
            }
            ///Checks if the value of the field is `DIV9`
            #[inline(always)]
            pub fn is_div9(&self) -> bool {
                **self == PREDIV1_A::DIV9
            }
            ///Checks if the value of the field is `DIV10`
            #[inline(always)]
            pub fn is_div10(&self) -> bool {
                **self == PREDIV1_A::DIV10
            }
            ///Checks if the value of the field is `DIV11`
            #[inline(always)]
            pub fn is_div11(&self) -> bool {
                **self == PREDIV1_A::DIV11
            }
            ///Checks if the value of the field is `DIV12`
            #[inline(always)]
            pub fn is_div12(&self) -> bool {
                **self == PREDIV1_A::DIV12
            }
            ///Checks if the value of the field is `DIV13`
            #[inline(always)]
            pub fn is_div13(&self) -> bool {
                **self == PREDIV1_A::DIV13
            }
            ///Checks if the value of the field is `DIV14`
            #[inline(always)]
            pub fn is_div14(&self) -> bool {
                **self == PREDIV1_A::DIV14
            }
            ///Checks if the value of the field is `DIV15`
            #[inline(always)]
            pub fn is_div15(&self) -> bool {
                **self == PREDIV1_A::DIV15
            }
            ///Checks if the value of the field is `DIV16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                **self == PREDIV1_A::DIV16
            }
        }
        impl core::ops::Deref for PREDIV1_R {
            type Target = crate::FieldReader<u8, PREDIV1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PREDIV1` writer - PREDIV1 division factor
        pub struct PREDIV1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PREDIV1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PREDIV1_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///PREDIV input clock not divided
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV1)
            }
            ///PREDIV input clock divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV2)
            }
            ///PREDIV input clock divided by 3
            #[inline(always)]
            pub fn div3(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV3)
            }
            ///PREDIV input clock divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV4)
            }
            ///PREDIV input clock divided by 5
            #[inline(always)]
            pub fn div5(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV5)
            }
            ///PREDIV input clock divided by 6
            #[inline(always)]
            pub fn div6(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV6)
            }
            ///PREDIV input clock divided by 7
            #[inline(always)]
            pub fn div7(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV7)
            }
            ///PREDIV input clock divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV8)
            }
            ///PREDIV input clock divided by 9
            #[inline(always)]
            pub fn div9(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV9)
            }
            ///PREDIV input clock divided by 10
            #[inline(always)]
            pub fn div10(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV10)
            }
            ///PREDIV input clock divided by 11
            #[inline(always)]
            pub fn div11(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV11)
            }
            ///PREDIV input clock divided by 12
            #[inline(always)]
            pub fn div12(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV12)
            }
            ///PREDIV input clock divided by 13
            #[inline(always)]
            pub fn div13(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV13)
            }
            ///PREDIV input clock divided by 14
            #[inline(always)]
            pub fn div14(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV14)
            }
            ///PREDIV input clock divided by 15
            #[inline(always)]
            pub fn div15(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV15)
            }
            ///PREDIV input clock divided by 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(PREDIV1_A::DIV16)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - PREDIV1 division factor
            #[inline(always)]
            pub fn prediv1(&self) -> PREDIV1_R {
                PREDIV1_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - PREDIV1 division factor
            #[inline(always)]
            pub fn prediv1(&mut self) -> PREDIV1_W {
                PREDIV1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock configuration register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr2](index.html) module
        pub struct CFGR2_SPEC;
        impl crate::RegisterSpec for CFGR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr2::R](R) reader structure
        impl crate::Readable for CFGR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr2::W](W) writer structure
        impl crate::Writable for CFGR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CFGR2 to value 0
        impl crate::Resettable for CFGR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose I/O
pub struct GPIOA {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOA {}
impl GPIOA {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOA {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOA {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOA").finish()
    }
}
///General purpose I/O
pub mod gpioa {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Port configuration register low (GPIOn_CRL)
        pub crl: crate::Reg<crl::CRL_SPEC>,
        ///0x04 - Port configuration register high (GPIOn_CRL)
        pub crh: crate::Reg<crh::CRH_SPEC>,
        ///0x08 - Port input data register (GPIOn_IDR)
        pub idr: crate::Reg<idr::IDR_SPEC>,
        ///0x0c - Port output data register (GPIOn_ODR)
        pub odr: crate::Reg<odr::ODR_SPEC>,
        ///0x10 - Port bit set/reset register (GPIOn_BSRR)
        pub bsrr: crate::Reg<bsrr::BSRR_SPEC>,
        ///0x14 - Port bit reset register (GPIOn_BRR)
        pub brr: crate::Reg<brr::BRR_SPEC>,
        ///0x18 - Port configuration lock register
        pub lckr: crate::Reg<lckr::LCKR_SPEC>,
    }
    ///CRL register accessor: an alias for `Reg<CRL_SPEC>`
    pub type CRL = crate::Reg<crl::CRL_SPEC>;
    ///Port configuration register low (GPIOn_CRL)
    pub mod crl {
        ///Register `CRL` reader
        pub struct R(crate::R<CRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CRL_SPEC>> for R {
            fn from(reader: crate::R<CRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRL` writer
        pub struct W(crate::W<CRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CRL_SPEC>> for W {
            fn from(writer: crate::W<CRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Port n.0 mode bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE0_A {
            ///0: Input mode (reset state)
            INPUT = 0,
            ///1: Output mode 10 MHz
            OUTPUT = 1,
            ///2: Output mode 2 MHz
            OUTPUT2 = 2,
            ///3: Output mode 50 MHz
            OUTPUT50 = 3,
        }
        impl From<MODE0_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE0_A) -> Self {
                variant as _
            }
        }
        ///Field `MODE0` reader - Port n.0 mode bits
        pub struct MODE0_R(crate::FieldReader<u8, MODE0_A>);
        impl MODE0_R {
            pub(crate) fn new(bits: u8) -> Self {
                MODE0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODE0_A {
                match self.bits {
                    0 => MODE0_A::INPUT,
                    1 => MODE0_A::OUTPUT,
                    2 => MODE0_A::OUTPUT2,
                    3 => MODE0_A::OUTPUT50,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `INPUT`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                **self == MODE0_A::INPUT
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == MODE0_A::OUTPUT
            }
            ///Checks if the value of the field is `OUTPUT2`
            #[inline(always)]
            pub fn is_output2(&self) -> bool {
                **self == MODE0_A::OUTPUT2
            }
            ///Checks if the value of the field is `OUTPUT50`
            #[inline(always)]
            pub fn is_output50(&self) -> bool {
                **self == MODE0_A::OUTPUT50
            }
        }
        impl core::ops::Deref for MODE0_R {
            type Target = crate::FieldReader<u8, MODE0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MODE0` writer - Port n.0 mode bits
        pub struct MODE0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE0_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE0_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE0_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        ///Port n.0 configuration bits
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CNF0_A {
            ///0: Analog mode / Push-Pull mode
            PUSHPULL = 0,
            ///1: Floating input (reset state) / Open Drain-Mode
            OPENDRAIN = 1,
            ///2: Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            ALTPUSHPULL = 2,
            ///3: Alternate Function Open-Drain Mode
            ALTOPENDRAIN = 3,
        }
        impl From<CNF0_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF0_A) -> Self {
                variant as _
            }
        }
        ///Field `CNF0` reader - Port n.0 configuration bits
        pub struct CNF0_R(crate::FieldReader<u8, CNF0_A>);
        impl CNF0_R {
            pub(crate) fn new(bits: u8) -> Self {
                CNF0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CNF0_A {
                match self.bits {
                    0 => CNF0_A::PUSHPULL,
                    1 => CNF0_A::OPENDRAIN,
                    2 => CNF0_A::ALTPUSHPULL,
                    3 => CNF0_A::ALTOPENDRAIN,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `PUSHPULL`
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                **self == CNF0_A::PUSHPULL
            }
            ///Checks if the value of the field is `OPENDRAIN`
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                **self == CNF0_A::OPENDRAIN
            }
            ///Checks if the value of the field is `ALTPUSHPULL`
            #[inline(always)]
            pub fn is_alt_push_pull(&self) -> bool {
                **self == CNF0_A::ALTPUSHPULL
            }
            ///Checks if the value of the field is `ALTOPENDRAIN`
            #[inline(always)]
            pub fn is_alt_open_drain(&self) -> bool {
                **self == CNF0_A::ALTOPENDRAIN
            }
        }
        impl core::ops::Deref for CNF0_R {
            type Target = crate::FieldReader<u8, CNF0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNF0` writer - Port n.0 configuration bits
        pub struct CNF0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF0_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF0_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF0_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Port n.1 mode bits
        pub type MODE1_A = MODE0_A;
        ///Field `MODE1` reader - Port n.1 mode bits
        pub type MODE1_R = MODE0_R;
        ///Field `MODE1` writer - Port n.1 mode bits
        pub struct MODE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE1_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE1_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE1_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE1_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE1_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | ((value as u32 & 0x03) << 4);
                self.w
            }
        }
        ///Port n.1 configuration bits
        pub type CNF1_A = CNF0_A;
        ///Field `CNF1` reader - Port n.1 configuration bits
        pub type CNF1_R = CNF0_R;
        ///Field `CNF1` writer - Port n.1 configuration bits
        pub struct CNF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF1_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF1_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF1_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF1_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF1_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | ((value as u32 & 0x03) << 6);
                self.w
            }
        }
        ///Port n.2 mode bits
        pub type MODE2_A = MODE0_A;
        ///Field `MODE2` reader - Port n.2 mode bits
        pub type MODE2_R = MODE0_R;
        ///Field `MODE2` writer - Port n.2 mode bits
        pub struct MODE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE2_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE2_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE2_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE2_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE2_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Port n.2 configuration bits
        pub type CNF2_A = CNF0_A;
        ///Field `CNF2` reader - Port n.2 configuration bits
        pub type CNF2_R = CNF0_R;
        ///Field `CNF2` writer - Port n.2 configuration bits
        pub struct CNF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF2_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF2_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF2_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF2_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF2_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Port n.3 mode bits
        pub type MODE3_A = MODE0_A;
        ///Field `MODE3` reader - Port n.3 mode bits
        pub type MODE3_R = MODE0_R;
        ///Field `MODE3` writer - Port n.3 mode bits
        pub struct MODE3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE3_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE3_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE3_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE3_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE3_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///Port n.3 configuration bits
        pub type CNF3_A = CNF0_A;
        ///Field `CNF3` reader - Port n.3 configuration bits
        pub type CNF3_R = CNF0_R;
        ///Field `CNF3` writer - Port n.3 configuration bits
        pub struct CNF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF3_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF3_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF3_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF3_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF3_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | ((value as u32 & 0x03) << 14);
                self.w
            }
        }
        ///Port n.4 mode bits
        pub type MODE4_A = MODE0_A;
        ///Field `MODE4` reader - Port n.4 mode bits
        pub type MODE4_R = MODE0_R;
        ///Field `MODE4` writer - Port n.4 mode bits
        pub struct MODE4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE4_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE4_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE4_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE4_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE4_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | ((value as u32 & 0x03) << 16);
                self.w
            }
        }
        ///Port n.4 configuration bits
        pub type CNF4_A = CNF0_A;
        ///Field `CNF4` reader - Port n.4 configuration bits
        pub type CNF4_R = CNF0_R;
        ///Field `CNF4` writer - Port n.4 configuration bits
        pub struct CNF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF4_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF4_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF4_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF4_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF4_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | ((value as u32 & 0x03) << 18);
                self.w
            }
        }
        ///Port n.5 mode bits
        pub type MODE5_A = MODE0_A;
        ///Field `MODE5` reader - Port n.5 mode bits
        pub type MODE5_R = MODE0_R;
        ///Field `MODE5` writer - Port n.5 mode bits
        pub struct MODE5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE5_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE5_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE5_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE5_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE5_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | ((value as u32 & 0x03) << 20);
                self.w
            }
        }
        ///Port n.5 configuration bits
        pub type CNF5_A = CNF0_A;
        ///Field `CNF5` reader - Port n.5 configuration bits
        pub type CNF5_R = CNF0_R;
        ///Field `CNF5` writer - Port n.5 configuration bits
        pub struct CNF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF5_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF5_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF5_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF5_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF5_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | ((value as u32 & 0x03) << 22);
                self.w
            }
        }
        ///Port n.6 mode bits
        pub type MODE6_A = MODE0_A;
        ///Field `MODE6` reader - Port n.6 mode bits
        pub type MODE6_R = MODE0_R;
        ///Field `MODE6` writer - Port n.6 mode bits
        pub struct MODE6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE6_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE6_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE6_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE6_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE6_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | ((value as u32 & 0x03) << 24);
                self.w
            }
        }
        ///Port n.6 configuration bits
        pub type CNF6_A = CNF0_A;
        ///Field `CNF6` reader - Port n.6 configuration bits
        pub type CNF6_R = CNF0_R;
        ///Field `CNF6` writer - Port n.6 configuration bits
        pub struct CNF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF6_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF6_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF6_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF6_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF6_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | ((value as u32 & 0x03) << 26);
                self.w
            }
        }
        ///Port n.7 mode bits
        pub type MODE7_A = MODE0_A;
        ///Field `MODE7` reader - Port n.7 mode bits
        pub type MODE7_R = MODE0_R;
        ///Field `MODE7` writer - Port n.7 mode bits
        pub struct MODE7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE7_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE7_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE7_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE7_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE7_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | ((value as u32 & 0x03) << 28);
                self.w
            }
        }
        ///Port n.7 configuration bits
        pub type CNF7_A = CNF0_A;
        ///Field `CNF7` reader - Port n.7 configuration bits
        pub type CNF7_R = CNF0_R;
        ///Field `CNF7` writer - Port n.7 configuration bits
        pub struct CNF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF7_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF7_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF7_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF7_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF7_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | ((value as u32 & 0x03) << 30);
                self.w
            }
        }
        impl R {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            pub fn mode0(&self) -> MODE0_R {
                MODE0_R::new((self.bits & 0x03) as u8)
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            pub fn cnf0(&self) -> CNF0_R {
                CNF0_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            pub fn mode1(&self) -> MODE1_R {
                MODE1_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            pub fn cnf1(&self) -> CNF1_R {
                CNF1_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            pub fn mode2(&self) -> MODE2_R {
                MODE2_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            pub fn cnf2(&self) -> CNF2_R {
                CNF2_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            pub fn mode3(&self) -> MODE3_R {
                MODE3_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            pub fn cnf3(&self) -> CNF3_R {
                CNF3_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            pub fn mode4(&self) -> MODE4_R {
                MODE4_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            pub fn cnf4(&self) -> CNF4_R {
                CNF4_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            pub fn mode5(&self) -> MODE5_R {
                MODE5_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            pub fn cnf5(&self) -> CNF5_R {
                CNF5_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            pub fn mode6(&self) -> MODE6_R {
                MODE6_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            pub fn cnf6(&self) -> CNF6_R {
                CNF6_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            pub fn mode7(&self) -> MODE7_R {
                MODE7_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            pub fn cnf7(&self) -> CNF7_R {
                CNF7_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.0 mode bits
            #[inline(always)]
            pub fn mode0(&mut self) -> MODE0_W {
                MODE0_W { w: self }
            }
            ///Bits 2:3 - Port n.0 configuration bits
            #[inline(always)]
            pub fn cnf0(&mut self) -> CNF0_W {
                CNF0_W { w: self }
            }
            ///Bits 4:5 - Port n.1 mode bits
            #[inline(always)]
            pub fn mode1(&mut self) -> MODE1_W {
                MODE1_W { w: self }
            }
            ///Bits 6:7 - Port n.1 configuration bits
            #[inline(always)]
            pub fn cnf1(&mut self) -> CNF1_W {
                CNF1_W { w: self }
            }
            ///Bits 8:9 - Port n.2 mode bits
            #[inline(always)]
            pub fn mode2(&mut self) -> MODE2_W {
                MODE2_W { w: self }
            }
            ///Bits 10:11 - Port n.2 configuration bits
            #[inline(always)]
            pub fn cnf2(&mut self) -> CNF2_W {
                CNF2_W { w: self }
            }
            ///Bits 12:13 - Port n.3 mode bits
            #[inline(always)]
            pub fn mode3(&mut self) -> MODE3_W {
                MODE3_W { w: self }
            }
            ///Bits 14:15 - Port n.3 configuration bits
            #[inline(always)]
            pub fn cnf3(&mut self) -> CNF3_W {
                CNF3_W { w: self }
            }
            ///Bits 16:17 - Port n.4 mode bits
            #[inline(always)]
            pub fn mode4(&mut self) -> MODE4_W {
                MODE4_W { w: self }
            }
            ///Bits 18:19 - Port n.4 configuration bits
            #[inline(always)]
            pub fn cnf4(&mut self) -> CNF4_W {
                CNF4_W { w: self }
            }
            ///Bits 20:21 - Port n.5 mode bits
            #[inline(always)]
            pub fn mode5(&mut self) -> MODE5_W {
                MODE5_W { w: self }
            }
            ///Bits 22:23 - Port n.5 configuration bits
            #[inline(always)]
            pub fn cnf5(&mut self) -> CNF5_W {
                CNF5_W { w: self }
            }
            ///Bits 24:25 - Port n.6 mode bits
            #[inline(always)]
            pub fn mode6(&mut self) -> MODE6_W {
                MODE6_W { w: self }
            }
            ///Bits 26:27 - Port n.6 configuration bits
            #[inline(always)]
            pub fn cnf6(&mut self) -> CNF6_W {
                CNF6_W { w: self }
            }
            ///Bits 28:29 - Port n.7 mode bits
            #[inline(always)]
            pub fn mode7(&mut self) -> MODE7_W {
                MODE7_W { w: self }
            }
            ///Bits 30:31 - Port n.7 configuration bits
            #[inline(always)]
            pub fn cnf7(&mut self) -> CNF7_W {
                CNF7_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration register low (GPIOn_CRL)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crl](index.html) module
        pub struct CRL_SPEC;
        impl crate::RegisterSpec for CRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crl::R](R) reader structure
        impl crate::Readable for CRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crl::W](W) writer structure
        impl crate::Writable for CRL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CRL to value 0x4444_4444
        impl crate::Resettable for CRL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x4444_4444
            }
        }
    }
    ///CRH register accessor: an alias for `Reg<CRH_SPEC>`
    pub type CRH = crate::Reg<crh::CRH_SPEC>;
    ///Port configuration register high (GPIOn_CRL)
    pub mod crh {
        ///Register `CRH` reader
        pub struct R(crate::R<CRH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CRH_SPEC>> for R {
            fn from(reader: crate::R<CRH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRH` writer
        pub struct W(crate::W<CRH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CRH_SPEC>> for W {
            fn from(writer: crate::W<CRH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Port n.8 mode bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MODE8_A {
            ///0: Input mode (reset state)
            INPUT = 0,
            ///1: Output mode 10 MHz
            OUTPUT = 1,
            ///2: Output mode 2 MHz
            OUTPUT2 = 2,
            ///3: Output mode 50 MHz
            OUTPUT50 = 3,
        }
        impl From<MODE8_A> for u8 {
            #[inline(always)]
            fn from(variant: MODE8_A) -> Self {
                variant as _
            }
        }
        ///Field `MODE8` reader - Port n.8 mode bits
        pub struct MODE8_R(crate::FieldReader<u8, MODE8_A>);
        impl MODE8_R {
            pub(crate) fn new(bits: u8) -> Self {
                MODE8_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODE8_A {
                match self.bits {
                    0 => MODE8_A::INPUT,
                    1 => MODE8_A::OUTPUT,
                    2 => MODE8_A::OUTPUT2,
                    3 => MODE8_A::OUTPUT50,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `INPUT`
            #[inline(always)]
            pub fn is_input(&self) -> bool {
                **self == MODE8_A::INPUT
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == MODE8_A::OUTPUT
            }
            ///Checks if the value of the field is `OUTPUT2`
            #[inline(always)]
            pub fn is_output2(&self) -> bool {
                **self == MODE8_A::OUTPUT2
            }
            ///Checks if the value of the field is `OUTPUT50`
            #[inline(always)]
            pub fn is_output50(&self) -> bool {
                **self == MODE8_A::OUTPUT50
            }
        }
        impl core::ops::Deref for MODE8_R {
            type Target = crate::FieldReader<u8, MODE8_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MODE8` writer - Port n.8 mode bits
        pub struct MODE8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE8_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE8_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE8_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        ///Port n.8 configuration bits
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CNF8_A {
            ///0: Analog mode / Push-Pull mode
            PUSHPULL = 0,
            ///1: Floating input (reset state) / Open Drain-Mode
            OPENDRAIN = 1,
            ///2: Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            ALTPUSHPULL = 2,
            ///3: Alternate Function Open-Drain Mode
            ALTOPENDRAIN = 3,
        }
        impl From<CNF8_A> for u8 {
            #[inline(always)]
            fn from(variant: CNF8_A) -> Self {
                variant as _
            }
        }
        ///Field `CNF8` reader - Port n.8 configuration bits
        pub struct CNF8_R(crate::FieldReader<u8, CNF8_A>);
        impl CNF8_R {
            pub(crate) fn new(bits: u8) -> Self {
                CNF8_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CNF8_A {
                match self.bits {
                    0 => CNF8_A::PUSHPULL,
                    1 => CNF8_A::OPENDRAIN,
                    2 => CNF8_A::ALTPUSHPULL,
                    3 => CNF8_A::ALTOPENDRAIN,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `PUSHPULL`
            #[inline(always)]
            pub fn is_push_pull(&self) -> bool {
                **self == CNF8_A::PUSHPULL
            }
            ///Checks if the value of the field is `OPENDRAIN`
            #[inline(always)]
            pub fn is_open_drain(&self) -> bool {
                **self == CNF8_A::OPENDRAIN
            }
            ///Checks if the value of the field is `ALTPUSHPULL`
            #[inline(always)]
            pub fn is_alt_push_pull(&self) -> bool {
                **self == CNF8_A::ALTPUSHPULL
            }
            ///Checks if the value of the field is `ALTOPENDRAIN`
            #[inline(always)]
            pub fn is_alt_open_drain(&self) -> bool {
                **self == CNF8_A::ALTOPENDRAIN
            }
        }
        impl core::ops::Deref for CNF8_R {
            type Target = crate::FieldReader<u8, CNF8_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNF8` writer - Port n.8 configuration bits
        pub struct CNF8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF8_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF8_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF8_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Port n.9 mode bits
        pub type MODE9_A = MODE8_A;
        ///Field `MODE9` reader - Port n.9 mode bits
        pub type MODE9_R = MODE8_R;
        ///Field `MODE9` writer - Port n.9 mode bits
        pub struct MODE9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE9_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE9_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE9_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE9_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE9_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | ((value as u32 & 0x03) << 4);
                self.w
            }
        }
        ///Port n.9 configuration bits
        pub type CNF9_A = CNF8_A;
        ///Field `CNF9` reader - Port n.9 configuration bits
        pub type CNF9_R = CNF8_R;
        ///Field `CNF9` writer - Port n.9 configuration bits
        pub struct CNF9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF9_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF9_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF9_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF9_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF9_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | ((value as u32 & 0x03) << 6);
                self.w
            }
        }
        ///Port n.10 mode bits
        pub type MODE10_A = MODE8_A;
        ///Field `MODE10` reader - Port n.10 mode bits
        pub type MODE10_R = MODE8_R;
        ///Field `MODE10` writer - Port n.10 mode bits
        pub struct MODE10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE10_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE10_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE10_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE10_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE10_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Port n.10 configuration bits
        pub type CNF10_A = CNF8_A;
        ///Field `CNF10` reader - Port n.10 configuration bits
        pub type CNF10_R = CNF8_R;
        ///Field `CNF10` writer - Port n.10 configuration bits
        pub struct CNF10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF10_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF10_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF10_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF10_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF10_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Port n.11 mode bits
        pub type MODE11_A = MODE8_A;
        ///Field `MODE11` reader - Port n.11 mode bits
        pub type MODE11_R = MODE8_R;
        ///Field `MODE11` writer - Port n.11 mode bits
        pub struct MODE11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE11_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE11_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE11_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE11_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE11_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///Port n.11 configuration bits
        pub type CNF11_A = CNF8_A;
        ///Field `CNF11` reader - Port n.11 configuration bits
        pub type CNF11_R = CNF8_R;
        ///Field `CNF11` writer - Port n.11 configuration bits
        pub struct CNF11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF11_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF11_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF11_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF11_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF11_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 14)) | ((value as u32 & 0x03) << 14);
                self.w
            }
        }
        ///Port n.12 mode bits
        pub type MODE12_A = MODE8_A;
        ///Field `MODE12` reader - Port n.12 mode bits
        pub type MODE12_R = MODE8_R;
        ///Field `MODE12` writer - Port n.12 mode bits
        pub struct MODE12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE12_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE12_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE12_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE12_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE12_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 16)) | ((value as u32 & 0x03) << 16);
                self.w
            }
        }
        ///Port n.12 configuration bits
        pub type CNF12_A = CNF8_A;
        ///Field `CNF12` reader - Port n.12 configuration bits
        pub type CNF12_R = CNF8_R;
        ///Field `CNF12` writer - Port n.12 configuration bits
        pub struct CNF12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF12_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF12_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF12_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF12_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF12_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 18)) | ((value as u32 & 0x03) << 18);
                self.w
            }
        }
        ///Port n.13 mode bits
        pub type MODE13_A = MODE8_A;
        ///Field `MODE13` reader - Port n.13 mode bits
        pub type MODE13_R = MODE8_R;
        ///Field `MODE13` writer - Port n.13 mode bits
        pub struct MODE13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE13_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE13_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE13_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE13_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE13_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | ((value as u32 & 0x03) << 20);
                self.w
            }
        }
        ///Port n.13 configuration bits
        pub type CNF13_A = CNF8_A;
        ///Field `CNF13` reader - Port n.13 configuration bits
        pub type CNF13_R = CNF8_R;
        ///Field `CNF13` writer - Port n.13 configuration bits
        pub struct CNF13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF13_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF13_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF13_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF13_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF13_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | ((value as u32 & 0x03) << 22);
                self.w
            }
        }
        ///Port n.14 mode bits
        pub type MODE14_A = MODE8_A;
        ///Field `MODE14` reader - Port n.14 mode bits
        pub type MODE14_R = MODE8_R;
        ///Field `MODE14` writer - Port n.14 mode bits
        pub struct MODE14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE14_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE14_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE14_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE14_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE14_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 24)) | ((value as u32 & 0x03) << 24);
                self.w
            }
        }
        ///Port n.14 configuration bits
        pub type CNF14_A = CNF8_A;
        ///Field `CNF14` reader - Port n.14 configuration bits
        pub type CNF14_R = CNF8_R;
        ///Field `CNF14` writer - Port n.14 configuration bits
        pub struct CNF14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF14_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF14_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF14_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF14_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF14_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 26)) | ((value as u32 & 0x03) << 26);
                self.w
            }
        }
        ///Port n.15 mode bits
        pub type MODE15_A = MODE8_A;
        ///Field `MODE15` reader - Port n.15 mode bits
        pub type MODE15_R = MODE8_R;
        ///Field `MODE15` writer - Port n.15 mode bits
        pub struct MODE15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MODE15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MODE15_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Input mode (reset state)
            #[inline(always)]
            pub fn input(self) -> &'a mut W {
                self.variant(MODE15_A::INPUT)
            }
            ///Output mode 10 MHz
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT)
            }
            ///Output mode 2 MHz
            #[inline(always)]
            pub fn output2(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT2)
            }
            ///Output mode 50 MHz
            #[inline(always)]
            pub fn output50(self) -> &'a mut W {
                self.variant(MODE15_A::OUTPUT50)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 28)) | ((value as u32 & 0x03) << 28);
                self.w
            }
        }
        ///Port n.15 configuration bits
        pub type CNF15_A = CNF8_A;
        ///Field `CNF15` reader - Port n.15 configuration bits
        pub type CNF15_R = CNF8_R;
        ///Field `CNF15` writer - Port n.15 configuration bits
        pub struct CNF15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CNF15_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Analog mode / Push-Pull mode
            #[inline(always)]
            pub fn push_pull(self) -> &'a mut W {
                self.variant(CNF15_A::PUSHPULL)
            }
            ///Floating input (reset state) / Open Drain-Mode
            #[inline(always)]
            pub fn open_drain(self) -> &'a mut W {
                self.variant(CNF15_A::OPENDRAIN)
            }
            ///Input with pull-up/pull-down / Alternate Function Push-Pull Mode
            #[inline(always)]
            pub fn alt_push_pull(self) -> &'a mut W {
                self.variant(CNF15_A::ALTPUSHPULL)
            }
            ///Alternate Function Open-Drain Mode
            #[inline(always)]
            pub fn alt_open_drain(self) -> &'a mut W {
                self.variant(CNF15_A::ALTOPENDRAIN)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 30)) | ((value as u32 & 0x03) << 30);
                self.w
            }
        }
        impl R {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            pub fn mode8(&self) -> MODE8_R {
                MODE8_R::new((self.bits & 0x03) as u8)
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            pub fn cnf8(&self) -> CNF8_R {
                CNF8_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            pub fn mode9(&self) -> MODE9_R {
                MODE9_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            pub fn cnf9(&self) -> CNF9_R {
                CNF9_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            pub fn mode10(&self) -> MODE10_R {
                MODE10_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            pub fn cnf10(&self) -> CNF10_R {
                CNF10_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            pub fn mode11(&self) -> MODE11_R {
                MODE11_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            pub fn cnf11(&self) -> CNF11_R {
                CNF11_R::new(((self.bits >> 14) & 0x03) as u8)
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            pub fn mode12(&self) -> MODE12_R {
                MODE12_R::new(((self.bits >> 16) & 0x03) as u8)
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            pub fn cnf12(&self) -> CNF12_R {
                CNF12_R::new(((self.bits >> 18) & 0x03) as u8)
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            pub fn mode13(&self) -> MODE13_R {
                MODE13_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            pub fn cnf13(&self) -> CNF13_R {
                CNF13_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            pub fn mode14(&self) -> MODE14_R {
                MODE14_R::new(((self.bits >> 24) & 0x03) as u8)
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            pub fn cnf14(&self) -> CNF14_R {
                CNF14_R::new(((self.bits >> 26) & 0x03) as u8)
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            pub fn mode15(&self) -> MODE15_R {
                MODE15_R::new(((self.bits >> 28) & 0x03) as u8)
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            pub fn cnf15(&self) -> CNF15_R {
                CNF15_R::new(((self.bits >> 30) & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Port n.8 mode bits
            #[inline(always)]
            pub fn mode8(&mut self) -> MODE8_W {
                MODE8_W { w: self }
            }
            ///Bits 2:3 - Port n.8 configuration bits
            #[inline(always)]
            pub fn cnf8(&mut self) -> CNF8_W {
                CNF8_W { w: self }
            }
            ///Bits 4:5 - Port n.9 mode bits
            #[inline(always)]
            pub fn mode9(&mut self) -> MODE9_W {
                MODE9_W { w: self }
            }
            ///Bits 6:7 - Port n.9 configuration bits
            #[inline(always)]
            pub fn cnf9(&mut self) -> CNF9_W {
                CNF9_W { w: self }
            }
            ///Bits 8:9 - Port n.10 mode bits
            #[inline(always)]
            pub fn mode10(&mut self) -> MODE10_W {
                MODE10_W { w: self }
            }
            ///Bits 10:11 - Port n.10 configuration bits
            #[inline(always)]
            pub fn cnf10(&mut self) -> CNF10_W {
                CNF10_W { w: self }
            }
            ///Bits 12:13 - Port n.11 mode bits
            #[inline(always)]
            pub fn mode11(&mut self) -> MODE11_W {
                MODE11_W { w: self }
            }
            ///Bits 14:15 - Port n.11 configuration bits
            #[inline(always)]
            pub fn cnf11(&mut self) -> CNF11_W {
                CNF11_W { w: self }
            }
            ///Bits 16:17 - Port n.12 mode bits
            #[inline(always)]
            pub fn mode12(&mut self) -> MODE12_W {
                MODE12_W { w: self }
            }
            ///Bits 18:19 - Port n.12 configuration bits
            #[inline(always)]
            pub fn cnf12(&mut self) -> CNF12_W {
                CNF12_W { w: self }
            }
            ///Bits 20:21 - Port n.13 mode bits
            #[inline(always)]
            pub fn mode13(&mut self) -> MODE13_W {
                MODE13_W { w: self }
            }
            ///Bits 22:23 - Port n.13 configuration bits
            #[inline(always)]
            pub fn cnf13(&mut self) -> CNF13_W {
                CNF13_W { w: self }
            }
            ///Bits 24:25 - Port n.14 mode bits
            #[inline(always)]
            pub fn mode14(&mut self) -> MODE14_W {
                MODE14_W { w: self }
            }
            ///Bits 26:27 - Port n.14 configuration bits
            #[inline(always)]
            pub fn cnf14(&mut self) -> CNF14_W {
                CNF14_W { w: self }
            }
            ///Bits 28:29 - Port n.15 mode bits
            #[inline(always)]
            pub fn mode15(&mut self) -> MODE15_W {
                MODE15_W { w: self }
            }
            ///Bits 30:31 - Port n.15 configuration bits
            #[inline(always)]
            pub fn cnf15(&mut self) -> CNF15_W {
                CNF15_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration register high (GPIOn_CRL)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crh](index.html) module
        pub struct CRH_SPEC;
        impl crate::RegisterSpec for CRH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crh::R](R) reader structure
        impl crate::Readable for CRH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crh::W](W) writer structure
        impl crate::Writable for CRH_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CRH to value 0x4444_4444
        impl crate::Resettable for CRH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x4444_4444
            }
        }
    }
    ///IDR register accessor: an alias for `Reg<IDR_SPEC>`
    pub type IDR = crate::Reg<idr::IDR_SPEC>;
    ///Port input data register (GPIOn_IDR)
    pub mod idr {
        ///Register `IDR` reader
        pub struct R(crate::R<IDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<IDR_SPEC>> for R {
            fn from(reader: crate::R<IDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Port input data
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDR0_A {
            ///1: Input is logic high
            HIGH = 1,
            ///0: Input is logic low
            LOW = 0,
        }
        impl From<IDR0_A> for bool {
            #[inline(always)]
            fn from(variant: IDR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IDR0` reader - Port input data
        pub struct IDR0_R(crate::FieldReader<bool, IDR0_A>);
        impl IDR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                IDR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDR0_A {
                match self.bits {
                    true => IDR0_A::HIGH,
                    false => IDR0_A::LOW,
                }
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == IDR0_A::HIGH
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == IDR0_A::LOW
            }
        }
        impl core::ops::Deref for IDR0_R {
            type Target = crate::FieldReader<bool, IDR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Port input data
        pub type IDR1_A = IDR0_A;
        ///Field `IDR1` reader - Port input data
        pub type IDR1_R = IDR0_R;
        ///Port input data
        pub type IDR2_A = IDR0_A;
        ///Field `IDR2` reader - Port input data
        pub type IDR2_R = IDR0_R;
        ///Port input data
        pub type IDR3_A = IDR0_A;
        ///Field `IDR3` reader - Port input data
        pub type IDR3_R = IDR0_R;
        ///Port input data
        pub type IDR4_A = IDR0_A;
        ///Field `IDR4` reader - Port input data
        pub type IDR4_R = IDR0_R;
        ///Port input data
        pub type IDR5_A = IDR0_A;
        ///Field `IDR5` reader - Port input data
        pub type IDR5_R = IDR0_R;
        ///Port input data
        pub type IDR6_A = IDR0_A;
        ///Field `IDR6` reader - Port input data
        pub type IDR6_R = IDR0_R;
        ///Port input data
        pub type IDR7_A = IDR0_A;
        ///Field `IDR7` reader - Port input data
        pub type IDR7_R = IDR0_R;
        ///Port input data
        pub type IDR8_A = IDR0_A;
        ///Field `IDR8` reader - Port input data
        pub type IDR8_R = IDR0_R;
        ///Port input data
        pub type IDR9_A = IDR0_A;
        ///Field `IDR9` reader - Port input data
        pub type IDR9_R = IDR0_R;
        ///Port input data
        pub type IDR10_A = IDR0_A;
        ///Field `IDR10` reader - Port input data
        pub type IDR10_R = IDR0_R;
        ///Port input data
        pub type IDR11_A = IDR0_A;
        ///Field `IDR11` reader - Port input data
        pub type IDR11_R = IDR0_R;
        ///Port input data
        pub type IDR12_A = IDR0_A;
        ///Field `IDR12` reader - Port input data
        pub type IDR12_R = IDR0_R;
        ///Port input data
        pub type IDR13_A = IDR0_A;
        ///Field `IDR13` reader - Port input data
        pub type IDR13_R = IDR0_R;
        ///Port input data
        pub type IDR14_A = IDR0_A;
        ///Field `IDR14` reader - Port input data
        pub type IDR14_R = IDR0_R;
        ///Port input data
        pub type IDR15_A = IDR0_A;
        ///Field `IDR15` reader - Port input data
        pub type IDR15_R = IDR0_R;
        impl R {
            ///Bit 0 - Port input data
            #[inline(always)]
            pub fn idr0(&self) -> IDR0_R {
                IDR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Port input data
            #[inline(always)]
            pub fn idr1(&self) -> IDR1_R {
                IDR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Port input data
            #[inline(always)]
            pub fn idr2(&self) -> IDR2_R {
                IDR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Port input data
            #[inline(always)]
            pub fn idr3(&self) -> IDR3_R {
                IDR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Port input data
            #[inline(always)]
            pub fn idr4(&self) -> IDR4_R {
                IDR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Port input data
            #[inline(always)]
            pub fn idr5(&self) -> IDR5_R {
                IDR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Port input data
            #[inline(always)]
            pub fn idr6(&self) -> IDR6_R {
                IDR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Port input data
            #[inline(always)]
            pub fn idr7(&self) -> IDR7_R {
                IDR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Port input data
            #[inline(always)]
            pub fn idr8(&self) -> IDR8_R {
                IDR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Port input data
            #[inline(always)]
            pub fn idr9(&self) -> IDR9_R {
                IDR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Port input data
            #[inline(always)]
            pub fn idr10(&self) -> IDR10_R {
                IDR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Port input data
            #[inline(always)]
            pub fn idr11(&self) -> IDR11_R {
                IDR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Port input data
            #[inline(always)]
            pub fn idr12(&self) -> IDR12_R {
                IDR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Port input data
            #[inline(always)]
            pub fn idr13(&self) -> IDR13_R {
                IDR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Port input data
            #[inline(always)]
            pub fn idr14(&self) -> IDR14_R {
                IDR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Port input data
            #[inline(always)]
            pub fn idr15(&self) -> IDR15_R {
                IDR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        ///Port input data register (GPIOn_IDR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idr](index.html) module
        pub struct IDR_SPEC;
        impl crate::RegisterSpec for IDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idr::R](R) reader structure
        impl crate::Readable for IDR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDR to value 0
        impl crate::Resettable for IDR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ODR register accessor: an alias for `Reg<ODR_SPEC>`
    pub type ODR = crate::Reg<odr::ODR_SPEC>;
    ///Port output data register (GPIOn_ODR)
    pub mod odr {
        ///Register `ODR` reader
        pub struct R(crate::R<ODR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ODR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ODR_SPEC>> for R {
            fn from(reader: crate::R<ODR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ODR` writer
        pub struct W(crate::W<ODR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ODR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ODR_SPEC>> for W {
            fn from(writer: crate::W<ODR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Port output data
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ODR0_A {
            ///1: Set output to logic high
            HIGH = 1,
            ///0: Set output to logic low
            LOW = 0,
        }
        impl From<ODR0_A> for bool {
            #[inline(always)]
            fn from(variant: ODR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ODR0` reader - Port output data
        pub struct ODR0_R(crate::FieldReader<bool, ODR0_A>);
        impl ODR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                ODR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ODR0_A {
                match self.bits {
                    true => ODR0_A::HIGH,
                    false => ODR0_A::LOW,
                }
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == ODR0_A::HIGH
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == ODR0_A::LOW
            }
        }
        impl core::ops::Deref for ODR0_R {
            type Target = crate::FieldReader<bool, ODR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ODR0` writer - Port output data
        pub struct ODR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR0_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR0_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Port output data
        pub type ODR1_A = ODR0_A;
        ///Field `ODR1` reader - Port output data
        pub type ODR1_R = ODR0_R;
        ///Field `ODR1` writer - Port output data
        pub struct ODR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR1_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR1_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Port output data
        pub type ODR2_A = ODR0_A;
        ///Field `ODR2` reader - Port output data
        pub type ODR2_R = ODR0_R;
        ///Field `ODR2` writer - Port output data
        pub struct ODR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR2_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR2_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Port output data
        pub type ODR3_A = ODR0_A;
        ///Field `ODR3` reader - Port output data
        pub type ODR3_R = ODR0_R;
        ///Field `ODR3` writer - Port output data
        pub struct ODR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR3_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR3_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Port output data
        pub type ODR4_A = ODR0_A;
        ///Field `ODR4` reader - Port output data
        pub type ODR4_R = ODR0_R;
        ///Field `ODR4` writer - Port output data
        pub struct ODR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR4_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR4_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Port output data
        pub type ODR5_A = ODR0_A;
        ///Field `ODR5` reader - Port output data
        pub type ODR5_R = ODR0_R;
        ///Field `ODR5` writer - Port output data
        pub struct ODR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR5_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR5_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Port output data
        pub type ODR6_A = ODR0_A;
        ///Field `ODR6` reader - Port output data
        pub type ODR6_R = ODR0_R;
        ///Field `ODR6` writer - Port output data
        pub struct ODR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR6_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR6_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Port output data
        pub type ODR7_A = ODR0_A;
        ///Field `ODR7` reader - Port output data
        pub type ODR7_R = ODR0_R;
        ///Field `ODR7` writer - Port output data
        pub struct ODR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR7_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR7_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Port output data
        pub type ODR8_A = ODR0_A;
        ///Field `ODR8` reader - Port output data
        pub type ODR8_R = ODR0_R;
        ///Field `ODR8` writer - Port output data
        pub struct ODR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR8_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR8_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Port output data
        pub type ODR9_A = ODR0_A;
        ///Field `ODR9` reader - Port output data
        pub type ODR9_R = ODR0_R;
        ///Field `ODR9` writer - Port output data
        pub struct ODR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR9_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR9_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Port output data
        pub type ODR10_A = ODR0_A;
        ///Field `ODR10` reader - Port output data
        pub type ODR10_R = ODR0_R;
        ///Field `ODR10` writer - Port output data
        pub struct ODR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR10_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR10_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Port output data
        pub type ODR11_A = ODR0_A;
        ///Field `ODR11` reader - Port output data
        pub type ODR11_R = ODR0_R;
        ///Field `ODR11` writer - Port output data
        pub struct ODR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR11_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR11_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Port output data
        pub type ODR12_A = ODR0_A;
        ///Field `ODR12` reader - Port output data
        pub type ODR12_R = ODR0_R;
        ///Field `ODR12` writer - Port output data
        pub struct ODR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR12_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR12_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Port output data
        pub type ODR13_A = ODR0_A;
        ///Field `ODR13` reader - Port output data
        pub type ODR13_R = ODR0_R;
        ///Field `ODR13` writer - Port output data
        pub struct ODR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR13_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR13_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Port output data
        pub type ODR14_A = ODR0_A;
        ///Field `ODR14` reader - Port output data
        pub type ODR14_R = ODR0_R;
        ///Field `ODR14` writer - Port output data
        pub struct ODR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR14_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR14_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Port output data
        pub type ODR15_A = ODR0_A;
        ///Field `ODR15` reader - Port output data
        pub type ODR15_R = ODR0_R;
        ///Field `ODR15` writer - Port output data
        pub struct ODR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ODR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ODR15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Set output to logic high
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(ODR15_A::HIGH)
            }
            ///Set output to logic low
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(ODR15_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Port output data
            #[inline(always)]
            pub fn odr0(&self) -> ODR0_R {
                ODR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            pub fn odr1(&self) -> ODR1_R {
                ODR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            pub fn odr2(&self) -> ODR2_R {
                ODR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            pub fn odr3(&self) -> ODR3_R {
                ODR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            pub fn odr4(&self) -> ODR4_R {
                ODR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            pub fn odr5(&self) -> ODR5_R {
                ODR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            pub fn odr6(&self) -> ODR6_R {
                ODR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            pub fn odr7(&self) -> ODR7_R {
                ODR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            pub fn odr8(&self) -> ODR8_R {
                ODR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            pub fn odr9(&self) -> ODR9_R {
                ODR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            pub fn odr10(&self) -> ODR10_R {
                ODR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            pub fn odr11(&self) -> ODR11_R {
                ODR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            pub fn odr12(&self) -> ODR12_R {
                ODR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            pub fn odr13(&self) -> ODR13_R {
                ODR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            pub fn odr14(&self) -> ODR14_R {
                ODR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            pub fn odr15(&self) -> ODR15_R {
                ODR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port output data
            #[inline(always)]
            pub fn odr0(&mut self) -> ODR0_W {
                ODR0_W { w: self }
            }
            ///Bit 1 - Port output data
            #[inline(always)]
            pub fn odr1(&mut self) -> ODR1_W {
                ODR1_W { w: self }
            }
            ///Bit 2 - Port output data
            #[inline(always)]
            pub fn odr2(&mut self) -> ODR2_W {
                ODR2_W { w: self }
            }
            ///Bit 3 - Port output data
            #[inline(always)]
            pub fn odr3(&mut self) -> ODR3_W {
                ODR3_W { w: self }
            }
            ///Bit 4 - Port output data
            #[inline(always)]
            pub fn odr4(&mut self) -> ODR4_W {
                ODR4_W { w: self }
            }
            ///Bit 5 - Port output data
            #[inline(always)]
            pub fn odr5(&mut self) -> ODR5_W {
                ODR5_W { w: self }
            }
            ///Bit 6 - Port output data
            #[inline(always)]
            pub fn odr6(&mut self) -> ODR6_W {
                ODR6_W { w: self }
            }
            ///Bit 7 - Port output data
            #[inline(always)]
            pub fn odr7(&mut self) -> ODR7_W {
                ODR7_W { w: self }
            }
            ///Bit 8 - Port output data
            #[inline(always)]
            pub fn odr8(&mut self) -> ODR8_W {
                ODR8_W { w: self }
            }
            ///Bit 9 - Port output data
            #[inline(always)]
            pub fn odr9(&mut self) -> ODR9_W {
                ODR9_W { w: self }
            }
            ///Bit 10 - Port output data
            #[inline(always)]
            pub fn odr10(&mut self) -> ODR10_W {
                ODR10_W { w: self }
            }
            ///Bit 11 - Port output data
            #[inline(always)]
            pub fn odr11(&mut self) -> ODR11_W {
                ODR11_W { w: self }
            }
            ///Bit 12 - Port output data
            #[inline(always)]
            pub fn odr12(&mut self) -> ODR12_W {
                ODR12_W { w: self }
            }
            ///Bit 13 - Port output data
            #[inline(always)]
            pub fn odr13(&mut self) -> ODR13_W {
                ODR13_W { w: self }
            }
            ///Bit 14 - Port output data
            #[inline(always)]
            pub fn odr14(&mut self) -> ODR14_W {
                ODR14_W { w: self }
            }
            ///Bit 15 - Port output data
            #[inline(always)]
            pub fn odr15(&mut self) -> ODR15_W {
                ODR15_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port output data register (GPIOn_ODR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [odr](index.html) module
        pub struct ODR_SPEC;
        impl crate::RegisterSpec for ODR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [odr::R](R) reader structure
        impl crate::Readable for ODR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [odr::W](W) writer structure
        impl crate::Writable for ODR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ODR to value 0
        impl crate::Resettable for ODR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BSRR register accessor: an alias for `Reg<BSRR_SPEC>`
    pub type BSRR = crate::Reg<bsrr::BSRR_SPEC>;
    ///Port bit set/reset register (GPIOn_BSRR)
    pub mod bsrr {
        ///Register `BSRR` writer
        pub struct W(crate::W<BSRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BSRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BSRR_SPEC>> for W {
            fn from(writer: crate::W<BSRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Set bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BS0_AW {
            ///1: Sets the corresponding ODRx bit
            SET = 1,
        }
        impl From<BS0_AW> for bool {
            #[inline(always)]
            fn from(variant: BS0_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BS0` writer - Set bit 0
        pub struct BS0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS0_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS0_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Set bit 1
        pub type BS1_AW = BS0_AW;
        ///Field `BS1` writer - Set bit 1
        pub struct BS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS1_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Set bit 1
        pub type BS2_AW = BS0_AW;
        ///Field `BS2` writer - Set bit 1
        pub struct BS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS2_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Set bit 3
        pub type BS3_AW = BS0_AW;
        ///Field `BS3` writer - Set bit 3
        pub struct BS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS3_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Set bit 4
        pub type BS4_AW = BS0_AW;
        ///Field `BS4` writer - Set bit 4
        pub struct BS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS4_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Set bit 5
        pub type BS5_AW = BS0_AW;
        ///Field `BS5` writer - Set bit 5
        pub struct BS5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS5_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Set bit 6
        pub type BS6_AW = BS0_AW;
        ///Field `BS6` writer - Set bit 6
        pub struct BS6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS6_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Set bit 7
        pub type BS7_AW = BS0_AW;
        ///Field `BS7` writer - Set bit 7
        pub struct BS7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS7_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Set bit 8
        pub type BS8_AW = BS0_AW;
        ///Field `BS8` writer - Set bit 8
        pub struct BS8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS8_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS8_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Set bit 9
        pub type BS9_AW = BS0_AW;
        ///Field `BS9` writer - Set bit 9
        pub struct BS9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS9_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS9_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Set bit 10
        pub type BS10_AW = BS0_AW;
        ///Field `BS10` writer - Set bit 10
        pub struct BS10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS10_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS10_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Set bit 11
        pub type BS11_AW = BS0_AW;
        ///Field `BS11` writer - Set bit 11
        pub struct BS11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS11_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS11_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Set bit 12
        pub type BS12_AW = BS0_AW;
        ///Field `BS12` writer - Set bit 12
        pub struct BS12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS12_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS12_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Set bit 13
        pub type BS13_AW = BS0_AW;
        ///Field `BS13` writer - Set bit 13
        pub struct BS13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS13_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS13_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Set bit 14
        pub type BS14_AW = BS0_AW;
        ///Field `BS14` writer - Set bit 14
        pub struct BS14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS14_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS14_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Set bit 15
        pub type BS15_AW = BS0_AW;
        ///Field `BS15` writer - Set bit 15
        pub struct BS15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BS15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BS15_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Sets the corresponding ODRx bit
            #[inline(always)]
            pub fn set(self) -> &'a mut W {
                self.variant(BS15_AW::SET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Reset bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR0_AW {
            ///1: Resets the corresponding ODRx bit
            RESET = 1,
        }
        impl From<BR0_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BR0` writer - Reset bit 0
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Reset bit 1
        pub type BR1_AW = BR0_AW;
        ///Field `BR1` writer - Reset bit 1
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR1_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///Reset bit 2
        pub type BR2_AW = BR0_AW;
        ///Field `BR2` writer - Reset bit 2
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR2_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///Reset bit 3
        pub type BR3_AW = BR0_AW;
        ///Field `BR3` writer - Reset bit 3
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR3_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///Reset bit 4
        pub type BR4_AW = BR0_AW;
        ///Field `BR4` writer - Reset bit 4
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR4_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///Reset bit 5
        pub type BR5_AW = BR0_AW;
        ///Field `BR5` writer - Reset bit 5
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR5_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | ((value as u32 & 0x01) << 21);
                self.w
            }
        }
        ///Reset bit 6
        pub type BR6_AW = BR0_AW;
        ///Field `BR6` writer - Reset bit 6
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR6_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Reset bit 7
        pub type BR7_AW = BR0_AW;
        ///Field `BR7` writer - Reset bit 7
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR7_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        ///Reset bit 8
        pub type BR8_AW = BR0_AW;
        ///Field `BR8` writer - Reset bit 8
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR8_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | ((value as u32 & 0x01) << 24);
                self.w
            }
        }
        ///Reset bit 9
        pub type BR9_AW = BR0_AW;
        ///Field `BR9` writer - Reset bit 9
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR9_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | ((value as u32 & 0x01) << 25);
                self.w
            }
        }
        ///Reset bit 10
        pub type BR10_AW = BR0_AW;
        ///Field `BR10` writer - Reset bit 10
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR10_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | ((value as u32 & 0x01) << 26);
                self.w
            }
        }
        ///Reset bit 11
        pub type BR11_AW = BR0_AW;
        ///Field `BR11` writer - Reset bit 11
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR11_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        ///Reset bit 12
        pub type BR12_AW = BR0_AW;
        ///Field `BR12` writer - Reset bit 12
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR12_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | ((value as u32 & 0x01) << 28);
                self.w
            }
        }
        ///Reset bit 13
        pub type BR13_AW = BR0_AW;
        ///Field `BR13` writer - Reset bit 13
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR13_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        ///Reset bit 14
        pub type BR14_AW = BR0_AW;
        ///Field `BR14` writer - Reset bit 14
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR14_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 30)) | ((value as u32 & 0x01) << 30);
                self.w
            }
        }
        ///Reset bit 15
        pub type BR15_AW = BR0_AW;
        ///Field `BR15` writer - Reset bit 15
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the corresponding ODRx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 31)) | ((value as u32 & 0x01) << 31);
                self.w
            }
        }
        impl W {
            ///Bit 0 - Set bit 0
            #[inline(always)]
            pub fn bs0(&mut self) -> BS0_W {
                BS0_W { w: self }
            }
            ///Bit 1 - Set bit 1
            #[inline(always)]
            pub fn bs1(&mut self) -> BS1_W {
                BS1_W { w: self }
            }
            ///Bit 2 - Set bit 1
            #[inline(always)]
            pub fn bs2(&mut self) -> BS2_W {
                BS2_W { w: self }
            }
            ///Bit 3 - Set bit 3
            #[inline(always)]
            pub fn bs3(&mut self) -> BS3_W {
                BS3_W { w: self }
            }
            ///Bit 4 - Set bit 4
            #[inline(always)]
            pub fn bs4(&mut self) -> BS4_W {
                BS4_W { w: self }
            }
            ///Bit 5 - Set bit 5
            #[inline(always)]
            pub fn bs5(&mut self) -> BS5_W {
                BS5_W { w: self }
            }
            ///Bit 6 - Set bit 6
            #[inline(always)]
            pub fn bs6(&mut self) -> BS6_W {
                BS6_W { w: self }
            }
            ///Bit 7 - Set bit 7
            #[inline(always)]
            pub fn bs7(&mut self) -> BS7_W {
                BS7_W { w: self }
            }
            ///Bit 8 - Set bit 8
            #[inline(always)]
            pub fn bs8(&mut self) -> BS8_W {
                BS8_W { w: self }
            }
            ///Bit 9 - Set bit 9
            #[inline(always)]
            pub fn bs9(&mut self) -> BS9_W {
                BS9_W { w: self }
            }
            ///Bit 10 - Set bit 10
            #[inline(always)]
            pub fn bs10(&mut self) -> BS10_W {
                BS10_W { w: self }
            }
            ///Bit 11 - Set bit 11
            #[inline(always)]
            pub fn bs11(&mut self) -> BS11_W {
                BS11_W { w: self }
            }
            ///Bit 12 - Set bit 12
            #[inline(always)]
            pub fn bs12(&mut self) -> BS12_W {
                BS12_W { w: self }
            }
            ///Bit 13 - Set bit 13
            #[inline(always)]
            pub fn bs13(&mut self) -> BS13_W {
                BS13_W { w: self }
            }
            ///Bit 14 - Set bit 14
            #[inline(always)]
            pub fn bs14(&mut self) -> BS14_W {
                BS14_W { w: self }
            }
            ///Bit 15 - Set bit 15
            #[inline(always)]
            pub fn bs15(&mut self) -> BS15_W {
                BS15_W { w: self }
            }
            ///Bit 16 - Reset bit 0
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            ///Bit 17 - Reset bit 1
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            ///Bit 18 - Reset bit 2
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            ///Bit 19 - Reset bit 3
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            ///Bit 20 - Reset bit 4
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            ///Bit 21 - Reset bit 5
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            ///Bit 22 - Reset bit 6
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            ///Bit 23 - Reset bit 7
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            ///Bit 24 - Reset bit 8
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            ///Bit 25 - Reset bit 9
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            ///Bit 26 - Reset bit 10
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            ///Bit 27 - Reset bit 11
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            ///Bit 28 - Reset bit 12
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            ///Bit 29 - Reset bit 13
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            ///Bit 30 - Reset bit 14
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            ///Bit 31 - Reset bit 15
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit set/reset register (GPIOn_BSRR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bsrr](index.html) module
        pub struct BSRR_SPEC;
        impl crate::RegisterSpec for BSRR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [bsrr::W](W) writer structure
        impl crate::Writable for BSRR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BSRR to value 0
        impl crate::Resettable for BSRR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BRR register accessor: an alias for `Reg<BRR_SPEC>`
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Port bit reset register (GPIOn_BRR)
    pub mod brr {
        ///Register `BRR` writer
        pub struct W(crate::W<BRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BRR_SPEC>> for W {
            fn from(writer: crate::W<BRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Reset bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BR0_AW {
            ///0: No action on the corresponding ODx bit
            NOACTION = 0,
            ///1: Reset the ODx bit
            RESET = 1,
        }
        impl From<BR0_AW> for bool {
            #[inline(always)]
            fn from(variant: BR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BR0` writer - Reset bit 0
        pub struct BR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR0_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR0_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR0_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Reset bit 1
        pub type BR1_AW = BR0_AW;
        ///Field `BR1` writer - Reset bit 1
        pub struct BR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR1_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR1_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Reset bit 1
        pub type BR2_AW = BR0_AW;
        ///Field `BR2` writer - Reset bit 1
        pub struct BR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR2_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR2_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Reset bit 3
        pub type BR3_AW = BR0_AW;
        ///Field `BR3` writer - Reset bit 3
        pub struct BR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR3_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR3_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Reset bit 4
        pub type BR4_AW = BR0_AW;
        ///Field `BR4` writer - Reset bit 4
        pub struct BR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR4_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR4_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Reset bit 5
        pub type BR5_AW = BR0_AW;
        ///Field `BR5` writer - Reset bit 5
        pub struct BR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR5_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR5_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Reset bit 6
        pub type BR6_AW = BR0_AW;
        ///Field `BR6` writer - Reset bit 6
        pub struct BR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR6_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR6_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Reset bit 7
        pub type BR7_AW = BR0_AW;
        ///Field `BR7` writer - Reset bit 7
        pub struct BR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR7_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR7_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Reset bit 8
        pub type BR8_AW = BR0_AW;
        ///Field `BR8` writer - Reset bit 8
        pub struct BR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR8_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR8_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR8_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Reset bit 9
        pub type BR9_AW = BR0_AW;
        ///Field `BR9` writer - Reset bit 9
        pub struct BR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR9_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR9_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR9_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Reset bit 10
        pub type BR10_AW = BR0_AW;
        ///Field `BR10` writer - Reset bit 10
        pub struct BR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR10_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR10_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR10_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Reset bit 11
        pub type BR11_AW = BR0_AW;
        ///Field `BR11` writer - Reset bit 11
        pub struct BR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR11_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR11_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR11_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Reset bit 12
        pub type BR12_AW = BR0_AW;
        ///Field `BR12` writer - Reset bit 12
        pub struct BR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR12_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR12_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR12_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Reset bit 13
        pub type BR13_AW = BR0_AW;
        ///Field `BR13` writer - Reset bit 13
        pub struct BR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR13_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR13_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR13_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Reset bit 14
        pub type BR14_AW = BR0_AW;
        ///Field `BR14` writer - Reset bit 14
        pub struct BR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR14_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR14_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR14_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Reset bit 15
        pub type BR15_AW = BR0_AW;
        ///Field `BR15` writer - Reset bit 15
        pub struct BR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR15_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action on the corresponding ODx bit
            #[inline(always)]
            pub fn no_action(self) -> &'a mut W {
                self.variant(BR15_AW::NOACTION)
            }
            ///Reset the ODx bit
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(BR15_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        impl W {
            ///Bit 0 - Reset bit 0
            #[inline(always)]
            pub fn br0(&mut self) -> BR0_W {
                BR0_W { w: self }
            }
            ///Bit 1 - Reset bit 1
            #[inline(always)]
            pub fn br1(&mut self) -> BR1_W {
                BR1_W { w: self }
            }
            ///Bit 2 - Reset bit 1
            #[inline(always)]
            pub fn br2(&mut self) -> BR2_W {
                BR2_W { w: self }
            }
            ///Bit 3 - Reset bit 3
            #[inline(always)]
            pub fn br3(&mut self) -> BR3_W {
                BR3_W { w: self }
            }
            ///Bit 4 - Reset bit 4
            #[inline(always)]
            pub fn br4(&mut self) -> BR4_W {
                BR4_W { w: self }
            }
            ///Bit 5 - Reset bit 5
            #[inline(always)]
            pub fn br5(&mut self) -> BR5_W {
                BR5_W { w: self }
            }
            ///Bit 6 - Reset bit 6
            #[inline(always)]
            pub fn br6(&mut self) -> BR6_W {
                BR6_W { w: self }
            }
            ///Bit 7 - Reset bit 7
            #[inline(always)]
            pub fn br7(&mut self) -> BR7_W {
                BR7_W { w: self }
            }
            ///Bit 8 - Reset bit 8
            #[inline(always)]
            pub fn br8(&mut self) -> BR8_W {
                BR8_W { w: self }
            }
            ///Bit 9 - Reset bit 9
            #[inline(always)]
            pub fn br9(&mut self) -> BR9_W {
                BR9_W { w: self }
            }
            ///Bit 10 - Reset bit 10
            #[inline(always)]
            pub fn br10(&mut self) -> BR10_W {
                BR10_W { w: self }
            }
            ///Bit 11 - Reset bit 11
            #[inline(always)]
            pub fn br11(&mut self) -> BR11_W {
                BR11_W { w: self }
            }
            ///Bit 12 - Reset bit 12
            #[inline(always)]
            pub fn br12(&mut self) -> BR12_W {
                BR12_W { w: self }
            }
            ///Bit 13 - Reset bit 13
            #[inline(always)]
            pub fn br13(&mut self) -> BR13_W {
                BR13_W { w: self }
            }
            ///Bit 14 - Reset bit 14
            #[inline(always)]
            pub fn br14(&mut self) -> BR14_W {
                BR14_W { w: self }
            }
            ///Bit 15 - Reset bit 15
            #[inline(always)]
            pub fn br15(&mut self) -> BR15_W {
                BR15_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port bit reset register (GPIOn_BRR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [brr](index.html) module
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [brr::W](W) writer structure
        impl crate::Writable for BRR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///LCKR register accessor: an alias for `Reg<LCKR_SPEC>`
    pub type LCKR = crate::Reg<lckr::LCKR_SPEC>;
    ///Port configuration lock register
    pub mod lckr {
        ///Register `LCKR` reader
        pub struct R(crate::R<LCKR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<LCKR_SPEC>> for R {
            fn from(reader: crate::R<LCKR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LCKR` writer
        pub struct W(crate::W<LCKR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LCKR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<LCKR_SPEC>> for W {
            fn from(writer: crate::W<LCKR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Port A Lock bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK0_A {
            ///0: Port configuration not locked
            UNLOCKED = 0,
            ///1: Port configuration locked
            LOCKED = 1,
        }
        impl From<LCK0_A> for bool {
            #[inline(always)]
            fn from(variant: LCK0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LCK0` reader - Port A Lock bit 0
        pub struct LCK0_R(crate::FieldReader<bool, LCK0_A>);
        impl LCK0_R {
            pub(crate) fn new(bits: bool) -> Self {
                LCK0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LCK0_A {
                match self.bits {
                    false => LCK0_A::UNLOCKED,
                    true => LCK0_A::LOCKED,
                }
            }
            ///Checks if the value of the field is `UNLOCKED`
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                **self == LCK0_A::UNLOCKED
            }
            ///Checks if the value of the field is `LOCKED`
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                **self == LCK0_A::LOCKED
            }
        }
        impl core::ops::Deref for LCK0_R {
            type Target = crate::FieldReader<bool, LCK0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LCK0` writer - Port A Lock bit 0
        pub struct LCK0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK0_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK0_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Port A Lock bit 1
        pub type LCK1_A = LCK0_A;
        ///Field `LCK1` reader - Port A Lock bit 1
        pub type LCK1_R = LCK0_R;
        ///Field `LCK1` writer - Port A Lock bit 1
        pub struct LCK1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK1_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK1_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Port A Lock bit 2
        pub type LCK2_A = LCK0_A;
        ///Field `LCK2` reader - Port A Lock bit 2
        pub type LCK2_R = LCK0_R;
        ///Field `LCK2` writer - Port A Lock bit 2
        pub struct LCK2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK2_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK2_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Port A Lock bit 3
        pub type LCK3_A = LCK0_A;
        ///Field `LCK3` reader - Port A Lock bit 3
        pub type LCK3_R = LCK0_R;
        ///Field `LCK3` writer - Port A Lock bit 3
        pub struct LCK3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK3_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK3_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Port A Lock bit 4
        pub type LCK4_A = LCK0_A;
        ///Field `LCK4` reader - Port A Lock bit 4
        pub type LCK4_R = LCK0_R;
        ///Field `LCK4` writer - Port A Lock bit 4
        pub struct LCK4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK4_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK4_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Port A Lock bit 5
        pub type LCK5_A = LCK0_A;
        ///Field `LCK5` reader - Port A Lock bit 5
        pub type LCK5_R = LCK0_R;
        ///Field `LCK5` writer - Port A Lock bit 5
        pub struct LCK5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK5_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK5_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Port A Lock bit 6
        pub type LCK6_A = LCK0_A;
        ///Field `LCK6` reader - Port A Lock bit 6
        pub type LCK6_R = LCK0_R;
        ///Field `LCK6` writer - Port A Lock bit 6
        pub struct LCK6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK6_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK6_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Port A Lock bit 7
        pub type LCK7_A = LCK0_A;
        ///Field `LCK7` reader - Port A Lock bit 7
        pub type LCK7_R = LCK0_R;
        ///Field `LCK7` writer - Port A Lock bit 7
        pub struct LCK7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK7_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK7_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Port A Lock bit 8
        pub type LCK8_A = LCK0_A;
        ///Field `LCK8` reader - Port A Lock bit 8
        pub type LCK8_R = LCK0_R;
        ///Field `LCK8` writer - Port A Lock bit 8
        pub struct LCK8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK8_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK8_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Port A Lock bit 9
        pub type LCK9_A = LCK0_A;
        ///Field `LCK9` reader - Port A Lock bit 9
        pub type LCK9_R = LCK0_R;
        ///Field `LCK9` writer - Port A Lock bit 9
        pub struct LCK9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK9_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK9_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Port A Lock bit 10
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCK10_A {
            ///0: Port configuration not locked
            UNLOCKED = 0,
            ///1: Port configuration locked
            LOCKED = 1,
        }
        impl From<LCK10_A> for bool {
            #[inline(always)]
            fn from(variant: LCK10_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LCK10` reader - Port A Lock bit 10
        pub struct LCK10_R(crate::FieldReader<bool, LCK10_A>);
        impl LCK10_R {
            pub(crate) fn new(bits: bool) -> Self {
                LCK10_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LCK10_A {
                match self.bits {
                    false => LCK10_A::UNLOCKED,
                    true => LCK10_A::LOCKED,
                }
            }
            ///Checks if the value of the field is `UNLOCKED`
            #[inline(always)]
            pub fn is_unlocked(&self) -> bool {
                **self == LCK10_A::UNLOCKED
            }
            ///Checks if the value of the field is `LOCKED`
            #[inline(always)]
            pub fn is_locked(&self) -> bool {
                **self == LCK10_A::LOCKED
            }
        }
        impl core::ops::Deref for LCK10_R {
            type Target = crate::FieldReader<bool, LCK10_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LCK10` writer - Port A Lock bit 10
        pub struct LCK10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK10_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK10_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Port A Lock bit 11
        pub type LCK11_A = LCK10_A;
        ///Field `LCK11` reader - Port A Lock bit 11
        pub type LCK11_R = LCK10_R;
        ///Field `LCK11` writer - Port A Lock bit 11
        pub struct LCK11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK11_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK11_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Port A Lock bit 12
        pub type LCK12_A = LCK10_A;
        ///Field `LCK12` reader - Port A Lock bit 12
        pub type LCK12_R = LCK10_R;
        ///Field `LCK12` writer - Port A Lock bit 12
        pub struct LCK12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK12_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK12_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Port A Lock bit 13
        pub type LCK13_A = LCK10_A;
        ///Field `LCK13` reader - Port A Lock bit 13
        pub type LCK13_R = LCK10_R;
        ///Field `LCK13` writer - Port A Lock bit 13
        pub struct LCK13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK13_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK13_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Port A Lock bit 14
        pub type LCK14_A = LCK10_A;
        ///Field `LCK14` reader - Port A Lock bit 14
        pub type LCK14_R = LCK10_R;
        ///Field `LCK14` writer - Port A Lock bit 14
        pub struct LCK14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK14_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK14_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Port A Lock bit 15
        pub type LCK15_A = LCK10_A;
        ///Field `LCK15` reader - Port A Lock bit 15
        pub type LCK15_R = LCK10_R;
        ///Field `LCK15` writer - Port A Lock bit 15
        pub struct LCK15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCK15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCK15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration not locked
            #[inline(always)]
            pub fn unlocked(self) -> &'a mut W {
                self.variant(LCK15_A::UNLOCKED)
            }
            ///Port configuration locked
            #[inline(always)]
            pub fn locked(self) -> &'a mut W {
                self.variant(LCK15_A::LOCKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Lock key
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LCKK_A {
            ///0: Port configuration lock key not active
            NOTACTIVE = 0,
            ///1: Port configuration lock key active
            ACTIVE = 1,
        }
        impl From<LCKK_A> for bool {
            #[inline(always)]
            fn from(variant: LCKK_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LCKK` reader - Lock key
        pub struct LCKK_R(crate::FieldReader<bool, LCKK_A>);
        impl LCKK_R {
            pub(crate) fn new(bits: bool) -> Self {
                LCKK_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LCKK_A {
                match self.bits {
                    false => LCKK_A::NOTACTIVE,
                    true => LCKK_A::ACTIVE,
                }
            }
            ///Checks if the value of the field is `NOTACTIVE`
            #[inline(always)]
            pub fn is_not_active(&self) -> bool {
                **self == LCKK_A::NOTACTIVE
            }
            ///Checks if the value of the field is `ACTIVE`
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                **self == LCKK_A::ACTIVE
            }
        }
        impl core::ops::Deref for LCKK_R {
            type Target = crate::FieldReader<bool, LCKK_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LCKK` writer - Lock key
        pub struct LCKK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LCKK_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LCKK_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Port configuration lock key not active
            #[inline(always)]
            pub fn not_active(self) -> &'a mut W {
                self.variant(LCKK_A::NOTACTIVE)
            }
            ///Port configuration lock key active
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(LCKK_A::ACTIVE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            pub fn lck0(&self) -> LCK0_R {
                LCK0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            pub fn lck1(&self) -> LCK1_R {
                LCK1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            pub fn lck2(&self) -> LCK2_R {
                LCK2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            pub fn lck3(&self) -> LCK3_R {
                LCK3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            pub fn lck4(&self) -> LCK4_R {
                LCK4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            pub fn lck5(&self) -> LCK5_R {
                LCK5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            pub fn lck6(&self) -> LCK6_R {
                LCK6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            pub fn lck7(&self) -> LCK7_R {
                LCK7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            pub fn lck8(&self) -> LCK8_R {
                LCK8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            pub fn lck9(&self) -> LCK9_R {
                LCK9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            pub fn lck10(&self) -> LCK10_R {
                LCK10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            pub fn lck11(&self) -> LCK11_R {
                LCK11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            pub fn lck12(&self) -> LCK12_R {
                LCK12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            pub fn lck13(&self) -> LCK13_R {
                LCK13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            pub fn lck14(&self) -> LCK14_R {
                LCK14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            pub fn lck15(&self) -> LCK15_R {
                LCK15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            pub fn lckk(&self) -> LCKK_R {
                LCKK_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Port A Lock bit 0
            #[inline(always)]
            pub fn lck0(&mut self) -> LCK0_W {
                LCK0_W { w: self }
            }
            ///Bit 1 - Port A Lock bit 1
            #[inline(always)]
            pub fn lck1(&mut self) -> LCK1_W {
                LCK1_W { w: self }
            }
            ///Bit 2 - Port A Lock bit 2
            #[inline(always)]
            pub fn lck2(&mut self) -> LCK2_W {
                LCK2_W { w: self }
            }
            ///Bit 3 - Port A Lock bit 3
            #[inline(always)]
            pub fn lck3(&mut self) -> LCK3_W {
                LCK3_W { w: self }
            }
            ///Bit 4 - Port A Lock bit 4
            #[inline(always)]
            pub fn lck4(&mut self) -> LCK4_W {
                LCK4_W { w: self }
            }
            ///Bit 5 - Port A Lock bit 5
            #[inline(always)]
            pub fn lck5(&mut self) -> LCK5_W {
                LCK5_W { w: self }
            }
            ///Bit 6 - Port A Lock bit 6
            #[inline(always)]
            pub fn lck6(&mut self) -> LCK6_W {
                LCK6_W { w: self }
            }
            ///Bit 7 - Port A Lock bit 7
            #[inline(always)]
            pub fn lck7(&mut self) -> LCK7_W {
                LCK7_W { w: self }
            }
            ///Bit 8 - Port A Lock bit 8
            #[inline(always)]
            pub fn lck8(&mut self) -> LCK8_W {
                LCK8_W { w: self }
            }
            ///Bit 9 - Port A Lock bit 9
            #[inline(always)]
            pub fn lck9(&mut self) -> LCK9_W {
                LCK9_W { w: self }
            }
            ///Bit 10 - Port A Lock bit 10
            #[inline(always)]
            pub fn lck10(&mut self) -> LCK10_W {
                LCK10_W { w: self }
            }
            ///Bit 11 - Port A Lock bit 11
            #[inline(always)]
            pub fn lck11(&mut self) -> LCK11_W {
                LCK11_W { w: self }
            }
            ///Bit 12 - Port A Lock bit 12
            #[inline(always)]
            pub fn lck12(&mut self) -> LCK12_W {
                LCK12_W { w: self }
            }
            ///Bit 13 - Port A Lock bit 13
            #[inline(always)]
            pub fn lck13(&mut self) -> LCK13_W {
                LCK13_W { w: self }
            }
            ///Bit 14 - Port A Lock bit 14
            #[inline(always)]
            pub fn lck14(&mut self) -> LCK14_W {
                LCK14_W { w: self }
            }
            ///Bit 15 - Port A Lock bit 15
            #[inline(always)]
            pub fn lck15(&mut self) -> LCK15_W {
                LCK15_W { w: self }
            }
            ///Bit 16 - Lock key
            #[inline(always)]
            pub fn lckk(&mut self) -> LCKK_W {
                LCKK_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Port configuration lock register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [lckr](index.html) module
        pub struct LCKR_SPEC;
        impl crate::RegisterSpec for LCKR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [lckr::R](R) reader structure
        impl crate::Readable for LCKR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [lckr::W](W) writer structure
        impl crate::Writable for LCKR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets LCKR to value 0
        impl crate::Resettable for LCKR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose I/O
pub struct GPIOB {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOB {}
impl GPIOB {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_0c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOB {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOB {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOB").finish()
    }
}
///General purpose I/O
pub struct GPIOC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOC {}
impl GPIOC {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOC {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOC").finish()
    }
}
///General purpose I/O
pub struct GPIOD {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOD {}
impl GPIOD {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOD {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOD {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOD").finish()
    }
}
///General purpose I/O
pub struct GPIOE {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOE {}
impl GPIOE {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOE {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOE {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOE").finish()
    }
}
///General purpose I/O
pub struct GPIOF {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOF {}
impl GPIOF {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_1c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOF {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOF {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOF").finish()
    }
}
///General purpose I/O
pub struct GPIOG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for GPIOG {}
impl GPIOG {
    ///Pointer to the register block
    pub const PTR: *const gpioa::RegisterBlock = 0x4001_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const gpioa::RegisterBlock {
        Self::PTR
    }
}
impl Deref for GPIOG {
    type Target = gpioa::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for GPIOG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("GPIOG").finish()
    }
}
///Alternate function I/O
pub struct AFIO {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for AFIO {}
impl AFIO {
    ///Pointer to the register block
    pub const PTR: *const afio::RegisterBlock = 0x4001_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const afio::RegisterBlock {
        Self::PTR
    }
}
impl Deref for AFIO {
    type Target = afio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for AFIO {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("AFIO").finish()
    }
}
///Alternate function I/O
pub mod afio {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Event Control Register (AFIO_EVCR)
        pub evcr: crate::Reg<evcr::EVCR_SPEC>,
        ///0x04 - AF remap and debug I/O configuration register (AFIO_MAPR)
        pub mapr: crate::Reg<mapr::MAPR_SPEC>,
        ///0x08 - External interrupt configuration register 1 (AFIO_EXTICR1)
        pub exticr1: crate::Reg<exticr1::EXTICR1_SPEC>,
        ///0x0c - External interrupt configuration register 2 (AFIO_EXTICR2)
        pub exticr2: crate::Reg<exticr2::EXTICR2_SPEC>,
        ///0x10 - External interrupt configuration register 3 (AFIO_EXTICR3)
        pub exticr3: crate::Reg<exticr3::EXTICR3_SPEC>,
        ///0x14 - External interrupt configuration register 4 (AFIO_EXTICR4)
        pub exticr4: crate::Reg<exticr4::EXTICR4_SPEC>,
        _reserved6: [u8; 4usize],
        ///0x1c - AF remap and debug I/O configuration register
        pub mapr2: crate::Reg<mapr2::MAPR2_SPEC>,
    }
    ///EVCR register accessor: an alias for `Reg<EVCR_SPEC>`
    pub type EVCR = crate::Reg<evcr::EVCR_SPEC>;
    ///Event Control Register (AFIO_EVCR)
    pub mod evcr {
        ///Register `EVCR` reader
        pub struct R(crate::R<EVCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EVCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EVCR_SPEC>> for R {
            fn from(reader: crate::R<EVCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EVCR` writer
        pub struct W(crate::W<EVCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EVCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EVCR_SPEC>> for W {
            fn from(writer: crate::W<EVCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PIN` reader - Pin selection
        pub struct PIN_R(crate::FieldReader<u8, u8>);
        impl PIN_R {
            pub(crate) fn new(bits: u8) -> Self {
                PIN_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PIN_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PIN` writer - Pin selection
        pub struct PIN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PIN_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `PORT` reader - Port selection
        pub struct PORT_R(crate::FieldReader<u8, u8>);
        impl PORT_R {
            pub(crate) fn new(bits: u8) -> Self {
                PORT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PORT_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PORT` writer - Port selection
        pub struct PORT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PORT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `EVOE` reader - Event Output Enable
        pub struct EVOE_R(crate::FieldReader<bool, bool>);
        impl EVOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                EVOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EVOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EVOE` writer - Event Output Enable
        pub struct EVOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EVOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            pub fn pin(&self) -> PIN_R {
                PIN_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            pub fn port(&self) -> PORT_R {
                PORT_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            pub fn evoe(&self) -> EVOE_R {
                EVOE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Pin selection
            #[inline(always)]
            pub fn pin(&mut self) -> PIN_W {
                PIN_W { w: self }
            }
            ///Bits 4:6 - Port selection
            #[inline(always)]
            pub fn port(&mut self) -> PORT_W {
                PORT_W { w: self }
            }
            ///Bit 7 - Event Output Enable
            #[inline(always)]
            pub fn evoe(&mut self) -> EVOE_W {
                EVOE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Event Control Register (AFIO_EVCR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [evcr](index.html) module
        pub struct EVCR_SPEC;
        impl crate::RegisterSpec for EVCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [evcr::R](R) reader structure
        impl crate::Readable for EVCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [evcr::W](W) writer structure
        impl crate::Writable for EVCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EVCR to value 0
        impl crate::Resettable for EVCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///MAPR register accessor: an alias for `Reg<MAPR_SPEC>`
    pub type MAPR = crate::Reg<mapr::MAPR_SPEC>;
    ///AF remap and debug I/O configuration register (AFIO_MAPR)
    pub mod mapr {
        ///Register `MAPR` reader
        pub struct R(crate::R<MAPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MAPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<MAPR_SPEC>> for R {
            fn from(reader: crate::R<MAPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MAPR` writer
        pub struct W(crate::W<MAPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MAPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<MAPR_SPEC>> for W {
            fn from(writer: crate::W<MAPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SPI1_REMAP` reader - SPI1 remapping
        pub struct SPI1_REMAP_R(crate::FieldReader<bool, bool>);
        impl SPI1_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                SPI1_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SPI1_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SPI1_REMAP` writer - SPI1 remapping
        pub struct SPI1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPI1_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `I2C1_REMAP` reader - I2C1 remapping
        pub struct I2C1_REMAP_R(crate::FieldReader<bool, bool>);
        impl I2C1_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                I2C1_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for I2C1_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `I2C1_REMAP` writer - I2C1 remapping
        pub struct I2C1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> I2C1_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `USART1_REMAP` reader - USART1 remapping
        pub struct USART1_REMAP_R(crate::FieldReader<bool, bool>);
        impl USART1_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                USART1_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for USART1_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `USART1_REMAP` writer - USART1 remapping
        pub struct USART1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART1_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `USART2_REMAP` reader - USART2 remapping
        pub struct USART2_REMAP_R(crate::FieldReader<bool, bool>);
        impl USART2_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                USART2_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for USART2_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `USART2_REMAP` writer - USART2 remapping
        pub struct USART2_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART2_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `USART3_REMAP` reader - USART3 remapping
        pub struct USART3_REMAP_R(crate::FieldReader<u8, u8>);
        impl USART3_REMAP_R {
            pub(crate) fn new(bits: u8) -> Self {
                USART3_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for USART3_REMAP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `USART3_REMAP` writer - USART3 remapping
        pub struct USART3_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> USART3_REMAP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 4)) | ((value as u32 & 0x03) << 4);
                self.w
            }
        }
        ///Field `TIM1_REMAP` reader - TIM1 remapping
        pub struct TIM1_REMAP_R(crate::FieldReader<u8, u8>);
        impl TIM1_REMAP_R {
            pub(crate) fn new(bits: u8) -> Self {
                TIM1_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM1_REMAP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM1_REMAP` writer - TIM1 remapping
        pub struct TIM1_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1_REMAP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | ((value as u32 & 0x03) << 6);
                self.w
            }
        }
        ///Field `TIM2_REMAP` reader - TIM2 remapping
        pub struct TIM2_REMAP_R(crate::FieldReader<u8, u8>);
        impl TIM2_REMAP_R {
            pub(crate) fn new(bits: u8) -> Self {
                TIM2_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM2_REMAP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM2_REMAP` writer - TIM2 remapping
        pub struct TIM2_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM2_REMAP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `TIM3_REMAP` reader - TIM3 remapping
        pub struct TIM3_REMAP_R(crate::FieldReader<u8, u8>);
        impl TIM3_REMAP_R {
            pub(crate) fn new(bits: u8) -> Self {
                TIM3_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM3_REMAP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM3_REMAP` writer - TIM3 remapping
        pub struct TIM3_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM3_REMAP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Field `TIM4_REMAP` reader - TIM4 remapping
        pub struct TIM4_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM4_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM4_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM4_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM4_REMAP` writer - TIM4 remapping
        pub struct TIM4_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM4_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `PD01_REMAP` reader - Port D0/Port D1 mapping on OSCIN/OSCOUT
        pub struct PD01_REMAP_R(crate::FieldReader<bool, bool>);
        impl PD01_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                PD01_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PD01_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PD01_REMAP` writer - Port D0/Port D1 mapping on OSCIN/OSCOUT
        pub struct PD01_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PD01_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `TIM5CH4_IREMAP` reader - Set and cleared by software
        pub struct TIM5CH4_IREMAP_R(crate::FieldReader<bool, bool>);
        impl TIM5CH4_IREMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM5CH4_IREMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM5CH4_IREMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM5CH4_IREMAP` writer - Set and cleared by software
        pub struct TIM5CH4_IREMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM5CH4_IREMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Field `SWJ_CFG` writer - Serial wire JTAG configuration
        pub struct SWJ_CFG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWJ_CFG_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | ((value as u32 & 0x07) << 24);
                self.w
            }
        }
        impl R {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            pub fn spi1_remap(&self) -> SPI1_REMAP_R {
                SPI1_REMAP_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1_remap(&self) -> I2C1_REMAP_R {
                I2C1_REMAP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            pub fn usart1_remap(&self) -> USART1_REMAP_R {
                USART1_REMAP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            pub fn usart2_remap(&self) -> USART2_REMAP_R {
                USART2_REMAP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            pub fn usart3_remap(&self) -> USART3_REMAP_R {
                USART3_REMAP_R::new(((self.bits >> 4) & 0x03) as u8)
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            pub fn tim1_remap(&self) -> TIM1_REMAP_R {
                TIM1_REMAP_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            pub fn tim2_remap(&self) -> TIM2_REMAP_R {
                TIM2_REMAP_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 10:11 - TIM3 remapping
            #[inline(always)]
            pub fn tim3_remap(&self) -> TIM3_REMAP_R {
                TIM3_REMAP_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bit 12 - TIM4 remapping
            #[inline(always)]
            pub fn tim4_remap(&self) -> TIM4_REMAP_R {
                TIM4_REMAP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT
            #[inline(always)]
            pub fn pd01_remap(&self) -> PD01_REMAP_R {
                PD01_REMAP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Set and cleared by software
            #[inline(always)]
            pub fn tim5ch4_iremap(&self) -> TIM5CH4_IREMAP_R {
                TIM5CH4_IREMAP_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - SPI1 remapping
            #[inline(always)]
            pub fn spi1_remap(&mut self) -> SPI1_REMAP_W {
                SPI1_REMAP_W { w: self }
            }
            ///Bit 1 - I2C1 remapping
            #[inline(always)]
            pub fn i2c1_remap(&mut self) -> I2C1_REMAP_W {
                I2C1_REMAP_W { w: self }
            }
            ///Bit 2 - USART1 remapping
            #[inline(always)]
            pub fn usart1_remap(&mut self) -> USART1_REMAP_W {
                USART1_REMAP_W { w: self }
            }
            ///Bit 3 - USART2 remapping
            #[inline(always)]
            pub fn usart2_remap(&mut self) -> USART2_REMAP_W {
                USART2_REMAP_W { w: self }
            }
            ///Bits 4:5 - USART3 remapping
            #[inline(always)]
            pub fn usart3_remap(&mut self) -> USART3_REMAP_W {
                USART3_REMAP_W { w: self }
            }
            ///Bits 6:7 - TIM1 remapping
            #[inline(always)]
            pub fn tim1_remap(&mut self) -> TIM1_REMAP_W {
                TIM1_REMAP_W { w: self }
            }
            ///Bits 8:9 - TIM2 remapping
            #[inline(always)]
            pub fn tim2_remap(&mut self) -> TIM2_REMAP_W {
                TIM2_REMAP_W { w: self }
            }
            ///Bits 10:11 - TIM3 remapping
            #[inline(always)]
            pub fn tim3_remap(&mut self) -> TIM3_REMAP_W {
                TIM3_REMAP_W { w: self }
            }
            ///Bit 12 - TIM4 remapping
            #[inline(always)]
            pub fn tim4_remap(&mut self) -> TIM4_REMAP_W {
                TIM4_REMAP_W { w: self }
            }
            ///Bit 15 - Port D0/Port D1 mapping on OSCIN/OSCOUT
            #[inline(always)]
            pub fn pd01_remap(&mut self) -> PD01_REMAP_W {
                PD01_REMAP_W { w: self }
            }
            ///Bit 16 - Set and cleared by software
            #[inline(always)]
            pub fn tim5ch4_iremap(&mut self) -> TIM5CH4_IREMAP_W {
                TIM5CH4_IREMAP_W { w: self }
            }
            ///Bits 24:26 - Serial wire JTAG configuration
            #[inline(always)]
            pub fn swj_cfg(&mut self) -> SWJ_CFG_W {
                SWJ_CFG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AF remap and debug I/O configuration register (AFIO_MAPR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [mapr](index.html) module
        pub struct MAPR_SPEC;
        impl crate::RegisterSpec for MAPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [mapr::R](R) reader structure
        impl crate::Readable for MAPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [mapr::W](W) writer structure
        impl crate::Writable for MAPR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets MAPR to value 0
        impl crate::Resettable for MAPR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EXTICR1 register accessor: an alias for `Reg<EXTICR1_SPEC>`
    pub type EXTICR1 = crate::Reg<exticr1::EXTICR1_SPEC>;
    ///External interrupt configuration register 1 (AFIO_EXTICR1)
    pub mod exticr1 {
        ///Register `EXTICR1` reader
        pub struct R(crate::R<EXTICR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EXTICR1_SPEC>> for R {
            fn from(reader: crate::R<EXTICR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR1` writer
        pub struct W(crate::W<EXTICR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EXTICR1_SPEC>> for W {
            fn from(writer: crate::W<EXTICR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI0` reader - EXTI0 configuration
        pub struct EXTI0_R(crate::FieldReader<u8, u8>);
        impl EXTI0_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI0_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI0_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI0` writer - EXTI0 configuration
        pub struct EXTI0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI0_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `EXTI1` reader - EXTI1 configuration
        pub struct EXTI1_R(crate::FieldReader<u8, u8>);
        impl EXTI1_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI1_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI1` writer - EXTI1 configuration
        pub struct EXTI1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `EXTI2` reader - EXTI2 configuration
        pub struct EXTI2_R(crate::FieldReader<u8, u8>);
        impl EXTI2_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI2_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI2` writer - EXTI2 configuration
        pub struct EXTI2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Field `EXTI3` reader - EXTI3 configuration
        pub struct EXTI3_R(crate::FieldReader<u8, u8>);
        impl EXTI3_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI3_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI3_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI3` writer - EXTI3 configuration
        pub struct EXTI3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI3_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            pub fn exti0(&self) -> EXTI0_R {
                EXTI0_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            pub fn exti1(&self) -> EXTI1_R {
                EXTI1_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            pub fn exti2(&self) -> EXTI2_R {
                EXTI2_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            pub fn exti3(&self) -> EXTI3_R {
                EXTI3_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI0 configuration
            #[inline(always)]
            pub fn exti0(&mut self) -> EXTI0_W {
                EXTI0_W { w: self }
            }
            ///Bits 4:7 - EXTI1 configuration
            #[inline(always)]
            pub fn exti1(&mut self) -> EXTI1_W {
                EXTI1_W { w: self }
            }
            ///Bits 8:11 - EXTI2 configuration
            #[inline(always)]
            pub fn exti2(&mut self) -> EXTI2_W {
                EXTI2_W { w: self }
            }
            ///Bits 12:15 - EXTI3 configuration
            #[inline(always)]
            pub fn exti3(&mut self) -> EXTI3_W {
                EXTI3_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 1 (AFIO_EXTICR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr1](index.html) module
        pub struct EXTICR1_SPEC;
        impl crate::RegisterSpec for EXTICR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr1::R](R) reader structure
        impl crate::Readable for EXTICR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr1::W](W) writer structure
        impl crate::Writable for EXTICR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EXTICR1 to value 0
        impl crate::Resettable for EXTICR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EXTICR2 register accessor: an alias for `Reg<EXTICR2_SPEC>`
    pub type EXTICR2 = crate::Reg<exticr2::EXTICR2_SPEC>;
    ///External interrupt configuration register 2 (AFIO_EXTICR2)
    pub mod exticr2 {
        ///Register `EXTICR2` reader
        pub struct R(crate::R<EXTICR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EXTICR2_SPEC>> for R {
            fn from(reader: crate::R<EXTICR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR2` writer
        pub struct W(crate::W<EXTICR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EXTICR2_SPEC>> for W {
            fn from(writer: crate::W<EXTICR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI4` reader - EXTI4 configuration
        pub struct EXTI4_R(crate::FieldReader<u8, u8>);
        impl EXTI4_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI4_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI4_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI4` writer - EXTI4 configuration
        pub struct EXTI4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI4_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `EXTI5` reader - EXTI5 configuration
        pub struct EXTI5_R(crate::FieldReader<u8, u8>);
        impl EXTI5_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI5_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI5_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI5` writer - EXTI5 configuration
        pub struct EXTI5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI5_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `EXTI6` reader - EXTI6 configuration
        pub struct EXTI6_R(crate::FieldReader<u8, u8>);
        impl EXTI6_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI6_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI6_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI6` writer - EXTI6 configuration
        pub struct EXTI6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI6_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Field `EXTI7` reader - EXTI7 configuration
        pub struct EXTI7_R(crate::FieldReader<u8, u8>);
        impl EXTI7_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI7_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI7_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI7` writer - EXTI7 configuration
        pub struct EXTI7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI7_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            pub fn exti4(&self) -> EXTI4_R {
                EXTI4_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            pub fn exti5(&self) -> EXTI5_R {
                EXTI5_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            pub fn exti6(&self) -> EXTI6_R {
                EXTI6_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            pub fn exti7(&self) -> EXTI7_R {
                EXTI7_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI4 configuration
            #[inline(always)]
            pub fn exti4(&mut self) -> EXTI4_W {
                EXTI4_W { w: self }
            }
            ///Bits 4:7 - EXTI5 configuration
            #[inline(always)]
            pub fn exti5(&mut self) -> EXTI5_W {
                EXTI5_W { w: self }
            }
            ///Bits 8:11 - EXTI6 configuration
            #[inline(always)]
            pub fn exti6(&mut self) -> EXTI6_W {
                EXTI6_W { w: self }
            }
            ///Bits 12:15 - EXTI7 configuration
            #[inline(always)]
            pub fn exti7(&mut self) -> EXTI7_W {
                EXTI7_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 2 (AFIO_EXTICR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr2](index.html) module
        pub struct EXTICR2_SPEC;
        impl crate::RegisterSpec for EXTICR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr2::R](R) reader structure
        impl crate::Readable for EXTICR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr2::W](W) writer structure
        impl crate::Writable for EXTICR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EXTICR2 to value 0
        impl crate::Resettable for EXTICR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EXTICR3 register accessor: an alias for `Reg<EXTICR3_SPEC>`
    pub type EXTICR3 = crate::Reg<exticr3::EXTICR3_SPEC>;
    ///External interrupt configuration register 3 (AFIO_EXTICR3)
    pub mod exticr3 {
        ///Register `EXTICR3` reader
        pub struct R(crate::R<EXTICR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EXTICR3_SPEC>> for R {
            fn from(reader: crate::R<EXTICR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR3` writer
        pub struct W(crate::W<EXTICR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EXTICR3_SPEC>> for W {
            fn from(writer: crate::W<EXTICR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI8` reader - EXTI8 configuration
        pub struct EXTI8_R(crate::FieldReader<u8, u8>);
        impl EXTI8_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI8_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI8_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI8` writer - EXTI8 configuration
        pub struct EXTI8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI8_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `EXTI9` reader - EXTI9 configuration
        pub struct EXTI9_R(crate::FieldReader<u8, u8>);
        impl EXTI9_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI9_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI9_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI9` writer - EXTI9 configuration
        pub struct EXTI9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI9_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `EXTI10` reader - EXTI10 configuration
        pub struct EXTI10_R(crate::FieldReader<u8, u8>);
        impl EXTI10_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI10_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI10_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI10` writer - EXTI10 configuration
        pub struct EXTI10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI10_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Field `EXTI11` reader - EXTI11 configuration
        pub struct EXTI11_R(crate::FieldReader<u8, u8>);
        impl EXTI11_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI11_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI11_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI11` writer - EXTI11 configuration
        pub struct EXTI11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI11_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            pub fn exti8(&self) -> EXTI8_R {
                EXTI8_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            pub fn exti9(&self) -> EXTI9_R {
                EXTI9_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            pub fn exti10(&self) -> EXTI10_R {
                EXTI10_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            pub fn exti11(&self) -> EXTI11_R {
                EXTI11_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI8 configuration
            #[inline(always)]
            pub fn exti8(&mut self) -> EXTI8_W {
                EXTI8_W { w: self }
            }
            ///Bits 4:7 - EXTI9 configuration
            #[inline(always)]
            pub fn exti9(&mut self) -> EXTI9_W {
                EXTI9_W { w: self }
            }
            ///Bits 8:11 - EXTI10 configuration
            #[inline(always)]
            pub fn exti10(&mut self) -> EXTI10_W {
                EXTI10_W { w: self }
            }
            ///Bits 12:15 - EXTI11 configuration
            #[inline(always)]
            pub fn exti11(&mut self) -> EXTI11_W {
                EXTI11_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 3 (AFIO_EXTICR3)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr3](index.html) module
        pub struct EXTICR3_SPEC;
        impl crate::RegisterSpec for EXTICR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr3::R](R) reader structure
        impl crate::Readable for EXTICR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr3::W](W) writer structure
        impl crate::Writable for EXTICR3_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EXTICR3 to value 0
        impl crate::Resettable for EXTICR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EXTICR4 register accessor: an alias for `Reg<EXTICR4_SPEC>`
    pub type EXTICR4 = crate::Reg<exticr4::EXTICR4_SPEC>;
    ///External interrupt configuration register 4 (AFIO_EXTICR4)
    pub mod exticr4 {
        ///Register `EXTICR4` reader
        pub struct R(crate::R<EXTICR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EXTICR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EXTICR4_SPEC>> for R {
            fn from(reader: crate::R<EXTICR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EXTICR4` writer
        pub struct W(crate::W<EXTICR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EXTICR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EXTICR4_SPEC>> for W {
            fn from(writer: crate::W<EXTICR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EXTI12` reader - EXTI12 configuration
        pub struct EXTI12_R(crate::FieldReader<u8, u8>);
        impl EXTI12_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI12_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI12_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI12` writer - EXTI12 configuration
        pub struct EXTI12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI12_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `EXTI13` reader - EXTI13 configuration
        pub struct EXTI13_R(crate::FieldReader<u8, u8>);
        impl EXTI13_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI13_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI13_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI13` writer - EXTI13 configuration
        pub struct EXTI13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI13_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `EXTI14` reader - EXTI14 configuration
        pub struct EXTI14_R(crate::FieldReader<u8, u8>);
        impl EXTI14_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI14_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI14_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI14` writer - EXTI14 configuration
        pub struct EXTI14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI14_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Field `EXTI15` reader - EXTI15 configuration
        pub struct EXTI15_R(crate::FieldReader<u8, u8>);
        impl EXTI15_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTI15_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EXTI15_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTI15` writer - EXTI15 configuration
        pub struct EXTI15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTI15_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            pub fn exti12(&self) -> EXTI12_R {
                EXTI12_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            pub fn exti13(&self) -> EXTI13_R {
                EXTI13_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            pub fn exti14(&self) -> EXTI14_R {
                EXTI14_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            pub fn exti15(&self) -> EXTI15_R {
                EXTI15_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - EXTI12 configuration
            #[inline(always)]
            pub fn exti12(&mut self) -> EXTI12_W {
                EXTI12_W { w: self }
            }
            ///Bits 4:7 - EXTI13 configuration
            #[inline(always)]
            pub fn exti13(&mut self) -> EXTI13_W {
                EXTI13_W { w: self }
            }
            ///Bits 8:11 - EXTI14 configuration
            #[inline(always)]
            pub fn exti14(&mut self) -> EXTI14_W {
                EXTI14_W { w: self }
            }
            ///Bits 12:15 - EXTI15 configuration
            #[inline(always)]
            pub fn exti15(&mut self) -> EXTI15_W {
                EXTI15_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///External interrupt configuration register 4 (AFIO_EXTICR4)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [exticr4](index.html) module
        pub struct EXTICR4_SPEC;
        impl crate::RegisterSpec for EXTICR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [exticr4::R](R) reader structure
        impl crate::Readable for EXTICR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [exticr4::W](W) writer structure
        impl crate::Writable for EXTICR4_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EXTICR4 to value 0
        impl crate::Resettable for EXTICR4_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///MAPR2 register accessor: an alias for `Reg<MAPR2_SPEC>`
    pub type MAPR2 = crate::Reg<mapr2::MAPR2_SPEC>;
    ///AF remap and debug I/O configuration register
    pub mod mapr2 {
        ///Register `MAPR2` reader
        pub struct R(crate::R<MAPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<MAPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<MAPR2_SPEC>> for R {
            fn from(reader: crate::R<MAPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `MAPR2` writer
        pub struct W(crate::W<MAPR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<MAPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<MAPR2_SPEC>> for W {
            fn from(writer: crate::W<MAPR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TIM15_REMAP` reader - TIM15 remapping
        pub struct TIM15_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM15_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM15_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM15_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM15_REMAP` writer - TIM15 remapping
        pub struct TIM15_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM15_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `TIM16_REMAP` reader - TIM16 remapping
        pub struct TIM16_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM16_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM16_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM16_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM16_REMAP` writer - TIM16 remapping
        pub struct TIM16_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM16_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `TIM17_REMAP` reader - TIM17 remapping
        pub struct TIM17_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM17_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM17_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM17_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM17_REMAP` writer - TIM17 remapping
        pub struct TIM17_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM17_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `TIM13_REMAP` reader - TIM13 remapping
        pub struct TIM13_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM13_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM13_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM13_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM13_REMAP` writer - TIM13 remapping
        pub struct TIM13_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM13_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `TIM14_REMAP` reader - TIM14 remapping
        pub struct TIM14_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM14_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM14_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM14_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM14_REMAP` writer - TIM14 remapping
        pub struct TIM14_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM14_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `FSMC_NADV` reader - NADV connect/disconnect
        pub struct FSMC_NADV_R(crate::FieldReader<bool, bool>);
        impl FSMC_NADV_R {
            pub(crate) fn new(bits: bool) -> Self {
                FSMC_NADV_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for FSMC_NADV_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FSMC_NADV` writer - NADV connect/disconnect
        pub struct FSMC_NADV_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FSMC_NADV_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CEC_REMAP` reader - CEC remapping
        pub struct CEC_REMAP_R(crate::FieldReader<bool, bool>);
        impl CEC_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEC_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CEC_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEC_REMAP` writer - CEC remapping
        pub struct CEC_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEC_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `TIM1_DMA_REMAP` reader - TIM1 DMA remapping
        pub struct TIM1_DMA_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM1_DMA_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM1_DMA_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM1_DMA_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM1_DMA_REMAP` writer - TIM1 DMA remapping
        pub struct TIM1_DMA_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM1_DMA_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `TIM67_DAC_DMA_REMAP` reader - TIM67_DAC DMA remapping
        pub struct TIM67_DAC_DMA_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM67_DAC_DMA_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM67_DAC_DMA_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM67_DAC_DMA_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM67_DAC_DMA_REMAP` writer - TIM67_DAC DMA remapping
        pub struct TIM67_DAC_DMA_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM67_DAC_DMA_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `TIM12_REMAP` reader - TIM12 remapping
        pub struct TIM12_REMAP_R(crate::FieldReader<bool, bool>);
        impl TIM12_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIM12_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIM12_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIM12_REMAP` writer - TIM12 remapping
        pub struct TIM12_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIM12_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `MISC_REMAP` reader - Miscellaneous features remapping
        pub struct MISC_REMAP_R(crate::FieldReader<bool, bool>);
        impl MISC_REMAP_R {
            pub(crate) fn new(bits: bool) -> Self {
                MISC_REMAP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MISC_REMAP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MISC_REMAP` writer - Miscellaneous features remapping
        pub struct MISC_REMAP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MISC_REMAP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        impl R {
            ///Bit 0 - TIM15 remapping
            #[inline(always)]
            pub fn tim15_remap(&self) -> TIM15_REMAP_R {
                TIM15_REMAP_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - TIM16 remapping
            #[inline(always)]
            pub fn tim16_remap(&self) -> TIM16_REMAP_R {
                TIM16_REMAP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - TIM17 remapping
            #[inline(always)]
            pub fn tim17_remap(&self) -> TIM17_REMAP_R {
                TIM17_REMAP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 8 - TIM13 remapping
            #[inline(always)]
            pub fn tim13_remap(&self) -> TIM13_REMAP_R {
                TIM13_REMAP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - TIM14 remapping
            #[inline(always)]
            pub fn tim14_remap(&self) -> TIM14_REMAP_R {
                TIM14_REMAP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - NADV connect/disconnect
            #[inline(always)]
            pub fn fsmc_nadv(&self) -> FSMC_NADV_R {
                FSMC_NADV_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 3 - CEC remapping
            #[inline(always)]
            pub fn cec_remap(&self) -> CEC_REMAP_R {
                CEC_REMAP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - TIM1 DMA remapping
            #[inline(always)]
            pub fn tim1_dma_remap(&self) -> TIM1_DMA_REMAP_R {
                TIM1_DMA_REMAP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 11 - TIM67_DAC DMA remapping
            #[inline(always)]
            pub fn tim67_dac_dma_remap(&self) -> TIM67_DAC_DMA_REMAP_R {
                TIM67_DAC_DMA_REMAP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - TIM12 remapping
            #[inline(always)]
            pub fn tim12_remap(&self) -> TIM12_REMAP_R {
                TIM12_REMAP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Miscellaneous features remapping
            #[inline(always)]
            pub fn misc_remap(&self) -> MISC_REMAP_R {
                MISC_REMAP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - TIM15 remapping
            #[inline(always)]
            pub fn tim15_remap(&mut self) -> TIM15_REMAP_W {
                TIM15_REMAP_W { w: self }
            }
            ///Bit 1 - TIM16 remapping
            #[inline(always)]
            pub fn tim16_remap(&mut self) -> TIM16_REMAP_W {
                TIM16_REMAP_W { w: self }
            }
            ///Bit 2 - TIM17 remapping
            #[inline(always)]
            pub fn tim17_remap(&mut self) -> TIM17_REMAP_W {
                TIM17_REMAP_W { w: self }
            }
            ///Bit 8 - TIM13 remapping
            #[inline(always)]
            pub fn tim13_remap(&mut self) -> TIM13_REMAP_W {
                TIM13_REMAP_W { w: self }
            }
            ///Bit 9 - TIM14 remapping
            #[inline(always)]
            pub fn tim14_remap(&mut self) -> TIM14_REMAP_W {
                TIM14_REMAP_W { w: self }
            }
            ///Bit 10 - NADV connect/disconnect
            #[inline(always)]
            pub fn fsmc_nadv(&mut self) -> FSMC_NADV_W {
                FSMC_NADV_W { w: self }
            }
            ///Bit 3 - CEC remapping
            #[inline(always)]
            pub fn cec_remap(&mut self) -> CEC_REMAP_W {
                CEC_REMAP_W { w: self }
            }
            ///Bit 4 - TIM1 DMA remapping
            #[inline(always)]
            pub fn tim1_dma_remap(&mut self) -> TIM1_DMA_REMAP_W {
                TIM1_DMA_REMAP_W { w: self }
            }
            ///Bit 11 - TIM67_DAC DMA remapping
            #[inline(always)]
            pub fn tim67_dac_dma_remap(&mut self) -> TIM67_DAC_DMA_REMAP_W {
                TIM67_DAC_DMA_REMAP_W { w: self }
            }
            ///Bit 12 - TIM12 remapping
            #[inline(always)]
            pub fn tim12_remap(&mut self) -> TIM12_REMAP_W {
                TIM12_REMAP_W { w: self }
            }
            ///Bit 13 - Miscellaneous features remapping
            #[inline(always)]
            pub fn misc_remap(&mut self) -> MISC_REMAP_W {
                MISC_REMAP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///AF remap and debug I/O configuration register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [mapr2](index.html) module
        pub struct MAPR2_SPEC;
        impl crate::RegisterSpec for MAPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [mapr2::R](R) reader structure
        impl crate::Readable for MAPR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [mapr2::W](W) writer structure
        impl crate::Writable for MAPR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets MAPR2 to value 0
        impl crate::Resettable for MAPR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///EXTI
pub struct EXTI {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for EXTI {}
impl EXTI {
    ///Pointer to the register block
    pub const PTR: *const exti::RegisterBlock = 0x4001_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const exti::RegisterBlock {
        Self::PTR
    }
}
impl Deref for EXTI {
    type Target = exti::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for EXTI {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("EXTI").finish()
    }
}
///EXTI
pub mod exti {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Interrupt mask register (EXTI_IMR)
        pub imr: crate::Reg<imr::IMR_SPEC>,
        ///0x04 - Event mask register (EXTI_EMR)
        pub emr: crate::Reg<emr::EMR_SPEC>,
        ///0x08 - Rising Trigger selection register (EXTI_RTSR)
        pub rtsr: crate::Reg<rtsr::RTSR_SPEC>,
        ///0x0c - Falling Trigger selection register (EXTI_FTSR)
        pub ftsr: crate::Reg<ftsr::FTSR_SPEC>,
        ///0x10 - Software interrupt event register (EXTI_SWIER)
        pub swier: crate::Reg<swier::SWIER_SPEC>,
        ///0x14 - Pending register (EXTI_PR)
        pub pr: crate::Reg<pr::PR_SPEC>,
    }
    ///IMR register accessor: an alias for `Reg<IMR_SPEC>`
    pub type IMR = crate::Reg<imr::IMR_SPEC>;
    ///Interrupt mask register (EXTI_IMR)
    pub mod imr {
        ///Register `IMR` reader
        pub struct R(crate::R<IMR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IMR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<IMR_SPEC>> for R {
            fn from(reader: crate::R<IMR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IMR` writer
        pub struct W(crate::W<IMR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IMR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<IMR_SPEC>> for W {
            fn from(writer: crate::W<IMR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Interrupt Mask on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0_A {
            ///0: Interrupt request line is masked
            MASKED = 0,
            ///1: Interrupt request line is unmasked
            UNMASKED = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MR0` reader - Interrupt Mask on line 0
        pub struct MR0_R(crate::FieldReader<bool, MR0_A>);
        impl MR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                MR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::MASKED,
                    true => MR0_A::UNMASKED,
                }
            }
            ///Checks if the value of the field is `MASKED`
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                **self == MR0_A::MASKED
            }
            ///Checks if the value of the field is `UNMASKED`
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                **self == MR0_A::UNMASKED
            }
        }
        impl core::ops::Deref for MR0_R {
            type Target = crate::FieldReader<bool, MR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MR0` writer - Interrupt Mask on line 0
        pub struct MR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Interrupt Mask on line 1
        pub type MR1_A = MR0_A;
        ///Field `MR1` reader - Interrupt Mask on line 1
        pub type MR1_R = MR0_R;
        ///Field `MR1` writer - Interrupt Mask on line 1
        pub struct MR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR1_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR1_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Interrupt Mask on line 2
        pub type MR2_A = MR0_A;
        ///Field `MR2` reader - Interrupt Mask on line 2
        pub type MR2_R = MR0_R;
        ///Field `MR2` writer - Interrupt Mask on line 2
        pub struct MR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR2_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR2_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Interrupt Mask on line 3
        pub type MR3_A = MR0_A;
        ///Field `MR3` reader - Interrupt Mask on line 3
        pub type MR3_R = MR0_R;
        ///Field `MR3` writer - Interrupt Mask on line 3
        pub struct MR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR3_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR3_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Interrupt Mask on line 4
        pub type MR4_A = MR0_A;
        ///Field `MR4` reader - Interrupt Mask on line 4
        pub type MR4_R = MR0_R;
        ///Field `MR4` writer - Interrupt Mask on line 4
        pub struct MR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR4_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR4_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Interrupt Mask on line 5
        pub type MR5_A = MR0_A;
        ///Field `MR5` reader - Interrupt Mask on line 5
        pub type MR5_R = MR0_R;
        ///Field `MR5` writer - Interrupt Mask on line 5
        pub struct MR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR5_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR5_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Interrupt Mask on line 6
        pub type MR6_A = MR0_A;
        ///Field `MR6` reader - Interrupt Mask on line 6
        pub type MR6_R = MR0_R;
        ///Field `MR6` writer - Interrupt Mask on line 6
        pub struct MR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR6_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR6_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Interrupt Mask on line 7
        pub type MR7_A = MR0_A;
        ///Field `MR7` reader - Interrupt Mask on line 7
        pub type MR7_R = MR0_R;
        ///Field `MR7` writer - Interrupt Mask on line 7
        pub struct MR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR7_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR7_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Interrupt Mask on line 8
        pub type MR8_A = MR0_A;
        ///Field `MR8` reader - Interrupt Mask on line 8
        pub type MR8_R = MR0_R;
        ///Field `MR8` writer - Interrupt Mask on line 8
        pub struct MR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR8_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR8_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Interrupt Mask on line 9
        pub type MR9_A = MR0_A;
        ///Field `MR9` reader - Interrupt Mask on line 9
        pub type MR9_R = MR0_R;
        ///Field `MR9` writer - Interrupt Mask on line 9
        pub struct MR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR9_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR9_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Interrupt Mask on line 10
        pub type MR10_A = MR0_A;
        ///Field `MR10` reader - Interrupt Mask on line 10
        pub type MR10_R = MR0_R;
        ///Field `MR10` writer - Interrupt Mask on line 10
        pub struct MR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR10_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR10_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Interrupt Mask on line 11
        pub type MR11_A = MR0_A;
        ///Field `MR11` reader - Interrupt Mask on line 11
        pub type MR11_R = MR0_R;
        ///Field `MR11` writer - Interrupt Mask on line 11
        pub struct MR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR11_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR11_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Interrupt Mask on line 12
        pub type MR12_A = MR0_A;
        ///Field `MR12` reader - Interrupt Mask on line 12
        pub type MR12_R = MR0_R;
        ///Field `MR12` writer - Interrupt Mask on line 12
        pub struct MR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR12_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR12_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Interrupt Mask on line 13
        pub type MR13_A = MR0_A;
        ///Field `MR13` reader - Interrupt Mask on line 13
        pub type MR13_R = MR0_R;
        ///Field `MR13` writer - Interrupt Mask on line 13
        pub struct MR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR13_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR13_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Interrupt Mask on line 14
        pub type MR14_A = MR0_A;
        ///Field `MR14` reader - Interrupt Mask on line 14
        pub type MR14_R = MR0_R;
        ///Field `MR14` writer - Interrupt Mask on line 14
        pub struct MR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR14_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR14_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Interrupt Mask on line 15
        pub type MR15_A = MR0_A;
        ///Field `MR15` reader - Interrupt Mask on line 15
        pub type MR15_R = MR0_R;
        ///Field `MR15` writer - Interrupt Mask on line 15
        pub struct MR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR15_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR15_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Interrupt Mask on line 16
        pub type MR16_A = MR0_A;
        ///Field `MR16` reader - Interrupt Mask on line 16
        pub type MR16_R = MR0_R;
        ///Field `MR16` writer - Interrupt Mask on line 16
        pub struct MR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR16_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR16_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR16_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Interrupt Mask on line 17
        pub type MR17_A = MR0_A;
        ///Field `MR17` reader - Interrupt Mask on line 17
        pub type MR17_R = MR0_R;
        ///Field `MR17` writer - Interrupt Mask on line 17
        pub struct MR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR17_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR17_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR17_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Interrupt Mask on line 0
            #[inline(always)]
            pub fn mr0(&mut self) -> MR0_W {
                MR0_W { w: self }
            }
            ///Bit 1 - Interrupt Mask on line 1
            #[inline(always)]
            pub fn mr1(&mut self) -> MR1_W {
                MR1_W { w: self }
            }
            ///Bit 2 - Interrupt Mask on line 2
            #[inline(always)]
            pub fn mr2(&mut self) -> MR2_W {
                MR2_W { w: self }
            }
            ///Bit 3 - Interrupt Mask on line 3
            #[inline(always)]
            pub fn mr3(&mut self) -> MR3_W {
                MR3_W { w: self }
            }
            ///Bit 4 - Interrupt Mask on line 4
            #[inline(always)]
            pub fn mr4(&mut self) -> MR4_W {
                MR4_W { w: self }
            }
            ///Bit 5 - Interrupt Mask on line 5
            #[inline(always)]
            pub fn mr5(&mut self) -> MR5_W {
                MR5_W { w: self }
            }
            ///Bit 6 - Interrupt Mask on line 6
            #[inline(always)]
            pub fn mr6(&mut self) -> MR6_W {
                MR6_W { w: self }
            }
            ///Bit 7 - Interrupt Mask on line 7
            #[inline(always)]
            pub fn mr7(&mut self) -> MR7_W {
                MR7_W { w: self }
            }
            ///Bit 8 - Interrupt Mask on line 8
            #[inline(always)]
            pub fn mr8(&mut self) -> MR8_W {
                MR8_W { w: self }
            }
            ///Bit 9 - Interrupt Mask on line 9
            #[inline(always)]
            pub fn mr9(&mut self) -> MR9_W {
                MR9_W { w: self }
            }
            ///Bit 10 - Interrupt Mask on line 10
            #[inline(always)]
            pub fn mr10(&mut self) -> MR10_W {
                MR10_W { w: self }
            }
            ///Bit 11 - Interrupt Mask on line 11
            #[inline(always)]
            pub fn mr11(&mut self) -> MR11_W {
                MR11_W { w: self }
            }
            ///Bit 12 - Interrupt Mask on line 12
            #[inline(always)]
            pub fn mr12(&mut self) -> MR12_W {
                MR12_W { w: self }
            }
            ///Bit 13 - Interrupt Mask on line 13
            #[inline(always)]
            pub fn mr13(&mut self) -> MR13_W {
                MR13_W { w: self }
            }
            ///Bit 14 - Interrupt Mask on line 14
            #[inline(always)]
            pub fn mr14(&mut self) -> MR14_W {
                MR14_W { w: self }
            }
            ///Bit 15 - Interrupt Mask on line 15
            #[inline(always)]
            pub fn mr15(&mut self) -> MR15_W {
                MR15_W { w: self }
            }
            ///Bit 16 - Interrupt Mask on line 16
            #[inline(always)]
            pub fn mr16(&mut self) -> MR16_W {
                MR16_W { w: self }
            }
            ///Bit 17 - Interrupt Mask on line 17
            #[inline(always)]
            pub fn mr17(&mut self) -> MR17_W {
                MR17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Interrupt mask register (EXTI_IMR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [imr](index.html) module
        pub struct IMR_SPEC;
        impl crate::RegisterSpec for IMR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [imr::R](R) reader structure
        impl crate::Readable for IMR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [imr::W](W) writer structure
        impl crate::Writable for IMR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets IMR to value 0
        impl crate::Resettable for IMR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EMR register accessor: an alias for `Reg<EMR_SPEC>`
    pub type EMR = crate::Reg<emr::EMR_SPEC>;
    ///Event mask register (EXTI_EMR)
    pub mod emr {
        ///Register `EMR` reader
        pub struct R(crate::R<EMR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<EMR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<EMR_SPEC>> for R {
            fn from(reader: crate::R<EMR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `EMR` writer
        pub struct W(crate::W<EMR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EMR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EMR_SPEC>> for W {
            fn from(writer: crate::W<EMR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Event Mask on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MR0_A {
            ///0: Interrupt request line is masked
            MASKED = 0,
            ///1: Interrupt request line is unmasked
            UNMASKED = 1,
        }
        impl From<MR0_A> for bool {
            #[inline(always)]
            fn from(variant: MR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MR0` reader - Event Mask on line 0
        pub struct MR0_R(crate::FieldReader<bool, MR0_A>);
        impl MR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                MR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MR0_A {
                match self.bits {
                    false => MR0_A::MASKED,
                    true => MR0_A::UNMASKED,
                }
            }
            ///Checks if the value of the field is `MASKED`
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                **self == MR0_A::MASKED
            }
            ///Checks if the value of the field is `UNMASKED`
            #[inline(always)]
            pub fn is_unmasked(&self) -> bool {
                **self == MR0_A::UNMASKED
            }
        }
        impl core::ops::Deref for MR0_R {
            type Target = crate::FieldReader<bool, MR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MR0` writer - Event Mask on line 0
        pub struct MR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR0_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR0_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Event Mask on line 1
        pub type MR1_A = MR0_A;
        ///Field `MR1` reader - Event Mask on line 1
        pub type MR1_R = MR0_R;
        ///Field `MR1` writer - Event Mask on line 1
        pub struct MR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR1_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR1_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Event Mask on line 2
        pub type MR2_A = MR0_A;
        ///Field `MR2` reader - Event Mask on line 2
        pub type MR2_R = MR0_R;
        ///Field `MR2` writer - Event Mask on line 2
        pub struct MR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR2_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR2_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Event Mask on line 3
        pub type MR3_A = MR0_A;
        ///Field `MR3` reader - Event Mask on line 3
        pub type MR3_R = MR0_R;
        ///Field `MR3` writer - Event Mask on line 3
        pub struct MR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR3_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR3_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Event Mask on line 4
        pub type MR4_A = MR0_A;
        ///Field `MR4` reader - Event Mask on line 4
        pub type MR4_R = MR0_R;
        ///Field `MR4` writer - Event Mask on line 4
        pub struct MR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR4_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR4_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Event Mask on line 5
        pub type MR5_A = MR0_A;
        ///Field `MR5` reader - Event Mask on line 5
        pub type MR5_R = MR0_R;
        ///Field `MR5` writer - Event Mask on line 5
        pub struct MR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR5_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR5_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Event Mask on line 6
        pub type MR6_A = MR0_A;
        ///Field `MR6` reader - Event Mask on line 6
        pub type MR6_R = MR0_R;
        ///Field `MR6` writer - Event Mask on line 6
        pub struct MR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR6_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR6_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Event Mask on line 7
        pub type MR7_A = MR0_A;
        ///Field `MR7` reader - Event Mask on line 7
        pub type MR7_R = MR0_R;
        ///Field `MR7` writer - Event Mask on line 7
        pub struct MR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR7_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR7_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Event Mask on line 8
        pub type MR8_A = MR0_A;
        ///Field `MR8` reader - Event Mask on line 8
        pub type MR8_R = MR0_R;
        ///Field `MR8` writer - Event Mask on line 8
        pub struct MR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR8_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR8_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Event Mask on line 9
        pub type MR9_A = MR0_A;
        ///Field `MR9` reader - Event Mask on line 9
        pub type MR9_R = MR0_R;
        ///Field `MR9` writer - Event Mask on line 9
        pub struct MR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR9_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR9_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Event Mask on line 10
        pub type MR10_A = MR0_A;
        ///Field `MR10` reader - Event Mask on line 10
        pub type MR10_R = MR0_R;
        ///Field `MR10` writer - Event Mask on line 10
        pub struct MR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR10_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR10_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Event Mask on line 11
        pub type MR11_A = MR0_A;
        ///Field `MR11` reader - Event Mask on line 11
        pub type MR11_R = MR0_R;
        ///Field `MR11` writer - Event Mask on line 11
        pub struct MR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR11_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR11_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Event Mask on line 12
        pub type MR12_A = MR0_A;
        ///Field `MR12` reader - Event Mask on line 12
        pub type MR12_R = MR0_R;
        ///Field `MR12` writer - Event Mask on line 12
        pub struct MR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR12_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR12_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Event Mask on line 13
        pub type MR13_A = MR0_A;
        ///Field `MR13` reader - Event Mask on line 13
        pub type MR13_R = MR0_R;
        ///Field `MR13` writer - Event Mask on line 13
        pub struct MR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR13_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR13_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Event Mask on line 14
        pub type MR14_A = MR0_A;
        ///Field `MR14` reader - Event Mask on line 14
        pub type MR14_R = MR0_R;
        ///Field `MR14` writer - Event Mask on line 14
        pub struct MR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR14_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR14_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Event Mask on line 15
        pub type MR15_A = MR0_A;
        ///Field `MR15` reader - Event Mask on line 15
        pub type MR15_R = MR0_R;
        ///Field `MR15` writer - Event Mask on line 15
        pub struct MR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR15_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR15_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Event Mask on line 16
        pub type MR16_A = MR0_A;
        ///Field `MR16` reader - Event Mask on line 16
        pub type MR16_R = MR0_R;
        ///Field `MR16` writer - Event Mask on line 16
        pub struct MR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR16_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR16_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR16_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Event Mask on line 17
        pub type MR17_A = MR0_A;
        ///Field `MR17` reader - Event Mask on line 17
        pub type MR17_R = MR0_R;
        ///Field `MR17` writer - Event Mask on line 17
        pub struct MR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MR17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MR17_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Interrupt request line is masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(MR17_A::MASKED)
            }
            ///Interrupt request line is unmasked
            #[inline(always)]
            pub fn unmasked(self) -> &'a mut W {
                self.variant(MR17_A::UNMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            pub fn mr0(&self) -> MR0_R {
                MR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            pub fn mr1(&self) -> MR1_R {
                MR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            pub fn mr2(&self) -> MR2_R {
                MR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            pub fn mr3(&self) -> MR3_R {
                MR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            pub fn mr4(&self) -> MR4_R {
                MR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            pub fn mr5(&self) -> MR5_R {
                MR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            pub fn mr6(&self) -> MR6_R {
                MR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            pub fn mr7(&self) -> MR7_R {
                MR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            pub fn mr8(&self) -> MR8_R {
                MR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            pub fn mr9(&self) -> MR9_R {
                MR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            pub fn mr10(&self) -> MR10_R {
                MR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            pub fn mr11(&self) -> MR11_R {
                MR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            pub fn mr12(&self) -> MR12_R {
                MR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            pub fn mr13(&self) -> MR13_R {
                MR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            pub fn mr14(&self) -> MR14_R {
                MR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            pub fn mr15(&self) -> MR15_R {
                MR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            pub fn mr16(&self) -> MR16_R {
                MR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            pub fn mr17(&self) -> MR17_R {
                MR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Event Mask on line 0
            #[inline(always)]
            pub fn mr0(&mut self) -> MR0_W {
                MR0_W { w: self }
            }
            ///Bit 1 - Event Mask on line 1
            #[inline(always)]
            pub fn mr1(&mut self) -> MR1_W {
                MR1_W { w: self }
            }
            ///Bit 2 - Event Mask on line 2
            #[inline(always)]
            pub fn mr2(&mut self) -> MR2_W {
                MR2_W { w: self }
            }
            ///Bit 3 - Event Mask on line 3
            #[inline(always)]
            pub fn mr3(&mut self) -> MR3_W {
                MR3_W { w: self }
            }
            ///Bit 4 - Event Mask on line 4
            #[inline(always)]
            pub fn mr4(&mut self) -> MR4_W {
                MR4_W { w: self }
            }
            ///Bit 5 - Event Mask on line 5
            #[inline(always)]
            pub fn mr5(&mut self) -> MR5_W {
                MR5_W { w: self }
            }
            ///Bit 6 - Event Mask on line 6
            #[inline(always)]
            pub fn mr6(&mut self) -> MR6_W {
                MR6_W { w: self }
            }
            ///Bit 7 - Event Mask on line 7
            #[inline(always)]
            pub fn mr7(&mut self) -> MR7_W {
                MR7_W { w: self }
            }
            ///Bit 8 - Event Mask on line 8
            #[inline(always)]
            pub fn mr8(&mut self) -> MR8_W {
                MR8_W { w: self }
            }
            ///Bit 9 - Event Mask on line 9
            #[inline(always)]
            pub fn mr9(&mut self) -> MR9_W {
                MR9_W { w: self }
            }
            ///Bit 10 - Event Mask on line 10
            #[inline(always)]
            pub fn mr10(&mut self) -> MR10_W {
                MR10_W { w: self }
            }
            ///Bit 11 - Event Mask on line 11
            #[inline(always)]
            pub fn mr11(&mut self) -> MR11_W {
                MR11_W { w: self }
            }
            ///Bit 12 - Event Mask on line 12
            #[inline(always)]
            pub fn mr12(&mut self) -> MR12_W {
                MR12_W { w: self }
            }
            ///Bit 13 - Event Mask on line 13
            #[inline(always)]
            pub fn mr13(&mut self) -> MR13_W {
                MR13_W { w: self }
            }
            ///Bit 14 - Event Mask on line 14
            #[inline(always)]
            pub fn mr14(&mut self) -> MR14_W {
                MR14_W { w: self }
            }
            ///Bit 15 - Event Mask on line 15
            #[inline(always)]
            pub fn mr15(&mut self) -> MR15_W {
                MR15_W { w: self }
            }
            ///Bit 16 - Event Mask on line 16
            #[inline(always)]
            pub fn mr16(&mut self) -> MR16_W {
                MR16_W { w: self }
            }
            ///Bit 17 - Event Mask on line 17
            #[inline(always)]
            pub fn mr17(&mut self) -> MR17_W {
                MR17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Event mask register (EXTI_EMR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [emr](index.html) module
        pub struct EMR_SPEC;
        impl crate::RegisterSpec for EMR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [emr::R](R) reader structure
        impl crate::Readable for EMR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [emr::W](W) writer structure
        impl crate::Writable for EMR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EMR to value 0
        impl crate::Resettable for EMR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RTSR register accessor: an alias for `Reg<RTSR_SPEC>`
    pub type RTSR = crate::Reg<rtsr::RTSR_SPEC>;
    ///Rising Trigger selection register (EXTI_RTSR)
    pub mod rtsr {
        ///Register `RTSR` reader
        pub struct R(crate::R<RTSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RTSR_SPEC>> for R {
            fn from(reader: crate::R<RTSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTSR` writer
        pub struct W(crate::W<RTSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RTSR_SPEC>> for W {
            fn from(writer: crate::W<RTSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Rising trigger event configuration of line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TR0_A {
            ///0: Rising edge trigger is disabled
            DISABLED = 0,
            ///1: Rising edge trigger is enabled
            ENABLED = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TR0` reader - Rising trigger event configuration of line 0
        pub struct TR0_R(crate::FieldReader<bool, TR0_A>);
        impl TR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                TR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::DISABLED,
                    true => TR0_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TR0_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TR0_A::ENABLED
            }
        }
        impl core::ops::Deref for TR0_R {
            type Target = crate::FieldReader<bool, TR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TR0` writer - Rising trigger event configuration of line 0
        pub struct TR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Rising trigger event configuration of line 1
        pub type TR1_A = TR0_A;
        ///Field `TR1` reader - Rising trigger event configuration of line 1
        pub type TR1_R = TR0_R;
        ///Field `TR1` writer - Rising trigger event configuration of line 1
        pub struct TR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR1_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Rising trigger event configuration of line 2
        pub type TR2_A = TR0_A;
        ///Field `TR2` reader - Rising trigger event configuration of line 2
        pub type TR2_R = TR0_R;
        ///Field `TR2` writer - Rising trigger event configuration of line 2
        pub struct TR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR2_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Rising trigger event configuration of line 3
        pub type TR3_A = TR0_A;
        ///Field `TR3` reader - Rising trigger event configuration of line 3
        pub type TR3_R = TR0_R;
        ///Field `TR3` writer - Rising trigger event configuration of line 3
        pub struct TR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR3_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR3_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Rising trigger event configuration of line 4
        pub type TR4_A = TR0_A;
        ///Field `TR4` reader - Rising trigger event configuration of line 4
        pub type TR4_R = TR0_R;
        ///Field `TR4` writer - Rising trigger event configuration of line 4
        pub struct TR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR4_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR4_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Rising trigger event configuration of line 5
        pub type TR5_A = TR0_A;
        ///Field `TR5` reader - Rising trigger event configuration of line 5
        pub type TR5_R = TR0_R;
        ///Field `TR5` writer - Rising trigger event configuration of line 5
        pub struct TR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR5_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR5_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Rising trigger event configuration of line 6
        pub type TR6_A = TR0_A;
        ///Field `TR6` reader - Rising trigger event configuration of line 6
        pub type TR6_R = TR0_R;
        ///Field `TR6` writer - Rising trigger event configuration of line 6
        pub struct TR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR6_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR6_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Rising trigger event configuration of line 7
        pub type TR7_A = TR0_A;
        ///Field `TR7` reader - Rising trigger event configuration of line 7
        pub type TR7_R = TR0_R;
        ///Field `TR7` writer - Rising trigger event configuration of line 7
        pub struct TR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR7_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR7_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Rising trigger event configuration of line 8
        pub type TR8_A = TR0_A;
        ///Field `TR8` reader - Rising trigger event configuration of line 8
        pub type TR8_R = TR0_R;
        ///Field `TR8` writer - Rising trigger event configuration of line 8
        pub struct TR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR8_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR8_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Rising trigger event configuration of line 9
        pub type TR9_A = TR0_A;
        ///Field `TR9` reader - Rising trigger event configuration of line 9
        pub type TR9_R = TR0_R;
        ///Field `TR9` writer - Rising trigger event configuration of line 9
        pub struct TR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR9_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR9_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Rising trigger event configuration of line 10
        pub type TR10_A = TR0_A;
        ///Field `TR10` reader - Rising trigger event configuration of line 10
        pub type TR10_R = TR0_R;
        ///Field `TR10` writer - Rising trigger event configuration of line 10
        pub struct TR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR10_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR10_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Rising trigger event configuration of line 11
        pub type TR11_A = TR0_A;
        ///Field `TR11` reader - Rising trigger event configuration of line 11
        pub type TR11_R = TR0_R;
        ///Field `TR11` writer - Rising trigger event configuration of line 11
        pub struct TR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR11_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR11_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Rising trigger event configuration of line 12
        pub type TR12_A = TR0_A;
        ///Field `TR12` reader - Rising trigger event configuration of line 12
        pub type TR12_R = TR0_R;
        ///Field `TR12` writer - Rising trigger event configuration of line 12
        pub struct TR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR12_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR12_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Rising trigger event configuration of line 13
        pub type TR13_A = TR0_A;
        ///Field `TR13` reader - Rising trigger event configuration of line 13
        pub type TR13_R = TR0_R;
        ///Field `TR13` writer - Rising trigger event configuration of line 13
        pub struct TR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR13_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR13_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Rising trigger event configuration of line 14
        pub type TR14_A = TR0_A;
        ///Field `TR14` reader - Rising trigger event configuration of line 14
        pub type TR14_R = TR0_R;
        ///Field `TR14` writer - Rising trigger event configuration of line 14
        pub struct TR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR14_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR14_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Rising trigger event configuration of line 15
        pub type TR15_A = TR0_A;
        ///Field `TR15` reader - Rising trigger event configuration of line 15
        pub type TR15_R = TR0_R;
        ///Field `TR15` writer - Rising trigger event configuration of line 15
        pub struct TR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR15_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR15_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Rising trigger event configuration of line 16
        pub type TR16_A = TR0_A;
        ///Field `TR16` reader - Rising trigger event configuration of line 16
        pub type TR16_R = TR0_R;
        ///Field `TR16` writer - Rising trigger event configuration of line 16
        pub struct TR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR16_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR16_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR16_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Rising trigger event configuration of line 17
        pub type TR17_A = TR0_A;
        ///Field `TR17` reader - Rising trigger event configuration of line 17
        pub type TR17_R = TR0_R;
        ///Field `TR17` writer - Rising trigger event configuration of line 17
        pub struct TR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR17_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rising edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR17_A::DISABLED)
            }
            ///Rising edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR17_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Rising trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&mut self) -> TR0_W {
                TR0_W { w: self }
            }
            ///Bit 1 - Rising trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&mut self) -> TR1_W {
                TR1_W { w: self }
            }
            ///Bit 2 - Rising trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&mut self) -> TR2_W {
                TR2_W { w: self }
            }
            ///Bit 3 - Rising trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&mut self) -> TR3_W {
                TR3_W { w: self }
            }
            ///Bit 4 - Rising trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&mut self) -> TR4_W {
                TR4_W { w: self }
            }
            ///Bit 5 - Rising trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&mut self) -> TR5_W {
                TR5_W { w: self }
            }
            ///Bit 6 - Rising trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&mut self) -> TR6_W {
                TR6_W { w: self }
            }
            ///Bit 7 - Rising trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&mut self) -> TR7_W {
                TR7_W { w: self }
            }
            ///Bit 8 - Rising trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&mut self) -> TR8_W {
                TR8_W { w: self }
            }
            ///Bit 9 - Rising trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&mut self) -> TR9_W {
                TR9_W { w: self }
            }
            ///Bit 10 - Rising trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&mut self) -> TR10_W {
                TR10_W { w: self }
            }
            ///Bit 11 - Rising trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&mut self) -> TR11_W {
                TR11_W { w: self }
            }
            ///Bit 12 - Rising trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&mut self) -> TR12_W {
                TR12_W { w: self }
            }
            ///Bit 13 - Rising trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&mut self) -> TR13_W {
                TR13_W { w: self }
            }
            ///Bit 14 - Rising trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&mut self) -> TR14_W {
                TR14_W { w: self }
            }
            ///Bit 15 - Rising trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&mut self) -> TR15_W {
                TR15_W { w: self }
            }
            ///Bit 16 - Rising trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&mut self) -> TR16_W {
                TR16_W { w: self }
            }
            ///Bit 17 - Rising trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&mut self) -> TR17_W {
                TR17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Rising Trigger selection register (EXTI_RTSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtsr](index.html) module
        pub struct RTSR_SPEC;
        impl crate::RegisterSpec for RTSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtsr::R](R) reader structure
        impl crate::Readable for RTSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtsr::W](W) writer structure
        impl crate::Writable for RTSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RTSR to value 0
        impl crate::Resettable for RTSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///FTSR register accessor: an alias for `Reg<FTSR_SPEC>`
    pub type FTSR = crate::Reg<ftsr::FTSR_SPEC>;
    ///Falling Trigger selection register (EXTI_FTSR)
    pub mod ftsr {
        ///Register `FTSR` reader
        pub struct R(crate::R<FTSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<FTSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<FTSR_SPEC>> for R {
            fn from(reader: crate::R<FTSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `FTSR` writer
        pub struct W(crate::W<FTSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<FTSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<FTSR_SPEC>> for W {
            fn from(writer: crate::W<FTSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Falling trigger event configuration of line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TR0_A {
            ///0: Falling edge trigger is disabled
            DISABLED = 0,
            ///1: Falling edge trigger is enabled
            ENABLED = 1,
        }
        impl From<TR0_A> for bool {
            #[inline(always)]
            fn from(variant: TR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TR0` reader - Falling trigger event configuration of line 0
        pub struct TR0_R(crate::FieldReader<bool, TR0_A>);
        impl TR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                TR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TR0_A {
                match self.bits {
                    false => TR0_A::DISABLED,
                    true => TR0_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TR0_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TR0_A::ENABLED
            }
        }
        impl core::ops::Deref for TR0_R {
            type Target = crate::FieldReader<bool, TR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TR0` writer - Falling trigger event configuration of line 0
        pub struct TR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR0_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR0_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Falling trigger event configuration of line 1
        pub type TR1_A = TR0_A;
        ///Field `TR1` reader - Falling trigger event configuration of line 1
        pub type TR1_R = TR0_R;
        ///Field `TR1` writer - Falling trigger event configuration of line 1
        pub struct TR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR1_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Falling trigger event configuration of line 2
        pub type TR2_A = TR0_A;
        ///Field `TR2` reader - Falling trigger event configuration of line 2
        pub type TR2_R = TR0_R;
        ///Field `TR2` writer - Falling trigger event configuration of line 2
        pub struct TR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR2_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Falling trigger event configuration of line 3
        pub type TR3_A = TR0_A;
        ///Field `TR3` reader - Falling trigger event configuration of line 3
        pub type TR3_R = TR0_R;
        ///Field `TR3` writer - Falling trigger event configuration of line 3
        pub struct TR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR3_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR3_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Falling trigger event configuration of line 4
        pub type TR4_A = TR0_A;
        ///Field `TR4` reader - Falling trigger event configuration of line 4
        pub type TR4_R = TR0_R;
        ///Field `TR4` writer - Falling trigger event configuration of line 4
        pub struct TR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR4_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR4_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Falling trigger event configuration of line 5
        pub type TR5_A = TR0_A;
        ///Field `TR5` reader - Falling trigger event configuration of line 5
        pub type TR5_R = TR0_R;
        ///Field `TR5` writer - Falling trigger event configuration of line 5
        pub struct TR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR5_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR5_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Falling trigger event configuration of line 6
        pub type TR6_A = TR0_A;
        ///Field `TR6` reader - Falling trigger event configuration of line 6
        pub type TR6_R = TR0_R;
        ///Field `TR6` writer - Falling trigger event configuration of line 6
        pub struct TR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR6_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR6_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Falling trigger event configuration of line 7
        pub type TR7_A = TR0_A;
        ///Field `TR7` reader - Falling trigger event configuration of line 7
        pub type TR7_R = TR0_R;
        ///Field `TR7` writer - Falling trigger event configuration of line 7
        pub struct TR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR7_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR7_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Falling trigger event configuration of line 8
        pub type TR8_A = TR0_A;
        ///Field `TR8` reader - Falling trigger event configuration of line 8
        pub type TR8_R = TR0_R;
        ///Field `TR8` writer - Falling trigger event configuration of line 8
        pub struct TR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR8_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR8_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Falling trigger event configuration of line 9
        pub type TR9_A = TR0_A;
        ///Field `TR9` reader - Falling trigger event configuration of line 9
        pub type TR9_R = TR0_R;
        ///Field `TR9` writer - Falling trigger event configuration of line 9
        pub struct TR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR9_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR9_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Falling trigger event configuration of line 10
        pub type TR10_A = TR0_A;
        ///Field `TR10` reader - Falling trigger event configuration of line 10
        pub type TR10_R = TR0_R;
        ///Field `TR10` writer - Falling trigger event configuration of line 10
        pub struct TR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR10_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR10_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Falling trigger event configuration of line 11
        pub type TR11_A = TR0_A;
        ///Field `TR11` reader - Falling trigger event configuration of line 11
        pub type TR11_R = TR0_R;
        ///Field `TR11` writer - Falling trigger event configuration of line 11
        pub struct TR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR11_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR11_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Falling trigger event configuration of line 12
        pub type TR12_A = TR0_A;
        ///Field `TR12` reader - Falling trigger event configuration of line 12
        pub type TR12_R = TR0_R;
        ///Field `TR12` writer - Falling trigger event configuration of line 12
        pub struct TR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR12_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR12_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Falling trigger event configuration of line 13
        pub type TR13_A = TR0_A;
        ///Field `TR13` reader - Falling trigger event configuration of line 13
        pub type TR13_R = TR0_R;
        ///Field `TR13` writer - Falling trigger event configuration of line 13
        pub struct TR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR13_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR13_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Falling trigger event configuration of line 14
        pub type TR14_A = TR0_A;
        ///Field `TR14` reader - Falling trigger event configuration of line 14
        pub type TR14_R = TR0_R;
        ///Field `TR14` writer - Falling trigger event configuration of line 14
        pub struct TR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR14_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR14_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Falling trigger event configuration of line 15
        pub type TR15_A = TR0_A;
        ///Field `TR15` reader - Falling trigger event configuration of line 15
        pub type TR15_R = TR0_R;
        ///Field `TR15` writer - Falling trigger event configuration of line 15
        pub struct TR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR15_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR15_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Falling trigger event configuration of line 16
        pub type TR16_A = TR0_A;
        ///Field `TR16` reader - Falling trigger event configuration of line 16
        pub type TR16_R = TR0_R;
        ///Field `TR16` writer - Falling trigger event configuration of line 16
        pub struct TR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR16_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR16_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR16_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Falling trigger event configuration of line 17
        pub type TR17_A = TR0_A;
        ///Field `TR17` reader - Falling trigger event configuration of line 17
        pub type TR17_R = TR0_R;
        ///Field `TR17` writer - Falling trigger event configuration of line 17
        pub struct TR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TR17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TR17_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Falling edge trigger is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TR17_A::DISABLED)
            }
            ///Falling edge trigger is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TR17_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&self) -> TR0_R {
                TR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&self) -> TR1_R {
                TR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&self) -> TR2_R {
                TR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&self) -> TR3_R {
                TR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&self) -> TR4_R {
                TR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&self) -> TR5_R {
                TR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&self) -> TR6_R {
                TR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&self) -> TR7_R {
                TR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&self) -> TR8_R {
                TR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&self) -> TR9_R {
                TR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&self) -> TR10_R {
                TR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&self) -> TR11_R {
                TR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&self) -> TR12_R {
                TR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&self) -> TR13_R {
                TR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&self) -> TR14_R {
                TR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&self) -> TR15_R {
                TR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&self) -> TR16_R {
                TR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&self) -> TR17_R {
                TR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Falling trigger event configuration of line 0
            #[inline(always)]
            pub fn tr0(&mut self) -> TR0_W {
                TR0_W { w: self }
            }
            ///Bit 1 - Falling trigger event configuration of line 1
            #[inline(always)]
            pub fn tr1(&mut self) -> TR1_W {
                TR1_W { w: self }
            }
            ///Bit 2 - Falling trigger event configuration of line 2
            #[inline(always)]
            pub fn tr2(&mut self) -> TR2_W {
                TR2_W { w: self }
            }
            ///Bit 3 - Falling trigger event configuration of line 3
            #[inline(always)]
            pub fn tr3(&mut self) -> TR3_W {
                TR3_W { w: self }
            }
            ///Bit 4 - Falling trigger event configuration of line 4
            #[inline(always)]
            pub fn tr4(&mut self) -> TR4_W {
                TR4_W { w: self }
            }
            ///Bit 5 - Falling trigger event configuration of line 5
            #[inline(always)]
            pub fn tr5(&mut self) -> TR5_W {
                TR5_W { w: self }
            }
            ///Bit 6 - Falling trigger event configuration of line 6
            #[inline(always)]
            pub fn tr6(&mut self) -> TR6_W {
                TR6_W { w: self }
            }
            ///Bit 7 - Falling trigger event configuration of line 7
            #[inline(always)]
            pub fn tr7(&mut self) -> TR7_W {
                TR7_W { w: self }
            }
            ///Bit 8 - Falling trigger event configuration of line 8
            #[inline(always)]
            pub fn tr8(&mut self) -> TR8_W {
                TR8_W { w: self }
            }
            ///Bit 9 - Falling trigger event configuration of line 9
            #[inline(always)]
            pub fn tr9(&mut self) -> TR9_W {
                TR9_W { w: self }
            }
            ///Bit 10 - Falling trigger event configuration of line 10
            #[inline(always)]
            pub fn tr10(&mut self) -> TR10_W {
                TR10_W { w: self }
            }
            ///Bit 11 - Falling trigger event configuration of line 11
            #[inline(always)]
            pub fn tr11(&mut self) -> TR11_W {
                TR11_W { w: self }
            }
            ///Bit 12 - Falling trigger event configuration of line 12
            #[inline(always)]
            pub fn tr12(&mut self) -> TR12_W {
                TR12_W { w: self }
            }
            ///Bit 13 - Falling trigger event configuration of line 13
            #[inline(always)]
            pub fn tr13(&mut self) -> TR13_W {
                TR13_W { w: self }
            }
            ///Bit 14 - Falling trigger event configuration of line 14
            #[inline(always)]
            pub fn tr14(&mut self) -> TR14_W {
                TR14_W { w: self }
            }
            ///Bit 15 - Falling trigger event configuration of line 15
            #[inline(always)]
            pub fn tr15(&mut self) -> TR15_W {
                TR15_W { w: self }
            }
            ///Bit 16 - Falling trigger event configuration of line 16
            #[inline(always)]
            pub fn tr16(&mut self) -> TR16_W {
                TR16_W { w: self }
            }
            ///Bit 17 - Falling trigger event configuration of line 17
            #[inline(always)]
            pub fn tr17(&mut self) -> TR17_W {
                TR17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Falling Trigger selection register (EXTI_FTSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ftsr](index.html) module
        pub struct FTSR_SPEC;
        impl crate::RegisterSpec for FTSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ftsr::R](R) reader structure
        impl crate::Readable for FTSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ftsr::W](W) writer structure
        impl crate::Writable for FTSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets FTSR to value 0
        impl crate::Resettable for FTSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SWIER register accessor: an alias for `Reg<SWIER_SPEC>`
    pub type SWIER = crate::Reg<swier::SWIER_SPEC>;
    ///Software interrupt event register (EXTI_SWIER)
    pub mod swier {
        ///Register `SWIER` reader
        pub struct R(crate::R<SWIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SWIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SWIER_SPEC>> for R {
            fn from(reader: crate::R<SWIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SWIER` writer
        pub struct W(crate::W<SWIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SWIER_SPEC>> for W {
            fn from(writer: crate::W<SWIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Software Interrupt on line 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWIER0_A {
            ///1: Generates an interrupt request
            PEND = 1,
        }
        impl From<SWIER0_A> for bool {
            #[inline(always)]
            fn from(variant: SWIER0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SWIER0` reader - Software Interrupt on line 0
        pub struct SWIER0_R(crate::FieldReader<bool, SWIER0_A>);
        impl SWIER0_R {
            pub(crate) fn new(bits: bool) -> Self {
                SWIER0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<SWIER0_A> {
                match self.bits {
                    true => Some(SWIER0_A::PEND),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `PEND`
            #[inline(always)]
            pub fn is_pend(&self) -> bool {
                **self == SWIER0_A::PEND
            }
        }
        impl core::ops::Deref for SWIER0_R {
            type Target = crate::FieldReader<bool, SWIER0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SWIER0` writer - Software Interrupt on line 0
        pub struct SWIER0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER0_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER0_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Software Interrupt on line 1
        pub type SWIER1_A = SWIER0_A;
        ///Field `SWIER1` reader - Software Interrupt on line 1
        pub type SWIER1_R = SWIER0_R;
        ///Field `SWIER1` writer - Software Interrupt on line 1
        pub struct SWIER1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER1_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Software Interrupt on line 2
        pub type SWIER2_A = SWIER0_A;
        ///Field `SWIER2` reader - Software Interrupt on line 2
        pub type SWIER2_R = SWIER0_R;
        ///Field `SWIER2` writer - Software Interrupt on line 2
        pub struct SWIER2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER2_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Software Interrupt on line 3
        pub type SWIER3_A = SWIER0_A;
        ///Field `SWIER3` reader - Software Interrupt on line 3
        pub type SWIER3_R = SWIER0_R;
        ///Field `SWIER3` writer - Software Interrupt on line 3
        pub struct SWIER3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER3_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER3_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Software Interrupt on line 4
        pub type SWIER4_A = SWIER0_A;
        ///Field `SWIER4` reader - Software Interrupt on line 4
        pub type SWIER4_R = SWIER0_R;
        ///Field `SWIER4` writer - Software Interrupt on line 4
        pub struct SWIER4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER4_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER4_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Software Interrupt on line 5
        pub type SWIER5_A = SWIER0_A;
        ///Field `SWIER5` reader - Software Interrupt on line 5
        pub type SWIER5_R = SWIER0_R;
        ///Field `SWIER5` writer - Software Interrupt on line 5
        pub struct SWIER5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER5_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER5_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Software Interrupt on line 6
        pub type SWIER6_A = SWIER0_A;
        ///Field `SWIER6` reader - Software Interrupt on line 6
        pub type SWIER6_R = SWIER0_R;
        ///Field `SWIER6` writer - Software Interrupt on line 6
        pub struct SWIER6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER6_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER6_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Software Interrupt on line 7
        pub type SWIER7_A = SWIER0_A;
        ///Field `SWIER7` reader - Software Interrupt on line 7
        pub type SWIER7_R = SWIER0_R;
        ///Field `SWIER7` writer - Software Interrupt on line 7
        pub struct SWIER7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER7_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER7_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Software Interrupt on line 8
        pub type SWIER8_A = SWIER0_A;
        ///Field `SWIER8` reader - Software Interrupt on line 8
        pub type SWIER8_R = SWIER0_R;
        ///Field `SWIER8` writer - Software Interrupt on line 8
        pub struct SWIER8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER8_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER8_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Software Interrupt on line 9
        pub type SWIER9_A = SWIER0_A;
        ///Field `SWIER9` reader - Software Interrupt on line 9
        pub type SWIER9_R = SWIER0_R;
        ///Field `SWIER9` writer - Software Interrupt on line 9
        pub struct SWIER9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER9_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER9_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Software Interrupt on line 10
        pub type SWIER10_A = SWIER0_A;
        ///Field `SWIER10` reader - Software Interrupt on line 10
        pub type SWIER10_R = SWIER0_R;
        ///Field `SWIER10` writer - Software Interrupt on line 10
        pub struct SWIER10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER10_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER10_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Software Interrupt on line 11
        pub type SWIER11_A = SWIER0_A;
        ///Field `SWIER11` reader - Software Interrupt on line 11
        pub type SWIER11_R = SWIER0_R;
        ///Field `SWIER11` writer - Software Interrupt on line 11
        pub struct SWIER11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER11_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER11_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Software Interrupt on line 12
        pub type SWIER12_A = SWIER0_A;
        ///Field `SWIER12` reader - Software Interrupt on line 12
        pub type SWIER12_R = SWIER0_R;
        ///Field `SWIER12` writer - Software Interrupt on line 12
        pub struct SWIER12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER12_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER12_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Software Interrupt on line 13
        pub type SWIER13_A = SWIER0_A;
        ///Field `SWIER13` reader - Software Interrupt on line 13
        pub type SWIER13_R = SWIER0_R;
        ///Field `SWIER13` writer - Software Interrupt on line 13
        pub struct SWIER13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER13_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER13_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Software Interrupt on line 14
        pub type SWIER14_A = SWIER0_A;
        ///Field `SWIER14` reader - Software Interrupt on line 14
        pub type SWIER14_R = SWIER0_R;
        ///Field `SWIER14` writer - Software Interrupt on line 14
        pub struct SWIER14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER14_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER14_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Software Interrupt on line 15
        pub type SWIER15_A = SWIER0_A;
        ///Field `SWIER15` reader - Software Interrupt on line 15
        pub type SWIER15_R = SWIER0_R;
        ///Field `SWIER15` writer - Software Interrupt on line 15
        pub struct SWIER15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER15_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER15_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Software Interrupt on line 16
        pub type SWIER16_A = SWIER0_A;
        ///Field `SWIER16` reader - Software Interrupt on line 16
        pub type SWIER16_R = SWIER0_R;
        ///Field `SWIER16` writer - Software Interrupt on line 16
        pub struct SWIER16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER16_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER16_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Software Interrupt on line 17
        pub type SWIER17_A = SWIER0_A;
        ///Field `SWIER17` reader - Software Interrupt on line 17
        pub type SWIER17_R = SWIER0_R;
        ///Field `SWIER17` writer - Software Interrupt on line 17
        pub struct SWIER17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWIER17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWIER17_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Generates an interrupt request
            #[inline(always)]
            pub fn pend(self) -> &'a mut W {
                self.variant(SWIER17_A::PEND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            pub fn swier0(&self) -> SWIER0_R {
                SWIER0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            pub fn swier1(&self) -> SWIER1_R {
                SWIER1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            pub fn swier2(&self) -> SWIER2_R {
                SWIER2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            pub fn swier3(&self) -> SWIER3_R {
                SWIER3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            pub fn swier4(&self) -> SWIER4_R {
                SWIER4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            pub fn swier5(&self) -> SWIER5_R {
                SWIER5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            pub fn swier6(&self) -> SWIER6_R {
                SWIER6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            pub fn swier7(&self) -> SWIER7_R {
                SWIER7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            pub fn swier8(&self) -> SWIER8_R {
                SWIER8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            pub fn swier9(&self) -> SWIER9_R {
                SWIER9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            pub fn swier10(&self) -> SWIER10_R {
                SWIER10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            pub fn swier11(&self) -> SWIER11_R {
                SWIER11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            pub fn swier12(&self) -> SWIER12_R {
                SWIER12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            pub fn swier13(&self) -> SWIER13_R {
                SWIER13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            pub fn swier14(&self) -> SWIER14_R {
                SWIER14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            pub fn swier15(&self) -> SWIER15_R {
                SWIER15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            pub fn swier16(&self) -> SWIER16_R {
                SWIER16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            pub fn swier17(&self) -> SWIER17_R {
                SWIER17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Software Interrupt on line 0
            #[inline(always)]
            pub fn swier0(&mut self) -> SWIER0_W {
                SWIER0_W { w: self }
            }
            ///Bit 1 - Software Interrupt on line 1
            #[inline(always)]
            pub fn swier1(&mut self) -> SWIER1_W {
                SWIER1_W { w: self }
            }
            ///Bit 2 - Software Interrupt on line 2
            #[inline(always)]
            pub fn swier2(&mut self) -> SWIER2_W {
                SWIER2_W { w: self }
            }
            ///Bit 3 - Software Interrupt on line 3
            #[inline(always)]
            pub fn swier3(&mut self) -> SWIER3_W {
                SWIER3_W { w: self }
            }
            ///Bit 4 - Software Interrupt on line 4
            #[inline(always)]
            pub fn swier4(&mut self) -> SWIER4_W {
                SWIER4_W { w: self }
            }
            ///Bit 5 - Software Interrupt on line 5
            #[inline(always)]
            pub fn swier5(&mut self) -> SWIER5_W {
                SWIER5_W { w: self }
            }
            ///Bit 6 - Software Interrupt on line 6
            #[inline(always)]
            pub fn swier6(&mut self) -> SWIER6_W {
                SWIER6_W { w: self }
            }
            ///Bit 7 - Software Interrupt on line 7
            #[inline(always)]
            pub fn swier7(&mut self) -> SWIER7_W {
                SWIER7_W { w: self }
            }
            ///Bit 8 - Software Interrupt on line 8
            #[inline(always)]
            pub fn swier8(&mut self) -> SWIER8_W {
                SWIER8_W { w: self }
            }
            ///Bit 9 - Software Interrupt on line 9
            #[inline(always)]
            pub fn swier9(&mut self) -> SWIER9_W {
                SWIER9_W { w: self }
            }
            ///Bit 10 - Software Interrupt on line 10
            #[inline(always)]
            pub fn swier10(&mut self) -> SWIER10_W {
                SWIER10_W { w: self }
            }
            ///Bit 11 - Software Interrupt on line 11
            #[inline(always)]
            pub fn swier11(&mut self) -> SWIER11_W {
                SWIER11_W { w: self }
            }
            ///Bit 12 - Software Interrupt on line 12
            #[inline(always)]
            pub fn swier12(&mut self) -> SWIER12_W {
                SWIER12_W { w: self }
            }
            ///Bit 13 - Software Interrupt on line 13
            #[inline(always)]
            pub fn swier13(&mut self) -> SWIER13_W {
                SWIER13_W { w: self }
            }
            ///Bit 14 - Software Interrupt on line 14
            #[inline(always)]
            pub fn swier14(&mut self) -> SWIER14_W {
                SWIER14_W { w: self }
            }
            ///Bit 15 - Software Interrupt on line 15
            #[inline(always)]
            pub fn swier15(&mut self) -> SWIER15_W {
                SWIER15_W { w: self }
            }
            ///Bit 16 - Software Interrupt on line 16
            #[inline(always)]
            pub fn swier16(&mut self) -> SWIER16_W {
                SWIER16_W { w: self }
            }
            ///Bit 17 - Software Interrupt on line 17
            #[inline(always)]
            pub fn swier17(&mut self) -> SWIER17_W {
                SWIER17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Software interrupt event register (EXTI_SWIER)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swier](index.html) module
        pub struct SWIER_SPEC;
        impl crate::RegisterSpec for SWIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [swier::R](R) reader structure
        impl crate::Readable for SWIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [swier::W](W) writer structure
        impl crate::Writable for SWIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SWIER to value 0
        impl crate::Resettable for SWIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PR register accessor: an alias for `Reg<PR_SPEC>`
    pub type PR = crate::Reg<pr::PR_SPEC>;
    ///Pending register (EXTI_PR)
    pub mod pr {
        ///Register `PR` reader
        pub struct R(crate::R<PR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PR_SPEC>> for R {
            fn from(reader: crate::R<PR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PR` writer
        pub struct W(crate::W<PR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PR_SPEC>> for W {
            fn from(writer: crate::W<PR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Pending bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PR0_A {
            ///0: No trigger request occurred
            NOTPENDING = 0,
            ///1: Selected trigger request occurred
            PENDING = 1,
        }
        impl From<PR0_A> for bool {
            #[inline(always)]
            fn from(variant: PR0_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PR0` reader - Pending bit 0
        pub struct PR0_R(crate::FieldReader<bool, PR0_A>);
        impl PR0_R {
            pub(crate) fn new(bits: bool) -> Self {
                PR0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PR0_A {
                match self.bits {
                    false => PR0_A::NOTPENDING,
                    true => PR0_A::PENDING,
                }
            }
            ///Checks if the value of the field is `NOTPENDING`
            #[inline(always)]
            pub fn is_not_pending(&self) -> bool {
                **self == PR0_A::NOTPENDING
            }
            ///Checks if the value of the field is `PENDING`
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                **self == PR0_A::PENDING
            }
        }
        impl core::ops::Deref for PR0_R {
            type Target = crate::FieldReader<bool, PR0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Pending bit 0
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PR0_AW {
            ///1: Clears pending bit
            CLEAR = 1,
        }
        impl From<PR0_AW> for bool {
            #[inline(always)]
            fn from(variant: PR0_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PR0` writer - Pending bit 0
        pub struct PR0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR0_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR0_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Pending bit 1
        pub type PR1_A = PR0_A;
        ///Field `PR1` reader - Pending bit 1
        pub type PR1_R = PR0_R;
        ///Pending bit 1
        pub type PR1_AW = PR0_AW;
        ///Field `PR1` writer - Pending bit 1
        pub struct PR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR1_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Pending bit 2
        pub type PR2_A = PR0_A;
        ///Field `PR2` reader - Pending bit 2
        pub type PR2_R = PR0_R;
        ///Pending bit 2
        pub type PR2_AW = PR0_AW;
        ///Field `PR2` writer - Pending bit 2
        pub struct PR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR2_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Pending bit 3
        pub type PR3_A = PR0_A;
        ///Field `PR3` reader - Pending bit 3
        pub type PR3_R = PR0_R;
        ///Pending bit 3
        pub type PR3_AW = PR0_AW;
        ///Field `PR3` writer - Pending bit 3
        pub struct PR3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR3_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Pending bit 4
        pub type PR4_A = PR0_A;
        ///Field `PR4` reader - Pending bit 4
        pub type PR4_R = PR0_R;
        ///Pending bit 4
        pub type PR4_AW = PR0_AW;
        ///Field `PR4` writer - Pending bit 4
        pub struct PR4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR4_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Pending bit 5
        pub type PR5_A = PR0_A;
        ///Field `PR5` reader - Pending bit 5
        pub type PR5_R = PR0_R;
        ///Pending bit 5
        pub type PR5_AW = PR0_AW;
        ///Field `PR5` writer - Pending bit 5
        pub struct PR5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR5_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Pending bit 6
        pub type PR6_A = PR0_A;
        ///Field `PR6` reader - Pending bit 6
        pub type PR6_R = PR0_R;
        ///Pending bit 6
        pub type PR6_AW = PR0_AW;
        ///Field `PR6` writer - Pending bit 6
        pub struct PR6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR6_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Pending bit 7
        pub type PR7_A = PR0_A;
        ///Field `PR7` reader - Pending bit 7
        pub type PR7_R = PR0_R;
        ///Pending bit 7
        pub type PR7_AW = PR0_AW;
        ///Field `PR7` writer - Pending bit 7
        pub struct PR7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR7_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Pending bit 8
        pub type PR8_A = PR0_A;
        ///Field `PR8` reader - Pending bit 8
        pub type PR8_R = PR0_R;
        ///Pending bit 8
        pub type PR8_AW = PR0_AW;
        ///Field `PR8` writer - Pending bit 8
        pub struct PR8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR8_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR8_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Pending bit 9
        pub type PR9_A = PR0_A;
        ///Field `PR9` reader - Pending bit 9
        pub type PR9_R = PR0_R;
        ///Pending bit 9
        pub type PR9_AW = PR0_AW;
        ///Field `PR9` writer - Pending bit 9
        pub struct PR9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR9_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR9_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Pending bit 10
        pub type PR10_A = PR0_A;
        ///Field `PR10` reader - Pending bit 10
        pub type PR10_R = PR0_R;
        ///Pending bit 10
        pub type PR10_AW = PR0_AW;
        ///Field `PR10` writer - Pending bit 10
        pub struct PR10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR10_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR10_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Pending bit 11
        pub type PR11_A = PR0_A;
        ///Field `PR11` reader - Pending bit 11
        pub type PR11_R = PR0_R;
        ///Pending bit 11
        pub type PR11_AW = PR0_AW;
        ///Field `PR11` writer - Pending bit 11
        pub struct PR11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR11_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR11_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Pending bit 12
        pub type PR12_A = PR0_A;
        ///Field `PR12` reader - Pending bit 12
        pub type PR12_R = PR0_R;
        ///Pending bit 12
        pub type PR12_AW = PR0_AW;
        ///Field `PR12` writer - Pending bit 12
        pub struct PR12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR12_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR12_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Pending bit 13
        pub type PR13_A = PR0_A;
        ///Field `PR13` reader - Pending bit 13
        pub type PR13_R = PR0_R;
        ///Pending bit 13
        pub type PR13_AW = PR0_AW;
        ///Field `PR13` writer - Pending bit 13
        pub struct PR13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR13_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR13_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Pending bit 14
        pub type PR14_A = PR0_A;
        ///Field `PR14` reader - Pending bit 14
        pub type PR14_R = PR0_R;
        ///Pending bit 14
        pub type PR14_AW = PR0_AW;
        ///Field `PR14` writer - Pending bit 14
        pub struct PR14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR14_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR14_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Pending bit 15
        pub type PR15_A = PR0_A;
        ///Field `PR15` reader - Pending bit 15
        pub type PR15_R = PR0_R;
        ///Pending bit 15
        pub type PR15_AW = PR0_AW;
        ///Field `PR15` writer - Pending bit 15
        pub struct PR15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR15_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR15_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Pending bit 16
        pub type PR16_A = PR0_A;
        ///Field `PR16` reader - Pending bit 16
        pub type PR16_R = PR0_R;
        ///Pending bit 16
        pub type PR16_AW = PR0_AW;
        ///Field `PR16` writer - Pending bit 16
        pub struct PR16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR16_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR16_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Pending bit 17
        pub type PR17_A = PR0_A;
        ///Field `PR17` reader - Pending bit 17
        pub type PR17_R = PR0_R;
        ///Pending bit 17
        pub type PR17_AW = PR0_AW;
        ///Field `PR17` writer - Pending bit 17
        pub struct PR17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR17_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears pending bit
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(PR17_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Pending bit 0
            #[inline(always)]
            pub fn pr0(&self) -> PR0_R {
                PR0_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Pending bit 1
            #[inline(always)]
            pub fn pr1(&self) -> PR1_R {
                PR1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Pending bit 2
            #[inline(always)]
            pub fn pr2(&self) -> PR2_R {
                PR2_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Pending bit 3
            #[inline(always)]
            pub fn pr3(&self) -> PR3_R {
                PR3_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Pending bit 4
            #[inline(always)]
            pub fn pr4(&self) -> PR4_R {
                PR4_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Pending bit 5
            #[inline(always)]
            pub fn pr5(&self) -> PR5_R {
                PR5_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Pending bit 6
            #[inline(always)]
            pub fn pr6(&self) -> PR6_R {
                PR6_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Pending bit 7
            #[inline(always)]
            pub fn pr7(&self) -> PR7_R {
                PR7_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Pending bit 8
            #[inline(always)]
            pub fn pr8(&self) -> PR8_R {
                PR8_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Pending bit 9
            #[inline(always)]
            pub fn pr9(&self) -> PR9_R {
                PR9_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Pending bit 10
            #[inline(always)]
            pub fn pr10(&self) -> PR10_R {
                PR10_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Pending bit 11
            #[inline(always)]
            pub fn pr11(&self) -> PR11_R {
                PR11_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Pending bit 12
            #[inline(always)]
            pub fn pr12(&self) -> PR12_R {
                PR12_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Pending bit 13
            #[inline(always)]
            pub fn pr13(&self) -> PR13_R {
                PR13_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Pending bit 14
            #[inline(always)]
            pub fn pr14(&self) -> PR14_R {
                PR14_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Pending bit 15
            #[inline(always)]
            pub fn pr15(&self) -> PR15_R {
                PR15_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Pending bit 16
            #[inline(always)]
            pub fn pr16(&self) -> PR16_R {
                PR16_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Pending bit 17
            #[inline(always)]
            pub fn pr17(&self) -> PR17_R {
                PR17_R::new(((self.bits >> 17) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Pending bit 0
            #[inline(always)]
            pub fn pr0(&mut self) -> PR0_W {
                PR0_W { w: self }
            }
            ///Bit 1 - Pending bit 1
            #[inline(always)]
            pub fn pr1(&mut self) -> PR1_W {
                PR1_W { w: self }
            }
            ///Bit 2 - Pending bit 2
            #[inline(always)]
            pub fn pr2(&mut self) -> PR2_W {
                PR2_W { w: self }
            }
            ///Bit 3 - Pending bit 3
            #[inline(always)]
            pub fn pr3(&mut self) -> PR3_W {
                PR3_W { w: self }
            }
            ///Bit 4 - Pending bit 4
            #[inline(always)]
            pub fn pr4(&mut self) -> PR4_W {
                PR4_W { w: self }
            }
            ///Bit 5 - Pending bit 5
            #[inline(always)]
            pub fn pr5(&mut self) -> PR5_W {
                PR5_W { w: self }
            }
            ///Bit 6 - Pending bit 6
            #[inline(always)]
            pub fn pr6(&mut self) -> PR6_W {
                PR6_W { w: self }
            }
            ///Bit 7 - Pending bit 7
            #[inline(always)]
            pub fn pr7(&mut self) -> PR7_W {
                PR7_W { w: self }
            }
            ///Bit 8 - Pending bit 8
            #[inline(always)]
            pub fn pr8(&mut self) -> PR8_W {
                PR8_W { w: self }
            }
            ///Bit 9 - Pending bit 9
            #[inline(always)]
            pub fn pr9(&mut self) -> PR9_W {
                PR9_W { w: self }
            }
            ///Bit 10 - Pending bit 10
            #[inline(always)]
            pub fn pr10(&mut self) -> PR10_W {
                PR10_W { w: self }
            }
            ///Bit 11 - Pending bit 11
            #[inline(always)]
            pub fn pr11(&mut self) -> PR11_W {
                PR11_W { w: self }
            }
            ///Bit 12 - Pending bit 12
            #[inline(always)]
            pub fn pr12(&mut self) -> PR12_W {
                PR12_W { w: self }
            }
            ///Bit 13 - Pending bit 13
            #[inline(always)]
            pub fn pr13(&mut self) -> PR13_W {
                PR13_W { w: self }
            }
            ///Bit 14 - Pending bit 14
            #[inline(always)]
            pub fn pr14(&mut self) -> PR14_W {
                PR14_W { w: self }
            }
            ///Bit 15 - Pending bit 15
            #[inline(always)]
            pub fn pr15(&mut self) -> PR15_W {
                PR15_W { w: self }
            }
            ///Bit 16 - Pending bit 16
            #[inline(always)]
            pub fn pr16(&mut self) -> PR16_W {
                PR16_W { w: self }
            }
            ///Bit 17 - Pending bit 17
            #[inline(always)]
            pub fn pr17(&mut self) -> PR17_W {
                PR17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Pending register (EXTI_PR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pr](index.html) module
        pub struct PR_SPEC;
        impl crate::RegisterSpec for PR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pr::R](R) reader structure
        impl crate::Readable for PR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pr::W](W) writer structure
        impl crate::Writable for PR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PR to value 0
        impl crate::Resettable for PR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///DMA controller
pub struct DMA1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA1 {}
impl DMA1 {
    ///Pointer to the register block
    pub const PTR: *const dma1::RegisterBlock = 0x4002_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA1 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA1").finish()
    }
}
///DMA controller
pub mod dma1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DMA interrupt status register (DMA_ISR)
        pub isr: crate::Reg<isr::ISR_SPEC>,
        ///0x04 - DMA interrupt flag clear register (DMA_IFCR)
        pub ifcr: crate::Reg<ifcr::IFCR_SPEC>,
        ///0x08 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch1: CH,
        _reserved3: [u8; 4usize],
        ///0x1c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch2: CH,
        _reserved4: [u8; 4usize],
        ///0x30 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch3: CH,
        _reserved5: [u8; 4usize],
        ///0x44 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch4: CH,
        _reserved6: [u8; 4usize],
        ///0x58 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch5: CH,
        _reserved7: [u8; 4usize],
        ///0x6c - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch6: CH,
        _reserved8: [u8; 4usize],
        ///0x80 - Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
        pub ch7: CH,
    }
    ///Register block
    #[repr(C)]
    pub struct CH {
        ///0x00 - DMA channel configuration register (DMA_CCR)
        pub cr: crate::Reg<self::ch::cr::CR_SPEC>,
        ///0x04 - DMA channel 1 number of data register
        pub ndtr: crate::Reg<self::ch::ndtr::NDTR_SPEC>,
        ///0x08 - DMA channel 1 peripheral address register
        pub par: crate::Reg<self::ch::par::PAR_SPEC>,
        ///0x0c - DMA channel 1 memory address register
        pub mar: crate::Reg<self::ch::mar::MAR_SPEC>,
    }
    ///Register block
    ///Channel cluster: CCR?, CNDTR?, CPAR?, and CMAR? registers
    pub mod ch {
        ///CR register accessor: an alias for `Reg<CR_SPEC>`
        pub type CR = crate::Reg<cr::CR_SPEC>;
        ///DMA channel configuration register (DMA_CCR)
        pub mod cr {
            ///Register `CR` reader
            pub struct R(crate::R<CR_SPEC>);
            impl core::ops::Deref for R {
                type Target = crate::R<CR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::convert::From<crate::R<CR_SPEC>> for R {
                fn from(reader: crate::R<CR_SPEC>) -> Self {
                    R(reader)
                }
            }
            ///Register `CR` writer
            pub struct W(crate::W<CR_SPEC>);
            impl core::ops::Deref for W {
                type Target = crate::W<CR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::ops::DerefMut for W {
                #[inline(always)]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
            }
            impl core::convert::From<crate::W<CR_SPEC>> for W {
                fn from(writer: crate::W<CR_SPEC>) -> Self {
                    W(writer)
                }
            }
            ///Channel enable
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum EN_A {
                ///0: Channel disabled
                DISABLED = 0,
                ///1: Channel enabled
                ENABLED = 1,
            }
            impl From<EN_A> for bool {
                #[inline(always)]
                fn from(variant: EN_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `EN` reader - Channel enable
            pub struct EN_R(crate::FieldReader<bool, EN_A>);
            impl EN_R {
                pub(crate) fn new(bits: bool) -> Self {
                    EN_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> EN_A {
                    match self.bits {
                        false => EN_A::DISABLED,
                        true => EN_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == EN_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == EN_A::ENABLED
                }
            }
            impl core::ops::Deref for EN_R {
                type Target = crate::FieldReader<bool, EN_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `EN` writer - Channel enable
            pub struct EN_W<'a> {
                w: &'a mut W,
            }
            impl<'a> EN_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: EN_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Channel disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(EN_A::DISABLED)
                }
                ///Channel enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(EN_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                    self.w
                }
            }
            ///Transfer complete interrupt enable
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TCIE_A {
                ///0: Transfer Complete interrupt disabled
                DISABLED = 0,
                ///1: Transfer Complete interrupt enabled
                ENABLED = 1,
            }
            impl From<TCIE_A> for bool {
                #[inline(always)]
                fn from(variant: TCIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `TCIE` reader - Transfer complete interrupt enable
            pub struct TCIE_R(crate::FieldReader<bool, TCIE_A>);
            impl TCIE_R {
                pub(crate) fn new(bits: bool) -> Self {
                    TCIE_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> TCIE_A {
                    match self.bits {
                        false => TCIE_A::DISABLED,
                        true => TCIE_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == TCIE_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == TCIE_A::ENABLED
                }
            }
            impl core::ops::Deref for TCIE_R {
                type Target = crate::FieldReader<bool, TCIE_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `TCIE` writer - Transfer complete interrupt enable
            pub struct TCIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TCIE_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Transfer Complete interrupt disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TCIE_A::DISABLED)
                }
                ///Transfer Complete interrupt enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TCIE_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                    self.w
                }
            }
            ///Half Transfer interrupt enable
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum HTIE_A {
                ///0: Half Transfer interrupt disabled
                DISABLED = 0,
                ///1: Half Transfer interrupt enabled
                ENABLED = 1,
            }
            impl From<HTIE_A> for bool {
                #[inline(always)]
                fn from(variant: HTIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `HTIE` reader - Half Transfer interrupt enable
            pub struct HTIE_R(crate::FieldReader<bool, HTIE_A>);
            impl HTIE_R {
                pub(crate) fn new(bits: bool) -> Self {
                    HTIE_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> HTIE_A {
                    match self.bits {
                        false => HTIE_A::DISABLED,
                        true => HTIE_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == HTIE_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == HTIE_A::ENABLED
                }
            }
            impl core::ops::Deref for HTIE_R {
                type Target = crate::FieldReader<bool, HTIE_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `HTIE` writer - Half Transfer interrupt enable
            pub struct HTIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> HTIE_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: HTIE_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Half Transfer interrupt disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(HTIE_A::DISABLED)
                }
                ///Half Transfer interrupt enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(HTIE_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                    self.w
                }
            }
            ///Transfer error interrupt enable
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum TEIE_A {
                ///0: Transfer Error interrupt disabled
                DISABLED = 0,
                ///1: Transfer Error interrupt enabled
                ENABLED = 1,
            }
            impl From<TEIE_A> for bool {
                #[inline(always)]
                fn from(variant: TEIE_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `TEIE` reader - Transfer error interrupt enable
            pub struct TEIE_R(crate::FieldReader<bool, TEIE_A>);
            impl TEIE_R {
                pub(crate) fn new(bits: bool) -> Self {
                    TEIE_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> TEIE_A {
                    match self.bits {
                        false => TEIE_A::DISABLED,
                        true => TEIE_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == TEIE_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == TEIE_A::ENABLED
                }
            }
            impl core::ops::Deref for TEIE_R {
                type Target = crate::FieldReader<bool, TEIE_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `TEIE` writer - Transfer error interrupt enable
            pub struct TEIE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> TEIE_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: TEIE_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Transfer Error interrupt disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(TEIE_A::DISABLED)
                }
                ///Transfer Error interrupt enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(TEIE_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                    self.w
                }
            }
            ///Data transfer direction
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum DIR_A {
                ///0: Read from peripheral
                FROMPERIPHERAL = 0,
                ///1: Read from memory
                FROMMEMORY = 1,
            }
            impl From<DIR_A> for bool {
                #[inline(always)]
                fn from(variant: DIR_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `DIR` reader - Data transfer direction
            pub struct DIR_R(crate::FieldReader<bool, DIR_A>);
            impl DIR_R {
                pub(crate) fn new(bits: bool) -> Self {
                    DIR_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> DIR_A {
                    match self.bits {
                        false => DIR_A::FROMPERIPHERAL,
                        true => DIR_A::FROMMEMORY,
                    }
                }
                ///Checks if the value of the field is `FROMPERIPHERAL`
                #[inline(always)]
                pub fn is_from_peripheral(&self) -> bool {
                    **self == DIR_A::FROMPERIPHERAL
                }
                ///Checks if the value of the field is `FROMMEMORY`
                #[inline(always)]
                pub fn is_from_memory(&self) -> bool {
                    **self == DIR_A::FROMMEMORY
                }
            }
            impl core::ops::Deref for DIR_R {
                type Target = crate::FieldReader<bool, DIR_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `DIR` writer - Data transfer direction
            pub struct DIR_W<'a> {
                w: &'a mut W,
            }
            impl<'a> DIR_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: DIR_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Read from peripheral
                #[inline(always)]
                pub fn from_peripheral(self) -> &'a mut W {
                    self.variant(DIR_A::FROMPERIPHERAL)
                }
                ///Read from memory
                #[inline(always)]
                pub fn from_memory(self) -> &'a mut W {
                    self.variant(DIR_A::FROMMEMORY)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                    self.w
                }
            }
            ///Circular mode
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum CIRC_A {
                ///0: Circular buffer disabled
                DISABLED = 0,
                ///1: Circular buffer enabled
                ENABLED = 1,
            }
            impl From<CIRC_A> for bool {
                #[inline(always)]
                fn from(variant: CIRC_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `CIRC` reader - Circular mode
            pub struct CIRC_R(crate::FieldReader<bool, CIRC_A>);
            impl CIRC_R {
                pub(crate) fn new(bits: bool) -> Self {
                    CIRC_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> CIRC_A {
                    match self.bits {
                        false => CIRC_A::DISABLED,
                        true => CIRC_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == CIRC_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == CIRC_A::ENABLED
                }
            }
            impl core::ops::Deref for CIRC_R {
                type Target = crate::FieldReader<bool, CIRC_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `CIRC` writer - Circular mode
            pub struct CIRC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> CIRC_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: CIRC_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Circular buffer disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(CIRC_A::DISABLED)
                }
                ///Circular buffer enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(CIRC_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                    self.w
                }
            }
            ///Peripheral increment mode
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum PINC_A {
                ///0: Increment mode disabled
                DISABLED = 0,
                ///1: Increment mode enabled
                ENABLED = 1,
            }
            impl From<PINC_A> for bool {
                #[inline(always)]
                fn from(variant: PINC_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `PINC` reader - Peripheral increment mode
            pub struct PINC_R(crate::FieldReader<bool, PINC_A>);
            impl PINC_R {
                pub(crate) fn new(bits: bool) -> Self {
                    PINC_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> PINC_A {
                    match self.bits {
                        false => PINC_A::DISABLED,
                        true => PINC_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == PINC_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == PINC_A::ENABLED
                }
            }
            impl core::ops::Deref for PINC_R {
                type Target = crate::FieldReader<bool, PINC_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `PINC` writer - Peripheral increment mode
            pub struct PINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PINC_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: PINC_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Increment mode disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(PINC_A::DISABLED)
                }
                ///Increment mode enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(PINC_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                    self.w
                }
            }
            ///Memory increment mode
            pub type MINC_A = PINC_A;
            ///Field `MINC` reader - Memory increment mode
            pub type MINC_R = PINC_R;
            ///Field `MINC` writer - Memory increment mode
            pub struct MINC_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MINC_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: MINC_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Increment mode disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MINC_A::DISABLED)
                }
                ///Increment mode enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MINC_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                    self.w
                }
            }
            ///Peripheral size
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PSIZE_A {
                ///0: 8-bit size
                BITS8 = 0,
                ///1: 16-bit size
                BITS16 = 1,
                ///2: 32-bit size
                BITS32 = 2,
            }
            impl From<PSIZE_A> for u8 {
                #[inline(always)]
                fn from(variant: PSIZE_A) -> Self {
                    variant as _
                }
            }
            ///Field `PSIZE` reader - Peripheral size
            pub struct PSIZE_R(crate::FieldReader<u8, PSIZE_A>);
            impl PSIZE_R {
                pub(crate) fn new(bits: u8) -> Self {
                    PSIZE_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> Option<PSIZE_A> {
                    match self.bits {
                        0 => Some(PSIZE_A::BITS8),
                        1 => Some(PSIZE_A::BITS16),
                        2 => Some(PSIZE_A::BITS32),
                        _ => None,
                    }
                }
                ///Checks if the value of the field is `BITS8`
                #[inline(always)]
                pub fn is_bits8(&self) -> bool {
                    **self == PSIZE_A::BITS8
                }
                ///Checks if the value of the field is `BITS16`
                #[inline(always)]
                pub fn is_bits16(&self) -> bool {
                    **self == PSIZE_A::BITS16
                }
                ///Checks if the value of the field is `BITS32`
                #[inline(always)]
                pub fn is_bits32(&self) -> bool {
                    **self == PSIZE_A::BITS32
                }
            }
            impl core::ops::Deref for PSIZE_R {
                type Target = crate::FieldReader<u8, PSIZE_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `PSIZE` writer - Peripheral size
            pub struct PSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PSIZE_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: PSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                ///8-bit size
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS8)
                }
                ///16-bit size
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS16)
                }
                ///32-bit size
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(PSIZE_A::BITS32)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                    self.w
                }
            }
            ///Memory size
            pub type MSIZE_A = PSIZE_A;
            ///Field `MSIZE` reader - Memory size
            pub type MSIZE_R = PSIZE_R;
            ///Field `MSIZE` writer - Memory size
            pub struct MSIZE_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MSIZE_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: MSIZE_A) -> &'a mut W {
                    unsafe { self.bits(variant.into()) }
                }
                ///8-bit size
                #[inline(always)]
                pub fn bits8(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS8)
                }
                ///16-bit size
                #[inline(always)]
                pub fn bits16(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS16)
                }
                ///32-bit size
                #[inline(always)]
                pub fn bits32(self) -> &'a mut W {
                    self.variant(MSIZE_A::BITS32)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub unsafe fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                    self.w
                }
            }
            ///Channel Priority level
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            #[repr(u8)]
            pub enum PL_A {
                ///0: Low priority
                LOW = 0,
                ///1: Medium priority
                MEDIUM = 1,
                ///2: High priority
                HIGH = 2,
                ///3: Very high priority
                VERYHIGH = 3,
            }
            impl From<PL_A> for u8 {
                #[inline(always)]
                fn from(variant: PL_A) -> Self {
                    variant as _
                }
            }
            ///Field `PL` reader - Channel Priority level
            pub struct PL_R(crate::FieldReader<u8, PL_A>);
            impl PL_R {
                pub(crate) fn new(bits: u8) -> Self {
                    PL_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> PL_A {
                    match self.bits {
                        0 => PL_A::LOW,
                        1 => PL_A::MEDIUM,
                        2 => PL_A::HIGH,
                        3 => PL_A::VERYHIGH,
                        _ => unreachable!(),
                    }
                }
                ///Checks if the value of the field is `LOW`
                #[inline(always)]
                pub fn is_low(&self) -> bool {
                    **self == PL_A::LOW
                }
                ///Checks if the value of the field is `MEDIUM`
                #[inline(always)]
                pub fn is_medium(&self) -> bool {
                    **self == PL_A::MEDIUM
                }
                ///Checks if the value of the field is `HIGH`
                #[inline(always)]
                pub fn is_high(&self) -> bool {
                    **self == PL_A::HIGH
                }
                ///Checks if the value of the field is `VERYHIGH`
                #[inline(always)]
                pub fn is_very_high(&self) -> bool {
                    **self == PL_A::VERYHIGH
                }
            }
            impl core::ops::Deref for PL_R {
                type Target = crate::FieldReader<u8, PL_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `PL` writer - Channel Priority level
            pub struct PL_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PL_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: PL_A) -> &'a mut W {
                    self.bits(variant.into())
                }
                ///Low priority
                #[inline(always)]
                pub fn low(self) -> &'a mut W {
                    self.variant(PL_A::LOW)
                }
                ///Medium priority
                #[inline(always)]
                pub fn medium(self) -> &'a mut W {
                    self.variant(PL_A::MEDIUM)
                }
                ///High priority
                #[inline(always)]
                pub fn high(self) -> &'a mut W {
                    self.variant(PL_A::HIGH)
                }
                ///Very high priority
                #[inline(always)]
                pub fn very_high(self) -> &'a mut W {
                    self.variant(PL_A::VERYHIGH)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bits(self, value: u8) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                    self.w
                }
            }
            ///Memory to memory mode
            ///
            ///Value on reset: 0
            #[derive(Clone, Copy, Debug, PartialEq)]
            pub enum MEM2MEM_A {
                ///0: Memory to memory mode disabled
                DISABLED = 0,
                ///1: Memory to memory mode enabled
                ENABLED = 1,
            }
            impl From<MEM2MEM_A> for bool {
                #[inline(always)]
                fn from(variant: MEM2MEM_A) -> Self {
                    variant as u8 != 0
                }
            }
            ///Field `MEM2MEM` reader - Memory to memory mode
            pub struct MEM2MEM_R(crate::FieldReader<bool, MEM2MEM_A>);
            impl MEM2MEM_R {
                pub(crate) fn new(bits: bool) -> Self {
                    MEM2MEM_R(crate::FieldReader::new(bits))
                }
                ///Get enumerated values variant
                #[inline(always)]
                pub fn variant(&self) -> MEM2MEM_A {
                    match self.bits {
                        false => MEM2MEM_A::DISABLED,
                        true => MEM2MEM_A::ENABLED,
                    }
                }
                ///Checks if the value of the field is `DISABLED`
                #[inline(always)]
                pub fn is_disabled(&self) -> bool {
                    **self == MEM2MEM_A::DISABLED
                }
                ///Checks if the value of the field is `ENABLED`
                #[inline(always)]
                pub fn is_enabled(&self) -> bool {
                    **self == MEM2MEM_A::ENABLED
                }
            }
            impl core::ops::Deref for MEM2MEM_R {
                type Target = crate::FieldReader<bool, MEM2MEM_A>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `MEM2MEM` writer - Memory to memory mode
            pub struct MEM2MEM_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MEM2MEM_W<'a> {
                ///Writes `variant` to the field
                #[inline(always)]
                pub fn variant(self, variant: MEM2MEM_A) -> &'a mut W {
                    self.bit(variant.into())
                }
                ///Memory to memory mode disabled
                #[inline(always)]
                pub fn disabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::DISABLED)
                }
                ///Memory to memory mode enabled
                #[inline(always)]
                pub fn enabled(self) -> &'a mut W {
                    self.variant(MEM2MEM_A::ENABLED)
                }
                ///Sets the field bit
                #[inline(always)]
                pub fn set_bit(self) -> &'a mut W {
                    self.bit(true)
                }
                ///Clears the field bit
                #[inline(always)]
                pub fn clear_bit(self) -> &'a mut W {
                    self.bit(false)
                }
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bit(self, value: bool) -> &'a mut W {
                    self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                    self.w
                }
            }
            impl R {
                ///Bit 0 - Channel enable
                #[inline(always)]
                pub fn en(&self) -> EN_R {
                    EN_R::new((self.bits & 0x01) != 0)
                }
                ///Bit 1 - Transfer complete interrupt enable
                #[inline(always)]
                pub fn tcie(&self) -> TCIE_R {
                    TCIE_R::new(((self.bits >> 1) & 0x01) != 0)
                }
                ///Bit 2 - Half Transfer interrupt enable
                #[inline(always)]
                pub fn htie(&self) -> HTIE_R {
                    HTIE_R::new(((self.bits >> 2) & 0x01) != 0)
                }
                ///Bit 3 - Transfer error interrupt enable
                #[inline(always)]
                pub fn teie(&self) -> TEIE_R {
                    TEIE_R::new(((self.bits >> 3) & 0x01) != 0)
                }
                ///Bit 4 - Data transfer direction
                #[inline(always)]
                pub fn dir(&self) -> DIR_R {
                    DIR_R::new(((self.bits >> 4) & 0x01) != 0)
                }
                ///Bit 5 - Circular mode
                #[inline(always)]
                pub fn circ(&self) -> CIRC_R {
                    CIRC_R::new(((self.bits >> 5) & 0x01) != 0)
                }
                ///Bit 6 - Peripheral increment mode
                #[inline(always)]
                pub fn pinc(&self) -> PINC_R {
                    PINC_R::new(((self.bits >> 6) & 0x01) != 0)
                }
                ///Bit 7 - Memory increment mode
                #[inline(always)]
                pub fn minc(&self) -> MINC_R {
                    MINC_R::new(((self.bits >> 7) & 0x01) != 0)
                }
                ///Bits 8:9 - Peripheral size
                #[inline(always)]
                pub fn psize(&self) -> PSIZE_R {
                    PSIZE_R::new(((self.bits >> 8) & 0x03) as u8)
                }
                ///Bits 10:11 - Memory size
                #[inline(always)]
                pub fn msize(&self) -> MSIZE_R {
                    MSIZE_R::new(((self.bits >> 10) & 0x03) as u8)
                }
                ///Bits 12:13 - Channel Priority level
                #[inline(always)]
                pub fn pl(&self) -> PL_R {
                    PL_R::new(((self.bits >> 12) & 0x03) as u8)
                }
                ///Bit 14 - Memory to memory mode
                #[inline(always)]
                pub fn mem2mem(&self) -> MEM2MEM_R {
                    MEM2MEM_R::new(((self.bits >> 14) & 0x01) != 0)
                }
            }
            impl W {
                ///Bit 0 - Channel enable
                #[inline(always)]
                pub fn en(&mut self) -> EN_W {
                    EN_W { w: self }
                }
                ///Bit 1 - Transfer complete interrupt enable
                #[inline(always)]
                pub fn tcie(&mut self) -> TCIE_W {
                    TCIE_W { w: self }
                }
                ///Bit 2 - Half Transfer interrupt enable
                #[inline(always)]
                pub fn htie(&mut self) -> HTIE_W {
                    HTIE_W { w: self }
                }
                ///Bit 3 - Transfer error interrupt enable
                #[inline(always)]
                pub fn teie(&mut self) -> TEIE_W {
                    TEIE_W { w: self }
                }
                ///Bit 4 - Data transfer direction
                #[inline(always)]
                pub fn dir(&mut self) -> DIR_W {
                    DIR_W { w: self }
                }
                ///Bit 5 - Circular mode
                #[inline(always)]
                pub fn circ(&mut self) -> CIRC_W {
                    CIRC_W { w: self }
                }
                ///Bit 6 - Peripheral increment mode
                #[inline(always)]
                pub fn pinc(&mut self) -> PINC_W {
                    PINC_W { w: self }
                }
                ///Bit 7 - Memory increment mode
                #[inline(always)]
                pub fn minc(&mut self) -> MINC_W {
                    MINC_W { w: self }
                }
                ///Bits 8:9 - Peripheral size
                #[inline(always)]
                pub fn psize(&mut self) -> PSIZE_W {
                    PSIZE_W { w: self }
                }
                ///Bits 10:11 - Memory size
                #[inline(always)]
                pub fn msize(&mut self) -> MSIZE_W {
                    MSIZE_W { w: self }
                }
                ///Bits 12:13 - Channel Priority level
                #[inline(always)]
                pub fn pl(&mut self) -> PL_W {
                    PL_W { w: self }
                }
                ///Bit 14 - Memory to memory mode
                #[inline(always)]
                pub fn mem2mem(&mut self) -> MEM2MEM_W {
                    MEM2MEM_W { w: self }
                }
                ///Writes raw bits to the register.
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.0.bits(bits);
                    self
                }
            }
            ///DMA channel configuration register (DMA_CCR)
            ///
            ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
            ///
            ///For information about available fields see [cr](index.html) module
            pub struct CR_SPEC;
            impl crate::RegisterSpec for CR_SPEC {
                type Ux = u32;
            }
            ///`read()` method returns [cr::R](R) reader structure
            impl crate::Readable for CR_SPEC {
                type Reader = R;
            }
            ///`write(|w| ..)` method takes [cr::W](W) writer structure
            impl crate::Writable for CR_SPEC {
                type Writer = W;
            }
            ///`reset()` method sets CR to value 0
            impl crate::Resettable for CR_SPEC {
                #[inline(always)]
                fn reset_value() -> Self::Ux {
                    0
                }
            }
        }
        ///NDTR register accessor: an alias for `Reg<NDTR_SPEC>`
        pub type NDTR = crate::Reg<ndtr::NDTR_SPEC>;
        ///DMA channel 1 number of data register
        pub mod ndtr {
            ///Register `NDTR` reader
            pub struct R(crate::R<NDTR_SPEC>);
            impl core::ops::Deref for R {
                type Target = crate::R<NDTR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::convert::From<crate::R<NDTR_SPEC>> for R {
                fn from(reader: crate::R<NDTR_SPEC>) -> Self {
                    R(reader)
                }
            }
            ///Register `NDTR` writer
            pub struct W(crate::W<NDTR_SPEC>);
            impl core::ops::Deref for W {
                type Target = crate::W<NDTR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::ops::DerefMut for W {
                #[inline(always)]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
            }
            impl core::convert::From<crate::W<NDTR_SPEC>> for W {
                fn from(writer: crate::W<NDTR_SPEC>) -> Self {
                    W(writer)
                }
            }
            ///Field `NDT` reader - Number of data to transfer
            pub struct NDT_R(crate::FieldReader<u16, u16>);
            impl NDT_R {
                pub(crate) fn new(bits: u16) -> Self {
                    NDT_R(crate::FieldReader::new(bits))
                }
            }
            impl core::ops::Deref for NDT_R {
                type Target = crate::FieldReader<u16, u16>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `NDT` writer - Number of data to transfer
            pub struct NDT_W<'a> {
                w: &'a mut W,
            }
            impl<'a> NDT_W<'a> {
                ///Writes raw bits to the field
                #[inline(always)]
                pub fn bits(self, value: u16) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                    self.w
                }
            }
            impl R {
                ///Bits 0:15 - Number of data to transfer
                #[inline(always)]
                pub fn ndt(&self) -> NDT_R {
                    NDT_R::new((self.bits & 0xffff) as u16)
                }
            }
            impl W {
                ///Bits 0:15 - Number of data to transfer
                #[inline(always)]
                pub fn ndt(&mut self) -> NDT_W {
                    NDT_W { w: self }
                }
                ///Writes raw bits to the register.
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.0.bits(bits);
                    self
                }
            }
            ///DMA channel 1 number of data register
            ///
            ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
            ///
            ///For information about available fields see [ndtr](index.html) module
            pub struct NDTR_SPEC;
            impl crate::RegisterSpec for NDTR_SPEC {
                type Ux = u32;
            }
            ///`read()` method returns [ndtr::R](R) reader structure
            impl crate::Readable for NDTR_SPEC {
                type Reader = R;
            }
            ///`write(|w| ..)` method takes [ndtr::W](W) writer structure
            impl crate::Writable for NDTR_SPEC {
                type Writer = W;
            }
            ///`reset()` method sets NDTR to value 0
            impl crate::Resettable for NDTR_SPEC {
                #[inline(always)]
                fn reset_value() -> Self::Ux {
                    0
                }
            }
        }
        ///PAR register accessor: an alias for `Reg<PAR_SPEC>`
        pub type PAR = crate::Reg<par::PAR_SPEC>;
        ///DMA channel 1 peripheral address register
        pub mod par {
            ///Register `PAR` reader
            pub struct R(crate::R<PAR_SPEC>);
            impl core::ops::Deref for R {
                type Target = crate::R<PAR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::convert::From<crate::R<PAR_SPEC>> for R {
                fn from(reader: crate::R<PAR_SPEC>) -> Self {
                    R(reader)
                }
            }
            ///Register `PAR` writer
            pub struct W(crate::W<PAR_SPEC>);
            impl core::ops::Deref for W {
                type Target = crate::W<PAR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::ops::DerefMut for W {
                #[inline(always)]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
            }
            impl core::convert::From<crate::W<PAR_SPEC>> for W {
                fn from(writer: crate::W<PAR_SPEC>) -> Self {
                    W(writer)
                }
            }
            ///Field `PA` reader - Peripheral address
            pub struct PA_R(crate::FieldReader<u32, u32>);
            impl PA_R {
                pub(crate) fn new(bits: u32) -> Self {
                    PA_R(crate::FieldReader::new(bits))
                }
            }
            impl core::ops::Deref for PA_R {
                type Target = crate::FieldReader<u32, u32>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `PA` writer - Peripheral address
            pub struct PA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> PA_W<'a> {
                ///Writes raw bits to the field
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                ///Bits 0:31 - Peripheral address
                #[inline(always)]
                pub fn pa(&self) -> PA_R {
                    PA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                ///Bits 0:31 - Peripheral address
                #[inline(always)]
                pub fn pa(&mut self) -> PA_W {
                    PA_W { w: self }
                }
                ///Writes raw bits to the register.
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.0.bits(bits);
                    self
                }
            }
            ///DMA channel 1 peripheral address register
            ///
            ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
            ///
            ///For information about available fields see [par](index.html) module
            pub struct PAR_SPEC;
            impl crate::RegisterSpec for PAR_SPEC {
                type Ux = u32;
            }
            ///`read()` method returns [par::R](R) reader structure
            impl crate::Readable for PAR_SPEC {
                type Reader = R;
            }
            ///`write(|w| ..)` method takes [par::W](W) writer structure
            impl crate::Writable for PAR_SPEC {
                type Writer = W;
            }
            ///`reset()` method sets PAR to value 0
            impl crate::Resettable for PAR_SPEC {
                #[inline(always)]
                fn reset_value() -> Self::Ux {
                    0
                }
            }
        }
        ///MAR register accessor: an alias for `Reg<MAR_SPEC>`
        pub type MAR = crate::Reg<mar::MAR_SPEC>;
        ///DMA channel 1 memory address register
        pub mod mar {
            ///Register `MAR` reader
            pub struct R(crate::R<MAR_SPEC>);
            impl core::ops::Deref for R {
                type Target = crate::R<MAR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::convert::From<crate::R<MAR_SPEC>> for R {
                fn from(reader: crate::R<MAR_SPEC>) -> Self {
                    R(reader)
                }
            }
            ///Register `MAR` writer
            pub struct W(crate::W<MAR_SPEC>);
            impl core::ops::Deref for W {
                type Target = crate::W<MAR_SPEC>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            impl core::ops::DerefMut for W {
                #[inline(always)]
                fn deref_mut(&mut self) -> &mut Self::Target {
                    &mut self.0
                }
            }
            impl core::convert::From<crate::W<MAR_SPEC>> for W {
                fn from(writer: crate::W<MAR_SPEC>) -> Self {
                    W(writer)
                }
            }
            ///Field `MA` reader - Memory address
            pub struct MA_R(crate::FieldReader<u32, u32>);
            impl MA_R {
                pub(crate) fn new(bits: u32) -> Self {
                    MA_R(crate::FieldReader::new(bits))
                }
            }
            impl core::ops::Deref for MA_R {
                type Target = crate::FieldReader<u32, u32>;
                #[inline(always)]
                fn deref(&self) -> &Self::Target {
                    &self.0
                }
            }
            ///Field `MA` writer - Memory address
            pub struct MA_W<'a> {
                w: &'a mut W,
            }
            impl<'a> MA_W<'a> {
                ///Writes raw bits to the field
                #[inline(always)]
                pub unsafe fn bits(self, value: u32) -> &'a mut W {
                    self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                    self.w
                }
            }
            impl R {
                ///Bits 0:31 - Memory address
                #[inline(always)]
                pub fn ma(&self) -> MA_R {
                    MA_R::new((self.bits & 0xffff_ffff) as u32)
                }
            }
            impl W {
                ///Bits 0:31 - Memory address
                #[inline(always)]
                pub fn ma(&mut self) -> MA_W {
                    MA_W { w: self }
                }
                ///Writes raw bits to the register.
                pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                    self.0.bits(bits);
                    self
                }
            }
            ///DMA channel 1 memory address register
            ///
            ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
            ///
            ///For information about available fields see [mar](index.html) module
            pub struct MAR_SPEC;
            impl crate::RegisterSpec for MAR_SPEC {
                type Ux = u32;
            }
            ///`read()` method returns [mar::R](R) reader structure
            impl crate::Readable for MAR_SPEC {
                type Reader = R;
            }
            ///`write(|w| ..)` method takes [mar::W](W) writer structure
            impl crate::Writable for MAR_SPEC {
                type Writer = W;
            }
            ///`reset()` method sets MAR to value 0
            impl crate::Resettable for MAR_SPEC {
                #[inline(always)]
                fn reset_value() -> Self::Ux {
                    0
                }
            }
        }
    }
    ///ISR register accessor: an alias for `Reg<ISR_SPEC>`
    pub type ISR = crate::Reg<isr::ISR_SPEC>;
    ///DMA interrupt status register (DMA_ISR)
    pub mod isr {
        ///Register `ISR` reader
        pub struct R(crate::R<ISR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ISR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ISR_SPEC>> for R {
            fn from(reader: crate::R<ISR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Channel 1 Global interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum GIF1_A {
            ///0: No transfer error, half event, complete event
            NOEVENT = 0,
            ///1: A transfer error, half event or complete event has occured
            EVENT = 1,
        }
        impl From<GIF1_A> for bool {
            #[inline(always)]
            fn from(variant: GIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `GIF1` reader - Channel 1 Global interrupt flag
        pub struct GIF1_R(crate::FieldReader<bool, GIF1_A>);
        impl GIF1_R {
            pub(crate) fn new(bits: bool) -> Self {
                GIF1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> GIF1_A {
                match self.bits {
                    false => GIF1_A::NOEVENT,
                    true => GIF1_A::EVENT,
                }
            }
            ///Checks if the value of the field is `NOEVENT`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                **self == GIF1_A::NOEVENT
            }
            ///Checks if the value of the field is `EVENT`
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                **self == GIF1_A::EVENT
            }
        }
        impl core::ops::Deref for GIF1_R {
            type Target = crate::FieldReader<bool, GIF1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Channel 1 Transfer Complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIF1_A {
            ///0: No transfer complete event
            NOTCOMPLETE = 0,
            ///1: A transfer complete event has occured
            COMPLETE = 1,
        }
        impl From<TCIF1_A> for bool {
            #[inline(always)]
            fn from(variant: TCIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TCIF1` reader - Channel 1 Transfer Complete flag
        pub struct TCIF1_R(crate::FieldReader<bool, TCIF1_A>);
        impl TCIF1_R {
            pub(crate) fn new(bits: bool) -> Self {
                TCIF1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIF1_A {
                match self.bits {
                    false => TCIF1_A::NOTCOMPLETE,
                    true => TCIF1_A::COMPLETE,
                }
            }
            ///Checks if the value of the field is `NOTCOMPLETE`
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                **self == TCIF1_A::NOTCOMPLETE
            }
            ///Checks if the value of the field is `COMPLETE`
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                **self == TCIF1_A::COMPLETE
            }
        }
        impl core::ops::Deref for TCIF1_R {
            type Target = crate::FieldReader<bool, TCIF1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Channel 1 Half Transfer Complete flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HTIF1_A {
            ///0: No half transfer event
            NOTHALF = 0,
            ///1: A half transfer event has occured
            HALF = 1,
        }
        impl From<HTIF1_A> for bool {
            #[inline(always)]
            fn from(variant: HTIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HTIF1` reader - Channel 1 Half Transfer Complete flag
        pub struct HTIF1_R(crate::FieldReader<bool, HTIF1_A>);
        impl HTIF1_R {
            pub(crate) fn new(bits: bool) -> Self {
                HTIF1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HTIF1_A {
                match self.bits {
                    false => HTIF1_A::NOTHALF,
                    true => HTIF1_A::HALF,
                }
            }
            ///Checks if the value of the field is `NOTHALF`
            #[inline(always)]
            pub fn is_not_half(&self) -> bool {
                **self == HTIF1_A::NOTHALF
            }
            ///Checks if the value of the field is `HALF`
            #[inline(always)]
            pub fn is_half(&self) -> bool {
                **self == HTIF1_A::HALF
            }
        }
        impl core::ops::Deref for HTIF1_R {
            type Target = crate::FieldReader<bool, HTIF1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Channel 1 Transfer Error flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEIF1_A {
            ///0: No transfer error
            NOERROR = 0,
            ///1: A transfer error has occured
            ERROR = 1,
        }
        impl From<TEIF1_A> for bool {
            #[inline(always)]
            fn from(variant: TEIF1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TEIF1` reader - Channel 1 Transfer Error flag
        pub struct TEIF1_R(crate::FieldReader<bool, TEIF1_A>);
        impl TEIF1_R {
            pub(crate) fn new(bits: bool) -> Self {
                TEIF1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TEIF1_A {
                match self.bits {
                    false => TEIF1_A::NOERROR,
                    true => TEIF1_A::ERROR,
                }
            }
            ///Checks if the value of the field is `NOERROR`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                **self == TEIF1_A::NOERROR
            }
            ///Checks if the value of the field is `ERROR`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                **self == TEIF1_A::ERROR
            }
        }
        impl core::ops::Deref for TEIF1_R {
            type Target = crate::FieldReader<bool, TEIF1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Channel 2 Global interrupt flag
        pub type GIF2_A = GIF1_A;
        ///Field `GIF2` reader - Channel 2 Global interrupt flag
        pub type GIF2_R = GIF1_R;
        ///Channel 2 Transfer Complete flag
        pub type TCIF2_A = TCIF1_A;
        ///Field `TCIF2` reader - Channel 2 Transfer Complete flag
        pub type TCIF2_R = TCIF1_R;
        ///Channel 2 Half Transfer Complete flag
        pub type HTIF2_A = HTIF1_A;
        ///Field `HTIF2` reader - Channel 2 Half Transfer Complete flag
        pub type HTIF2_R = HTIF1_R;
        ///Channel 2 Transfer Error flag
        pub type TEIF2_A = TEIF1_A;
        ///Field `TEIF2` reader - Channel 2 Transfer Error flag
        pub type TEIF2_R = TEIF1_R;
        ///Channel 3 Global interrupt flag
        pub type GIF3_A = GIF1_A;
        ///Field `GIF3` reader - Channel 3 Global interrupt flag
        pub type GIF3_R = GIF1_R;
        ///Channel 3 Transfer Complete flag
        pub type TCIF3_A = TCIF1_A;
        ///Field `TCIF3` reader - Channel 3 Transfer Complete flag
        pub type TCIF3_R = TCIF1_R;
        ///Channel 3 Half Transfer Complete flag
        pub type HTIF3_A = HTIF1_A;
        ///Field `HTIF3` reader - Channel 3 Half Transfer Complete flag
        pub type HTIF3_R = HTIF1_R;
        ///Channel 3 Transfer Error flag
        pub type TEIF3_A = TEIF1_A;
        ///Field `TEIF3` reader - Channel 3 Transfer Error flag
        pub type TEIF3_R = TEIF1_R;
        ///Channel 4 Global interrupt flag
        pub type GIF4_A = GIF1_A;
        ///Field `GIF4` reader - Channel 4 Global interrupt flag
        pub type GIF4_R = GIF1_R;
        ///Channel 4 Transfer Complete flag
        pub type TCIF4_A = TCIF1_A;
        ///Field `TCIF4` reader - Channel 4 Transfer Complete flag
        pub type TCIF4_R = TCIF1_R;
        ///Channel 4 Half Transfer Complete flag
        pub type HTIF4_A = HTIF1_A;
        ///Field `HTIF4` reader - Channel 4 Half Transfer Complete flag
        pub type HTIF4_R = HTIF1_R;
        ///Channel 4 Transfer Error flag
        pub type TEIF4_A = TEIF1_A;
        ///Field `TEIF4` reader - Channel 4 Transfer Error flag
        pub type TEIF4_R = TEIF1_R;
        ///Channel 5 Global interrupt flag
        pub type GIF5_A = GIF1_A;
        ///Field `GIF5` reader - Channel 5 Global interrupt flag
        pub type GIF5_R = GIF1_R;
        ///Channel 5 Transfer Complete flag
        pub type TCIF5_A = TCIF1_A;
        ///Field `TCIF5` reader - Channel 5 Transfer Complete flag
        pub type TCIF5_R = TCIF1_R;
        ///Channel 5 Half Transfer Complete flag
        pub type HTIF5_A = HTIF1_A;
        ///Field `HTIF5` reader - Channel 5 Half Transfer Complete flag
        pub type HTIF5_R = HTIF1_R;
        ///Channel 5 Transfer Error flag
        pub type TEIF5_A = TEIF1_A;
        ///Field `TEIF5` reader - Channel 5 Transfer Error flag
        pub type TEIF5_R = TEIF1_R;
        ///Channel 6 Global interrupt flag
        pub type GIF6_A = GIF1_A;
        ///Field `GIF6` reader - Channel 6 Global interrupt flag
        pub type GIF6_R = GIF1_R;
        ///Channel 6 Transfer Complete flag
        pub type TCIF6_A = TCIF1_A;
        ///Field `TCIF6` reader - Channel 6 Transfer Complete flag
        pub type TCIF6_R = TCIF1_R;
        ///Channel 6 Half Transfer Complete flag
        pub type HTIF6_A = HTIF1_A;
        ///Field `HTIF6` reader - Channel 6 Half Transfer Complete flag
        pub type HTIF6_R = HTIF1_R;
        ///Channel 6 Transfer Error flag
        pub type TEIF6_A = TEIF1_A;
        ///Field `TEIF6` reader - Channel 6 Transfer Error flag
        pub type TEIF6_R = TEIF1_R;
        ///Channel 7 Global interrupt flag
        pub type GIF7_A = GIF1_A;
        ///Field `GIF7` reader - Channel 7 Global interrupt flag
        pub type GIF7_R = GIF1_R;
        ///Channel 7 Transfer Complete flag
        pub type TCIF7_A = TCIF1_A;
        ///Field `TCIF7` reader - Channel 7 Transfer Complete flag
        pub type TCIF7_R = TCIF1_R;
        ///Channel 7 Half Transfer Complete flag
        pub type HTIF7_A = HTIF1_A;
        ///Field `HTIF7` reader - Channel 7 Half Transfer Complete flag
        pub type HTIF7_R = HTIF1_R;
        ///Channel 7 Transfer Error flag
        pub type TEIF7_A = TEIF1_A;
        ///Field `TEIF7` reader - Channel 7 Transfer Error flag
        pub type TEIF7_R = TEIF1_R;
        impl R {
            ///Bit 0 - Channel 1 Global interrupt flag
            #[inline(always)]
            pub fn gif1(&self) -> GIF1_R {
                GIF1_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Channel 1 Transfer Complete flag
            #[inline(always)]
            pub fn tcif1(&self) -> TCIF1_R {
                TCIF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Channel 1 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif1(&self) -> HTIF1_R {
                HTIF1_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Channel 1 Transfer Error flag
            #[inline(always)]
            pub fn teif1(&self) -> TEIF1_R {
                TEIF1_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Channel 2 Global interrupt flag
            #[inline(always)]
            pub fn gif2(&self) -> GIF2_R {
                GIF2_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Channel 2 Transfer Complete flag
            #[inline(always)]
            pub fn tcif2(&self) -> TCIF2_R {
                TCIF2_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Channel 2 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif2(&self) -> HTIF2_R {
                HTIF2_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Channel 2 Transfer Error flag
            #[inline(always)]
            pub fn teif2(&self) -> TEIF2_R {
                TEIF2_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Channel 3 Global interrupt flag
            #[inline(always)]
            pub fn gif3(&self) -> GIF3_R {
                GIF3_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Channel 3 Transfer Complete flag
            #[inline(always)]
            pub fn tcif3(&self) -> TCIF3_R {
                TCIF3_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Channel 3 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif3(&self) -> HTIF3_R {
                HTIF3_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Channel 3 Transfer Error flag
            #[inline(always)]
            pub fn teif3(&self) -> TEIF3_R {
                TEIF3_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Channel 4 Global interrupt flag
            #[inline(always)]
            pub fn gif4(&self) -> GIF4_R {
                GIF4_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - Channel 4 Transfer Complete flag
            #[inline(always)]
            pub fn tcif4(&self) -> TCIF4_R {
                TCIF4_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Channel 4 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif4(&self) -> HTIF4_R {
                HTIF4_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 15 - Channel 4 Transfer Error flag
            #[inline(always)]
            pub fn teif4(&self) -> TEIF4_R {
                TEIF4_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - Channel 5 Global interrupt flag
            #[inline(always)]
            pub fn gif5(&self) -> GIF5_R {
                GIF5_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - Channel 5 Transfer Complete flag
            #[inline(always)]
            pub fn tcif5(&self) -> TCIF5_R {
                TCIF5_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - Channel 5 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif5(&self) -> HTIF5_R {
                HTIF5_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bit 19 - Channel 5 Transfer Error flag
            #[inline(always)]
            pub fn teif5(&self) -> TEIF5_R {
                TEIF5_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 20 - Channel 6 Global interrupt flag
            #[inline(always)]
            pub fn gif6(&self) -> GIF6_R {
                GIF6_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            ///Bit 21 - Channel 6 Transfer Complete flag
            #[inline(always)]
            pub fn tcif6(&self) -> TCIF6_R {
                TCIF6_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            ///Bit 22 - Channel 6 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif6(&self) -> HTIF6_R {
                HTIF6_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bit 23 - Channel 6 Transfer Error flag
            #[inline(always)]
            pub fn teif6(&self) -> TEIF6_R {
                TEIF6_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            ///Bit 24 - Channel 7 Global interrupt flag
            #[inline(always)]
            pub fn gif7(&self) -> GIF7_R {
                GIF7_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            ///Bit 25 - Channel 7 Transfer Complete flag
            #[inline(always)]
            pub fn tcif7(&self) -> TCIF7_R {
                TCIF7_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            ///Bit 26 - Channel 7 Half Transfer Complete flag
            #[inline(always)]
            pub fn htif7(&self) -> HTIF7_R {
                HTIF7_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            ///Bit 27 - Channel 7 Transfer Error flag
            #[inline(always)]
            pub fn teif7(&self) -> TEIF7_R {
                TEIF7_R::new(((self.bits >> 27) & 0x01) != 0)
            }
        }
        ///DMA interrupt status register (DMA_ISR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [isr](index.html) module
        pub struct ISR_SPEC;
        impl crate::RegisterSpec for ISR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [isr::R](R) reader structure
        impl crate::Readable for ISR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ISR to value 0
        impl crate::Resettable for ISR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///IFCR register accessor: an alias for `Reg<IFCR_SPEC>`
    pub type IFCR = crate::Reg<ifcr::IFCR_SPEC>;
    ///DMA interrupt flag clear register (DMA_IFCR)
    pub mod ifcr {
        ///Register `IFCR` writer
        pub struct W(crate::W<IFCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IFCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<IFCR_SPEC>> for W {
            fn from(writer: crate::W<IFCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Channel 1 Global interrupt clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CGIF1_AW {
            ///1: Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            CLEAR = 1,
        }
        impl From<CGIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CGIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CGIF1` writer - Channel 1 Global interrupt clear
        pub struct CGIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF1_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Channel 2 Global interrupt clear
        pub type CGIF2_AW = CGIF1_AW;
        ///Field `CGIF2` writer - Channel 2 Global interrupt clear
        pub struct CGIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF2_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Channel 3 Global interrupt clear
        pub type CGIF3_AW = CGIF1_AW;
        ///Field `CGIF3` writer - Channel 3 Global interrupt clear
        pub struct CGIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF3_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Channel 4 Global interrupt clear
        pub type CGIF4_AW = CGIF1_AW;
        ///Field `CGIF4` writer - Channel 4 Global interrupt clear
        pub struct CGIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF4_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Channel 5 Global interrupt clear
        pub type CGIF5_AW = CGIF1_AW;
        ///Field `CGIF5` writer - Channel 5 Global interrupt clear
        pub struct CGIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF5_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Channel 6 Global interrupt clear
        pub type CGIF6_AW = CGIF1_AW;
        ///Field `CGIF6` writer - Channel 6 Global interrupt clear
        pub struct CGIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF6_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///Channel 7 Global interrupt clear
        pub type CGIF7_AW = CGIF1_AW;
        ///Field `CGIF7` writer - Channel 7 Global interrupt clear
        pub struct CGIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CGIF7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CGIF7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the GIF, TEIF, HTIF, TCIF flags in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CGIF7_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | ((value as u32 & 0x01) << 24);
                self.w
            }
        }
        ///Channel 1 Transfer Complete clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTCIF1_AW {
            ///1: Clears the TCIF flag in the ISR register
            CLEAR = 1,
        }
        impl From<CTCIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CTCIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTCIF1` writer - Channel 1 Transfer Complete clear
        pub struct CTCIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF1_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Channel 2 Transfer Complete clear
        pub type CTCIF2_AW = CTCIF1_AW;
        ///Field `CTCIF2` writer - Channel 2 Transfer Complete clear
        pub struct CTCIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF2_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Channel 3 Transfer Complete clear
        pub type CTCIF3_AW = CTCIF1_AW;
        ///Field `CTCIF3` writer - Channel 3 Transfer Complete clear
        pub struct CTCIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF3_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Channel 4 Transfer Complete clear
        pub type CTCIF4_AW = CTCIF1_AW;
        ///Field `CTCIF4` writer - Channel 4 Transfer Complete clear
        pub struct CTCIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF4_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Channel 5 Transfer Complete clear
        pub type CTCIF5_AW = CTCIF1_AW;
        ///Field `CTCIF5` writer - Channel 5 Transfer Complete clear
        pub struct CTCIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF5_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///Channel 6 Transfer Complete clear
        pub type CTCIF6_AW = CTCIF1_AW;
        ///Field `CTCIF6` writer - Channel 6 Transfer Complete clear
        pub struct CTCIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF6_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | ((value as u32 & 0x01) << 21);
                self.w
            }
        }
        ///Channel 7 Transfer Complete clear
        pub type CTCIF7_AW = CTCIF1_AW;
        ///Field `CTCIF7` writer - Channel 7 Transfer Complete clear
        pub struct CTCIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTCIF7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTCIF7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TCIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTCIF7_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | ((value as u32 & 0x01) << 25);
                self.w
            }
        }
        ///Channel 1 Half Transfer clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CHTIF1_AW {
            ///1: Clears the HTIF flag in the ISR register
            CLEAR = 1,
        }
        impl From<CHTIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CHTIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CHTIF1` writer - Channel 1 Half Transfer clear
        pub struct CHTIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF1_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Channel 2 Half Transfer clear
        pub type CHTIF2_AW = CHTIF1_AW;
        ///Field `CHTIF2` writer - Channel 2 Half Transfer clear
        pub struct CHTIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF2_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Channel 3 Half Transfer clear
        pub type CHTIF3_AW = CHTIF1_AW;
        ///Field `CHTIF3` writer - Channel 3 Half Transfer clear
        pub struct CHTIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF3_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Channel 4 Half Transfer clear
        pub type CHTIF4_AW = CHTIF1_AW;
        ///Field `CHTIF4` writer - Channel 4 Half Transfer clear
        pub struct CHTIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF4_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Channel 5 Half Transfer clear
        pub type CHTIF5_AW = CHTIF1_AW;
        ///Field `CHTIF5` writer - Channel 5 Half Transfer clear
        pub struct CHTIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF5_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///Channel 6 Half Transfer clear
        pub type CHTIF6_AW = CHTIF1_AW;
        ///Field `CHTIF6` writer - Channel 6 Half Transfer clear
        pub struct CHTIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF6_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Channel 7 Half Transfer clear
        pub type CHTIF7_AW = CHTIF1_AW;
        ///Field `CHTIF7` writer - Channel 7 Half Transfer clear
        pub struct CHTIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CHTIF7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CHTIF7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the HTIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CHTIF7_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | ((value as u32 & 0x01) << 26);
                self.w
            }
        }
        ///Channel 1 Transfer Error clear
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTEIF1_AW {
            ///1: Clears the TEIF flag in the ISR register
            CLEAR = 1,
        }
        impl From<CTEIF1_AW> for bool {
            #[inline(always)]
            fn from(variant: CTEIF1_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTEIF1` writer - Channel 1 Transfer Error clear
        pub struct CTEIF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF1_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Channel 2 Transfer Error clear
        pub type CTEIF2_AW = CTEIF1_AW;
        ///Field `CTEIF2` writer - Channel 2 Transfer Error clear
        pub struct CTEIF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF2_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Channel 3 Transfer Error clear
        pub type CTEIF3_AW = CTEIF1_AW;
        ///Field `CTEIF3` writer - Channel 3 Transfer Error clear
        pub struct CTEIF3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF3_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF3_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Channel 4 Transfer Error clear
        pub type CTEIF4_AW = CTEIF1_AW;
        ///Field `CTEIF4` writer - Channel 4 Transfer Error clear
        pub struct CTEIF4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF4_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF4_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Channel 5 Transfer Error clear
        pub type CTEIF5_AW = CTEIF1_AW;
        ///Field `CTEIF5` writer - Channel 5 Transfer Error clear
        pub struct CTEIF5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF5_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF5_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///Channel 6 Transfer Error clear
        pub type CTEIF6_AW = CTEIF1_AW;
        ///Field `CTEIF6` writer - Channel 6 Transfer Error clear
        pub struct CTEIF6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF6_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF6_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        ///Channel 7 Transfer Error clear
        pub type CTEIF7_AW = CTEIF1_AW;
        ///Field `CTEIF7` writer - Channel 7 Transfer Error clear
        pub struct CTEIF7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTEIF7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTEIF7_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clears the TEIF flag in the ISR register
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTEIF7_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        impl W {
            ///Bit 0 - Channel 1 Global interrupt clear
            #[inline(always)]
            pub fn cgif1(&mut self) -> CGIF1_W {
                CGIF1_W { w: self }
            }
            ///Bit 4 - Channel 2 Global interrupt clear
            #[inline(always)]
            pub fn cgif2(&mut self) -> CGIF2_W {
                CGIF2_W { w: self }
            }
            ///Bit 8 - Channel 3 Global interrupt clear
            #[inline(always)]
            pub fn cgif3(&mut self) -> CGIF3_W {
                CGIF3_W { w: self }
            }
            ///Bit 12 - Channel 4 Global interrupt clear
            #[inline(always)]
            pub fn cgif4(&mut self) -> CGIF4_W {
                CGIF4_W { w: self }
            }
            ///Bit 16 - Channel 5 Global interrupt clear
            #[inline(always)]
            pub fn cgif5(&mut self) -> CGIF5_W {
                CGIF5_W { w: self }
            }
            ///Bit 20 - Channel 6 Global interrupt clear
            #[inline(always)]
            pub fn cgif6(&mut self) -> CGIF6_W {
                CGIF6_W { w: self }
            }
            ///Bit 24 - Channel 7 Global interrupt clear
            #[inline(always)]
            pub fn cgif7(&mut self) -> CGIF7_W {
                CGIF7_W { w: self }
            }
            ///Bit 1 - Channel 1 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif1(&mut self) -> CTCIF1_W {
                CTCIF1_W { w: self }
            }
            ///Bit 5 - Channel 2 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif2(&mut self) -> CTCIF2_W {
                CTCIF2_W { w: self }
            }
            ///Bit 9 - Channel 3 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif3(&mut self) -> CTCIF3_W {
                CTCIF3_W { w: self }
            }
            ///Bit 13 - Channel 4 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif4(&mut self) -> CTCIF4_W {
                CTCIF4_W { w: self }
            }
            ///Bit 17 - Channel 5 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif5(&mut self) -> CTCIF5_W {
                CTCIF5_W { w: self }
            }
            ///Bit 21 - Channel 6 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif6(&mut self) -> CTCIF6_W {
                CTCIF6_W { w: self }
            }
            ///Bit 25 - Channel 7 Transfer Complete clear
            #[inline(always)]
            pub fn ctcif7(&mut self) -> CTCIF7_W {
                CTCIF7_W { w: self }
            }
            ///Bit 2 - Channel 1 Half Transfer clear
            #[inline(always)]
            pub fn chtif1(&mut self) -> CHTIF1_W {
                CHTIF1_W { w: self }
            }
            ///Bit 6 - Channel 2 Half Transfer clear
            #[inline(always)]
            pub fn chtif2(&mut self) -> CHTIF2_W {
                CHTIF2_W { w: self }
            }
            ///Bit 10 - Channel 3 Half Transfer clear
            #[inline(always)]
            pub fn chtif3(&mut self) -> CHTIF3_W {
                CHTIF3_W { w: self }
            }
            ///Bit 14 - Channel 4 Half Transfer clear
            #[inline(always)]
            pub fn chtif4(&mut self) -> CHTIF4_W {
                CHTIF4_W { w: self }
            }
            ///Bit 18 - Channel 5 Half Transfer clear
            #[inline(always)]
            pub fn chtif5(&mut self) -> CHTIF5_W {
                CHTIF5_W { w: self }
            }
            ///Bit 22 - Channel 6 Half Transfer clear
            #[inline(always)]
            pub fn chtif6(&mut self) -> CHTIF6_W {
                CHTIF6_W { w: self }
            }
            ///Bit 26 - Channel 7 Half Transfer clear
            #[inline(always)]
            pub fn chtif7(&mut self) -> CHTIF7_W {
                CHTIF7_W { w: self }
            }
            ///Bit 3 - Channel 1 Transfer Error clear
            #[inline(always)]
            pub fn cteif1(&mut self) -> CTEIF1_W {
                CTEIF1_W { w: self }
            }
            ///Bit 7 - Channel 2 Transfer Error clear
            #[inline(always)]
            pub fn cteif2(&mut self) -> CTEIF2_W {
                CTEIF2_W { w: self }
            }
            ///Bit 11 - Channel 3 Transfer Error clear
            #[inline(always)]
            pub fn cteif3(&mut self) -> CTEIF3_W {
                CTEIF3_W { w: self }
            }
            ///Bit 15 - Channel 4 Transfer Error clear
            #[inline(always)]
            pub fn cteif4(&mut self) -> CTEIF4_W {
                CTEIF4_W { w: self }
            }
            ///Bit 19 - Channel 5 Transfer Error clear
            #[inline(always)]
            pub fn cteif5(&mut self) -> CTEIF5_W {
                CTEIF5_W { w: self }
            }
            ///Bit 23 - Channel 6 Transfer Error clear
            #[inline(always)]
            pub fn cteif6(&mut self) -> CTEIF6_W {
                CTEIF6_W { w: self }
            }
            ///Bit 27 - Channel 7 Transfer Error clear
            #[inline(always)]
            pub fn cteif7(&mut self) -> CTEIF7_W {
                CTEIF7_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA interrupt flag clear register (DMA_IFCR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ifcr](index.html) module
        pub struct IFCR_SPEC;
        impl crate::RegisterSpec for IFCR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ifcr::W](W) writer structure
        impl crate::Writable for IFCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets IFCR to value 0
        impl crate::Resettable for IFCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///DMA controller
pub struct DMA2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DMA2 {}
impl DMA2 {
    ///Pointer to the register block
    pub const PTR: *const dma1::RegisterBlock = 0x4002_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dma1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DMA2 {
    type Target = dma1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DMA2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DMA2").finish()
    }
}
///Real time clock
pub struct RTC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for RTC {}
impl RTC {
    ///Pointer to the register block
    pub const PTR: *const rtc::RegisterBlock = 0x4000_2800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const rtc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for RTC {
    type Target = rtc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for RTC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("RTC").finish()
    }
}
///Real time clock
pub mod rtc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - RTC Control Register High
        pub crh: crate::Reg<crh::CRH_SPEC>,
        ///0x04 - RTC Control Register Low
        pub crl: crate::Reg<crl::CRL_SPEC>,
        ///0x08 - RTC Prescaler Load Register High
        pub prlh: crate::Reg<prlh::PRLH_SPEC>,
        ///0x0c - RTC Prescaler Load Register Low
        pub prll: crate::Reg<prll::PRLL_SPEC>,
        ///0x10 - RTC Prescaler Divider Register High
        pub divh: crate::Reg<divh::DIVH_SPEC>,
        ///0x14 - RTC Prescaler Divider Register Low
        pub divl: crate::Reg<divl::DIVL_SPEC>,
        ///0x18 - RTC Counter Register High
        pub cnth: crate::Reg<cnth::CNTH_SPEC>,
        ///0x1c - RTC Counter Register Low
        pub cntl: crate::Reg<cntl::CNTL_SPEC>,
        ///0x20 - RTC Alarm Register High
        pub alrh: crate::Reg<alrh::ALRH_SPEC>,
        ///0x24 - RTC Alarm Register Low
        pub alrl: crate::Reg<alrl::ALRL_SPEC>,
    }
    ///CRH register accessor: an alias for `Reg<CRH_SPEC>`
    pub type CRH = crate::Reg<crh::CRH_SPEC>;
    ///RTC Control Register High
    pub mod crh {
        ///Register `CRH` reader
        pub struct R(crate::R<CRH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CRH_SPEC>> for R {
            fn from(reader: crate::R<CRH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRH` writer
        pub struct W(crate::W<CRH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CRH_SPEC>> for W {
            fn from(writer: crate::W<CRH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SECIE` reader - Second interrupt Enable
        pub struct SECIE_R(crate::FieldReader<bool, bool>);
        impl SECIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                SECIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SECIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SECIE` writer - Second interrupt Enable
        pub struct SECIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `ALRIE` reader - Alarm interrupt Enable
        pub struct ALRIE_R(crate::FieldReader<bool, bool>);
        impl ALRIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ALRIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ALRIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ALRIE` writer - Alarm interrupt Enable
        pub struct ALRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `OWIE` reader - Overflow interrupt Enable
        pub struct OWIE_R(crate::FieldReader<bool, bool>);
        impl OWIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OWIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OWIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OWIE` writer - Overflow interrupt Enable
        pub struct OWIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OWIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            pub fn secie(&self) -> SECIE_R {
                SECIE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            pub fn alrie(&self) -> ALRIE_R {
                ALRIE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            pub fn owie(&self) -> OWIE_R {
                OWIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second interrupt Enable
            #[inline(always)]
            pub fn secie(&mut self) -> SECIE_W {
                SECIE_W { w: self }
            }
            ///Bit 1 - Alarm interrupt Enable
            #[inline(always)]
            pub fn alrie(&mut self) -> ALRIE_W {
                ALRIE_W { w: self }
            }
            ///Bit 2 - Overflow interrupt Enable
            #[inline(always)]
            pub fn owie(&mut self) -> OWIE_W {
                OWIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Control Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crh](index.html) module
        pub struct CRH_SPEC;
        impl crate::RegisterSpec for CRH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crh::R](R) reader structure
        impl crate::Readable for CRH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crh::W](W) writer structure
        impl crate::Writable for CRH_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CRH to value 0
        impl crate::Resettable for CRH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CRL register accessor: an alias for `Reg<CRL_SPEC>`
    pub type CRL = crate::Reg<crl::CRL_SPEC>;
    ///RTC Control Register Low
    pub mod crl {
        ///Register `CRL` reader
        pub struct R(crate::R<CRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CRL_SPEC>> for R {
            fn from(reader: crate::R<CRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRL` writer
        pub struct W(crate::W<CRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CRL_SPEC>> for W {
            fn from(writer: crate::W<CRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SECF` reader - Second Flag
        pub struct SECF_R(crate::FieldReader<bool, bool>);
        impl SECF_R {
            pub(crate) fn new(bits: bool) -> Self {
                SECF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SECF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SECF` writer - Second Flag
        pub struct SECF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SECF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `ALRF` reader - Alarm Flag
        pub struct ALRF_R(crate::FieldReader<bool, bool>);
        impl ALRF_R {
            pub(crate) fn new(bits: bool) -> Self {
                ALRF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ALRF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ALRF` writer - Alarm Flag
        pub struct ALRF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `OWF` reader - Overflow Flag
        pub struct OWF_R(crate::FieldReader<bool, bool>);
        impl OWF_R {
            pub(crate) fn new(bits: bool) -> Self {
                OWF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OWF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OWF` writer - Overflow Flag
        pub struct OWF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OWF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `RSF` reader - Registers Synchronized Flag
        pub struct RSF_R(crate::FieldReader<bool, bool>);
        impl RSF_R {
            pub(crate) fn new(bits: bool) -> Self {
                RSF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RSF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RSF` writer - Registers Synchronized Flag
        pub struct RSF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CNF` reader - Configuration Flag
        pub struct CNF_R(crate::FieldReader<bool, bool>);
        impl CNF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CNF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNF` writer - Configuration Flag
        pub struct CNF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `RTOFF` reader - RTC operation OFF
        pub struct RTOFF_R(crate::FieldReader<bool, bool>);
        impl RTOFF_R {
            pub(crate) fn new(bits: bool) -> Self {
                RTOFF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RTOFF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 0 - Second Flag
            #[inline(always)]
            pub fn secf(&self) -> SECF_R {
                SECF_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            pub fn alrf(&self) -> ALRF_R {
                ALRF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            pub fn owf(&self) -> OWF_R {
                OWF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            pub fn rsf(&self) -> RSF_R {
                RSF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            pub fn cnf(&self) -> CNF_R {
                CNF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - RTC operation OFF
            #[inline(always)]
            pub fn rtoff(&self) -> RTOFF_R {
                RTOFF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Second Flag
            #[inline(always)]
            pub fn secf(&mut self) -> SECF_W {
                SECF_W { w: self }
            }
            ///Bit 1 - Alarm Flag
            #[inline(always)]
            pub fn alrf(&mut self) -> ALRF_W {
                ALRF_W { w: self }
            }
            ///Bit 2 - Overflow Flag
            #[inline(always)]
            pub fn owf(&mut self) -> OWF_W {
                OWF_W { w: self }
            }
            ///Bit 3 - Registers Synchronized Flag
            #[inline(always)]
            pub fn rsf(&mut self) -> RSF_W {
                RSF_W { w: self }
            }
            ///Bit 4 - Configuration Flag
            #[inline(always)]
            pub fn cnf(&mut self) -> CNF_W {
                CNF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Control Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crl](index.html) module
        pub struct CRL_SPEC;
        impl crate::RegisterSpec for CRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crl::R](R) reader structure
        impl crate::Readable for CRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crl::W](W) writer structure
        impl crate::Writable for CRL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CRL to value 0x20
        impl crate::Resettable for CRL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x20
            }
        }
    }
    ///PRLH register accessor: an alias for `Reg<PRLH_SPEC>`
    pub type PRLH = crate::Reg<prlh::PRLH_SPEC>;
    ///RTC Prescaler Load Register High
    pub mod prlh {
        ///Register `PRLH` writer
        pub struct W(crate::W<PRLH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PRLH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PRLH_SPEC>> for W {
            fn from(writer: crate::W<PRLH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PRLH` writer - RTC Prescaler Load Register High
        pub struct PRLH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRLH_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl W {
            ///Bits 0:3 - RTC Prescaler Load Register High
            #[inline(always)]
            pub fn prlh(&mut self) -> PRLH_W {
                PRLH_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Prescaler Load Register High
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [prlh](index.html) module
        pub struct PRLH_SPEC;
        impl crate::RegisterSpec for PRLH_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [prlh::W](W) writer structure
        impl crate::Writable for PRLH_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PRLH to value 0
        impl crate::Resettable for PRLH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PRLL register accessor: an alias for `Reg<PRLL_SPEC>`
    pub type PRLL = crate::Reg<prll::PRLL_SPEC>;
    ///RTC Prescaler Load Register Low
    pub mod prll {
        ///Register `PRLL` writer
        pub struct W(crate::W<PRLL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PRLL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PRLL_SPEC>> for W {
            fn from(writer: crate::W<PRLL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PRLL` writer - RTC Prescaler Divider Register Low
        pub struct PRLL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRLL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:15 - RTC Prescaler Divider Register Low
            #[inline(always)]
            pub fn prll(&mut self) -> PRLL_W {
                PRLL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Prescaler Load Register Low
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [prll](index.html) module
        pub struct PRLL_SPEC;
        impl crate::RegisterSpec for PRLL_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [prll::W](W) writer structure
        impl crate::Writable for PRLL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PRLL to value 0x8000
        impl crate::Resettable for PRLL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x8000
            }
        }
    }
    ///DIVH register accessor: an alias for `Reg<DIVH_SPEC>`
    pub type DIVH = crate::Reg<divh::DIVH_SPEC>;
    ///RTC Prescaler Divider Register High
    pub mod divh {
        ///Register `DIVH` reader
        pub struct R(crate::R<DIVH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIVH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIVH_SPEC>> for R {
            fn from(reader: crate::R<DIVH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DIVH` reader - RTC prescaler divider register high
        pub struct DIVH_R(crate::FieldReader<u8, u8>);
        impl DIVH_R {
            pub(crate) fn new(bits: u8) -> Self {
                DIVH_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIVH_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:3 - RTC prescaler divider register high
            #[inline(always)]
            pub fn divh(&self) -> DIVH_R {
                DIVH_R::new((self.bits & 0x0f) as u8)
            }
        }
        ///RTC Prescaler Divider Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [divh](index.html) module
        pub struct DIVH_SPEC;
        impl crate::RegisterSpec for DIVH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [divh::R](R) reader structure
        impl crate::Readable for DIVH_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DIVH to value 0
        impl crate::Resettable for DIVH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIVL register accessor: an alias for `Reg<DIVL_SPEC>`
    pub type DIVL = crate::Reg<divl::DIVL_SPEC>;
    ///RTC Prescaler Divider Register Low
    pub mod divl {
        ///Register `DIVL` reader
        pub struct R(crate::R<DIVL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIVL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIVL_SPEC>> for R {
            fn from(reader: crate::R<DIVL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DIVL` reader - RTC prescaler divider register Low
        pub struct DIVL_R(crate::FieldReader<u16, u16>);
        impl DIVL_R {
            pub(crate) fn new(bits: u16) -> Self {
                DIVL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIVL_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - RTC prescaler divider register Low
            #[inline(always)]
            pub fn divl(&self) -> DIVL_R {
                DIVL_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///RTC Prescaler Divider Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [divl](index.html) module
        pub struct DIVL_SPEC;
        impl crate::RegisterSpec for DIVL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [divl::R](R) reader structure
        impl crate::Readable for DIVL_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DIVL to value 0x8000
        impl crate::Resettable for DIVL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x8000
            }
        }
    }
    ///CNTH register accessor: an alias for `Reg<CNTH_SPEC>`
    pub type CNTH = crate::Reg<cnth::CNTH_SPEC>;
    ///RTC Counter Register High
    pub mod cnth {
        ///Register `CNTH` reader
        pub struct R(crate::R<CNTH_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNTH_SPEC>> for R {
            fn from(reader: crate::R<CNTH_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTH` writer
        pub struct W(crate::W<CNTH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNTH_SPEC>> for W {
            fn from(writer: crate::W<CNTH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTH` reader - RTC counter register high
        pub struct CNTH_R(crate::FieldReader<u16, u16>);
        impl CNTH_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNTH_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNTH_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNTH` writer - RTC counter register high
        pub struct CNTH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNTH_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            pub fn cnth(&self) -> CNTH_R {
                CNTH_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register high
            #[inline(always)]
            pub fn cnth(&mut self) -> CNTH_W {
                CNTH_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Counter Register High
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnth](index.html) module
        pub struct CNTH_SPEC;
        impl crate::RegisterSpec for CNTH_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnth::R](R) reader structure
        impl crate::Readable for CNTH_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnth::W](W) writer structure
        impl crate::Writable for CNTH_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNTH to value 0
        impl crate::Resettable for CNTH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNTL register accessor: an alias for `Reg<CNTL_SPEC>`
    pub type CNTL = crate::Reg<cntl::CNTL_SPEC>;
    ///RTC Counter Register Low
    pub mod cntl {
        ///Register `CNTL` reader
        pub struct R(crate::R<CNTL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNTL_SPEC>> for R {
            fn from(reader: crate::R<CNTL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNTL` writer
        pub struct W(crate::W<CNTL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNTL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNTL_SPEC>> for W {
            fn from(writer: crate::W<CNTL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNTL` reader - RTC counter register Low
        pub struct CNTL_R(crate::FieldReader<u16, u16>);
        impl CNTL_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNTL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNTL_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNTL` writer - RTC counter register Low
        pub struct CNTL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNTL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            pub fn cntl(&self) -> CNTL_R {
                CNTL_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - RTC counter register Low
            #[inline(always)]
            pub fn cntl(&mut self) -> CNTL_W {
                CNTL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Counter Register Low
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cntl](index.html) module
        pub struct CNTL_SPEC;
        impl crate::RegisterSpec for CNTL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cntl::R](R) reader structure
        impl crate::Readable for CNTL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cntl::W](W) writer structure
        impl crate::Writable for CNTL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNTL to value 0
        impl crate::Resettable for CNTL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ALRH register accessor: an alias for `Reg<ALRH_SPEC>`
    pub type ALRH = crate::Reg<alrh::ALRH_SPEC>;
    ///RTC Alarm Register High
    pub mod alrh {
        ///Register `ALRH` writer
        pub struct W(crate::W<ALRH_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ALRH_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ALRH_SPEC>> for W {
            fn from(writer: crate::W<ALRH_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ALRH` writer - RTC alarm register high
        pub struct ALRH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRH_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:15 - RTC alarm register high
            #[inline(always)]
            pub fn alrh(&mut self) -> ALRH_W {
                ALRH_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Alarm Register High
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [alrh](index.html) module
        pub struct ALRH_SPEC;
        impl crate::RegisterSpec for ALRH_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [alrh::W](W) writer structure
        impl crate::Writable for ALRH_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ALRH to value 0xffff
        impl crate::Resettable for ALRH_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xffff
            }
        }
    }
    ///ALRL register accessor: an alias for `Reg<ALRL_SPEC>`
    pub type ALRL = crate::Reg<alrl::ALRL_SPEC>;
    ///RTC Alarm Register Low
    pub mod alrl {
        ///Register `ALRL` writer
        pub struct W(crate::W<ALRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ALRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ALRL_SPEC>> for W {
            fn from(writer: crate::W<ALRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ALRL` writer - RTC alarm register low
        pub struct ALRL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALRL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:15 - RTC alarm register low
            #[inline(always)]
            pub fn alrl(&mut self) -> ALRL_W {
                ALRL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC Alarm Register Low
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [alrl](index.html) module
        pub struct ALRL_SPEC;
        impl crate::RegisterSpec for ALRL_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [alrl::W](W) writer structure
        impl crate::Writable for ALRL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ALRL to value 0xffff
        impl crate::Resettable for ALRL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xffff
            }
        }
    }
}
///Backup registers
pub struct BKP {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for BKP {}
impl BKP {
    ///Pointer to the register block
    pub const PTR: *const bkp::RegisterBlock = 0x4000_6c04 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const bkp::RegisterBlock {
        Self::PTR
    }
}
impl Deref for BKP {
    type Target = bkp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for BKP {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("BKP").finish()
    }
}
///Backup registers
pub mod bkp {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Backup data register (BKP_DR)
        pub dr: [crate::Reg<dr::DR_SPEC>; 10],
        ///0x28 - RTC clock calibration register (BKP_RTCCR)
        pub rtccr: crate::Reg<rtccr::RTCCR_SPEC>,
        ///0x2c - Backup control register (BKP_CR)
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x30 - BKP_CSR control/status register (BKP_CSR)
        pub csr: crate::Reg<csr::CSR_SPEC>,
        _reserved4: [u8; 8usize],
        ///0x3c - Backup data register (BKP_DR)
        pub bkp_dr: [crate::Reg<bkp_dr::BKP_DR_SPEC>; 32],
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod dr {
        ///Register `DR%s` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR%s` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D` reader - Backup data
        pub struct D_R(crate::FieldReader<u16, u16>);
        impl D_R {
            pub(crate) fn new(bits: u16) -> Self {
                D_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for D_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `D` writer - Backup data
        pub struct D_W<'a> {
            w: &'a mut W,
        }
        impl<'a> D_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d(&self) -> D_R {
                D_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d(&mut self) -> D_W {
                D_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR%s to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BKP_DR register accessor: an alias for `Reg<BKP_DR_SPEC>`
    pub type BKP_DR = crate::Reg<bkp_dr::BKP_DR_SPEC>;
    ///Backup data register (BKP_DR)
    pub mod bkp_dr {
        ///Register `BKP_DR%s` reader
        pub struct R(crate::R<BKP_DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BKP_DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BKP_DR_SPEC>> for R {
            fn from(reader: crate::R<BKP_DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BKP_DR%s` writer
        pub struct W(crate::W<BKP_DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BKP_DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BKP_DR_SPEC>> for W {
            fn from(writer: crate::W<BKP_DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `D` reader - Backup data
        pub struct D_R(crate::FieldReader<u16, u16>);
        impl D_R {
            pub(crate) fn new(bits: u16) -> Self {
                D_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for D_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `D` writer - Backup data
        pub struct D_W<'a> {
            w: &'a mut W,
        }
        impl<'a> D_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d(&self) -> D_R {
                D_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Backup data
            #[inline(always)]
            pub fn d(&mut self) -> D_W {
                D_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup data register (BKP_DR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bkp_dr](index.html) module
        pub struct BKP_DR_SPEC;
        impl crate::RegisterSpec for BKP_DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bkp_dr::R](R) reader structure
        impl crate::Readable for BKP_DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bkp_dr::W](W) writer structure
        impl crate::Writable for BKP_DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BKP_DR%s to value 0
        impl crate::Resettable for BKP_DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RTCCR register accessor: an alias for `Reg<RTCCR_SPEC>`
    pub type RTCCR = crate::Reg<rtccr::RTCCR_SPEC>;
    ///RTC clock calibration register (BKP_RTCCR)
    pub mod rtccr {
        ///Register `RTCCR` reader
        pub struct R(crate::R<RTCCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RTCCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RTCCR_SPEC>> for R {
            fn from(reader: crate::R<RTCCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RTCCR` writer
        pub struct W(crate::W<RTCCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RTCCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RTCCR_SPEC>> for W {
            fn from(writer: crate::W<RTCCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CAL` reader - Calibration value
        pub struct CAL_R(crate::FieldReader<u8, u8>);
        impl CAL_R {
            pub(crate) fn new(bits: u8) -> Self {
                CAL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CAL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CAL` writer - Calibration value
        pub struct CAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CAL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | (value as u32 & 0x7f);
                self.w
            }
        }
        ///Field `CCO` reader - Calibration Clock Output
        pub struct CCO_R(crate::FieldReader<bool, bool>);
        impl CCO_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCO_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCO_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCO` writer - Calibration Clock Output
        pub struct CCO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCO_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Alarm or second output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASOE_A {
            ///0: Disabled
            DISABLED = 0,
            ///1: Setting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the TAMPER pin depending on the ASOS bit
            ENABLED = 1,
        }
        impl From<ASOE_A> for bool {
            #[inline(always)]
            fn from(variant: ASOE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ASOE` reader - Alarm or second output enable
        pub struct ASOE_R(crate::FieldReader<bool, ASOE_A>);
        impl ASOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ASOE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASOE_A {
                match self.bits {
                    false => ASOE_A::DISABLED,
                    true => ASOE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ASOE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ASOE_A::ENABLED
            }
        }
        impl core::ops::Deref for ASOE_R {
            type Target = crate::FieldReader<bool, ASOE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ASOE` writer - Alarm or second output enable
        pub struct ASOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASOE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ASOE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ASOE_A::DISABLED)
            }
            ///Setting this bit outputs either the RTC Alarm pulse signal or the Second pulse signal on the TAMPER pin depending on the ASOS bit
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ASOE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Alarm or second output selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ASOS_A {
            ///0: RTC Alarm pulse output selected
            ALARM = 0,
            ///1: RTC Second pulse output selected
            SECOND = 1,
        }
        impl From<ASOS_A> for bool {
            #[inline(always)]
            fn from(variant: ASOS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ASOS` reader - Alarm or second output selection
        pub struct ASOS_R(crate::FieldReader<bool, ASOS_A>);
        impl ASOS_R {
            pub(crate) fn new(bits: bool) -> Self {
                ASOS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ASOS_A {
                match self.bits {
                    false => ASOS_A::ALARM,
                    true => ASOS_A::SECOND,
                }
            }
            ///Checks if the value of the field is `ALARM`
            #[inline(always)]
            pub fn is_alarm(&self) -> bool {
                **self == ASOS_A::ALARM
            }
            ///Checks if the value of the field is `SECOND`
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                **self == ASOS_A::SECOND
            }
        }
        impl core::ops::Deref for ASOS_R {
            type Target = crate::FieldReader<bool, ASOS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ASOS` writer - Alarm or second output selection
        pub struct ASOS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ASOS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ASOS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RTC Alarm pulse output selected
            #[inline(always)]
            pub fn alarm(self) -> &'a mut W {
                self.variant(ASOS_A::ALARM)
            }
            ///RTC Second pulse output selected
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(ASOS_A::SECOND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        impl R {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            pub fn cco(&self) -> CCO_R {
                CCO_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            pub fn asoe(&self) -> ASOE_R {
                ASOE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            pub fn asos(&self) -> ASOS_R {
                ASOS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - Calibration value
            #[inline(always)]
            pub fn cal(&mut self) -> CAL_W {
                CAL_W { w: self }
            }
            ///Bit 7 - Calibration Clock Output
            #[inline(always)]
            pub fn cco(&mut self) -> CCO_W {
                CCO_W { w: self }
            }
            ///Bit 8 - Alarm or second output enable
            #[inline(always)]
            pub fn asoe(&mut self) -> ASOE_W {
                ASOE_W { w: self }
            }
            ///Bit 9 - Alarm or second output selection
            #[inline(always)]
            pub fn asos(&mut self) -> ASOS_W {
                ASOS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///RTC clock calibration register (BKP_RTCCR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rtccr](index.html) module
        pub struct RTCCR_SPEC;
        impl crate::RegisterSpec for RTCCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rtccr::R](R) reader structure
        impl crate::Readable for RTCCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rtccr::W](W) writer structure
        impl crate::Writable for RTCCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RTCCR to value 0
        impl crate::Resettable for RTCCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Backup control register (BKP_CR)
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Tamper pin enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPE_A {
            ///0: The TAMPER pin is free for general purpose I/O
            GENERAL = 0,
            ///1: Tamper alternate I/O function is activated
            ALTERNATE = 1,
        }
        impl From<TPE_A> for bool {
            #[inline(always)]
            fn from(variant: TPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TPE` reader - Tamper pin enable
        pub struct TPE_R(crate::FieldReader<bool, TPE_A>);
        impl TPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPE_A {
                match self.bits {
                    false => TPE_A::GENERAL,
                    true => TPE_A::ALTERNATE,
                }
            }
            ///Checks if the value of the field is `GENERAL`
            #[inline(always)]
            pub fn is_general(&self) -> bool {
                **self == TPE_A::GENERAL
            }
            ///Checks if the value of the field is `ALTERNATE`
            #[inline(always)]
            pub fn is_alternate(&self) -> bool {
                **self == TPE_A::ALTERNATE
            }
        }
        impl core::ops::Deref for TPE_R {
            type Target = crate::FieldReader<bool, TPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TPE` writer - Tamper pin enable
        pub struct TPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The TAMPER pin is free for general purpose I/O
            #[inline(always)]
            pub fn general(self) -> &'a mut W {
                self.variant(TPE_A::GENERAL)
            }
            ///Tamper alternate I/O function is activated
            #[inline(always)]
            pub fn alternate(self) -> &'a mut W {
                self.variant(TPE_A::ALTERNATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Tamper pin active level
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPAL_A {
            ///0: A high level on the TAMPER pin resets all data backup registers (if TPE bit is set)
            HIGH = 0,
            ///1: A low level on the TAMPER pin resets all data backup registers (if TPE bit is set)
            LOW = 1,
        }
        impl From<TPAL_A> for bool {
            #[inline(always)]
            fn from(variant: TPAL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TPAL` reader - Tamper pin active level
        pub struct TPAL_R(crate::FieldReader<bool, TPAL_A>);
        impl TPAL_R {
            pub(crate) fn new(bits: bool) -> Self {
                TPAL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPAL_A {
                match self.bits {
                    false => TPAL_A::HIGH,
                    true => TPAL_A::LOW,
                }
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == TPAL_A::HIGH
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == TPAL_A::LOW
            }
        }
        impl core::ops::Deref for TPAL_R {
            type Target = crate::FieldReader<bool, TPAL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TPAL` writer - Tamper pin active level
        pub struct TPAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPAL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TPAL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///A high level on the TAMPER pin resets all data backup registers (if TPE bit is set)
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(TPAL_A::HIGH)
            }
            ///A low level on the TAMPER pin resets all data backup registers (if TPE bit is set)
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(TPAL_A::LOW)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            pub fn tpe(&self) -> TPE_R {
                TPE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            pub fn tpal(&self) -> TPAL_R {
                TPAL_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Tamper pin enable
            #[inline(always)]
            pub fn tpe(&mut self) -> TPE_W {
                TPE_W { w: self }
            }
            ///Bit 1 - Tamper pin active level
            #[inline(always)]
            pub fn tpal(&mut self) -> TPAL_W {
                TPAL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Backup control register (BKP_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CSR register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///BKP_CSR control/status register (BKP_CSR)
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CSR_SPEC>> for R {
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CSR` writer
        pub struct W(crate::W<CSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CSR_SPEC>> for W {
            fn from(writer: crate::W<CSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clear Tamper event
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTE_AW {
            ///1: Reset the TEF Tamper event flag (and the Tamper detector)
            RESET = 1,
        }
        impl From<CTE_AW> for bool {
            #[inline(always)]
            fn from(variant: CTE_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTE` writer - Clear Tamper event
        pub struct CTE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTE_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Reset the TEF Tamper event flag (and the Tamper detector)
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(CTE_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Clear Tamper Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTI_AW {
            ///1: Clear the Tamper interrupt and the TIF Tamper interrupt flag
            CLEAR = 1,
        }
        impl From<CTI_AW> for bool {
            #[inline(always)]
            fn from(variant: CTI_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTI` writer - Clear Tamper Interrupt
        pub struct CTI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTI_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTI_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear the Tamper interrupt and the TIF Tamper interrupt flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CTI_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Tamper Pin interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TPIE_A {
            ///0: Tamper interrupt disabled
            DISABLED = 0,
            ///1: Tamper interrupt enabled (the TPE bit must also be set in the BKP_CR register
            ENABLED = 1,
        }
        impl From<TPIE_A> for bool {
            #[inline(always)]
            fn from(variant: TPIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TPIE` reader - Tamper Pin interrupt enable
        pub struct TPIE_R(crate::FieldReader<bool, TPIE_A>);
        impl TPIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TPIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TPIE_A {
                match self.bits {
                    false => TPIE_A::DISABLED,
                    true => TPIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TPIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TPIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TPIE_R {
            type Target = crate::FieldReader<bool, TPIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TPIE` writer - Tamper Pin interrupt enable
        pub struct TPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TPIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TPIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Tamper interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TPIE_A::DISABLED)
            }
            ///Tamper interrupt enabled (the TPE bit must also be set in the BKP_CR register
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TPIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `TEF` reader - Tamper Event Flag
        pub struct TEF_R(crate::FieldReader<bool, bool>);
        impl TEF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TEF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TEF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIF` reader - Tamper Interrupt Flag
        pub struct TIF_R(crate::FieldReader<bool, bool>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            pub fn tpie(&self) -> TPIE_R {
                TPIE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 8 - Tamper Event Flag
            #[inline(always)]
            pub fn tef(&self) -> TEF_R {
                TEF_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Tamper Interrupt Flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Clear Tamper event
            #[inline(always)]
            pub fn cte(&mut self) -> CTE_W {
                CTE_W { w: self }
            }
            ///Bit 1 - Clear Tamper Interrupt
            #[inline(always)]
            pub fn cti(&mut self) -> CTI_W {
                CTI_W { w: self }
            }
            ///Bit 2 - Tamper Pin interrupt enable
            #[inline(always)]
            pub fn tpie(&mut self) -> TPIE_W {
                TPIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///BKP_CSR control/status register (BKP_CSR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [csr::W](W) writer structure
        impl crate::Writable for CSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Independent watchdog
pub struct IWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for IWDG {}
impl IWDG {
    ///Pointer to the register block
    pub const PTR: *const iwdg::RegisterBlock = 0x4000_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const iwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for IWDG {
    type Target = iwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for IWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("IWDG").finish()
    }
}
///Independent watchdog
pub mod iwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Key register (IWDG_KR)
        pub kr: crate::Reg<kr::KR_SPEC>,
        ///0x04 - Prescaler register (IWDG_PR)
        pub pr: crate::Reg<pr::PR_SPEC>,
        ///0x08 - Reload register (IWDG_RLR)
        pub rlr: crate::Reg<rlr::RLR_SPEC>,
        ///0x0c - Status register (IWDG_SR)
        pub sr: crate::Reg<sr::SR_SPEC>,
    }
    ///KR register accessor: an alias for `Reg<KR_SPEC>`
    pub type KR = crate::Reg<kr::KR_SPEC>;
    ///Key register (IWDG_KR)
    pub mod kr {
        ///Register `KR` writer
        pub struct W(crate::W<KR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<KR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<KR_SPEC>> for W {
            fn from(writer: crate::W<KR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Key value
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u16)]
        pub enum KEY_AW {
            ///21845: Enable access to PR, RLR and WINR registers (0x5555)
            ENABLE = 21845,
            ///43690: Reset the watchdog value (0xAAAA)
            RESET = 43690,
            ///52428: Start the watchdog (0xCCCC)
            START = 52428,
        }
        impl From<KEY_AW> for u16 {
            #[inline(always)]
            fn from(variant: KEY_AW) -> Self {
                variant as _
            }
        }
        ///Field `KEY` writer - Key value
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: KEY_AW) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Enable access to PR, RLR and WINR registers (0x5555)
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(KEY_AW::ENABLE)
            }
            ///Reset the watchdog value (0xAAAA)
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(KEY_AW::RESET)
            }
            ///Start the watchdog (0xCCCC)
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(KEY_AW::START)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:15 - Key value
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Key register (IWDG_KR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [kr](index.html) module
        pub struct KR_SPEC;
        impl crate::RegisterSpec for KR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [kr::W](W) writer structure
        impl crate::Writable for KR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets KR to value 0
        impl crate::Resettable for KR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PR register accessor: an alias for `Reg<PR_SPEC>`
    pub type PR = crate::Reg<pr::PR_SPEC>;
    ///Prescaler register (IWDG_PR)
    pub mod pr {
        ///Register `PR` reader
        pub struct R(crate::R<PR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PR_SPEC>> for R {
            fn from(reader: crate::R<PR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PR` writer
        pub struct W(crate::W<PR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PR_SPEC>> for W {
            fn from(writer: crate::W<PR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Prescaler divider
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum PR_A {
            ///0: Divider /4
            DIVIDEBY4 = 0,
            ///1: Divider /8
            DIVIDEBY8 = 1,
            ///2: Divider /16
            DIVIDEBY16 = 2,
            ///3: Divider /32
            DIVIDEBY32 = 3,
            ///4: Divider /64
            DIVIDEBY64 = 4,
            ///5: Divider /128
            DIVIDEBY128 = 5,
            ///6: Divider /256
            DIVIDEBY256 = 6,
            ///7: Divider /256
            DIVIDEBY256BIS = 7,
        }
        impl From<PR_A> for u8 {
            #[inline(always)]
            fn from(variant: PR_A) -> Self {
                variant as _
            }
        }
        ///Field `PR` reader - Prescaler divider
        pub struct PR_R(crate::FieldReader<u8, PR_A>);
        impl PR_R {
            pub(crate) fn new(bits: u8) -> Self {
                PR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PR_A {
                match self.bits {
                    0 => PR_A::DIVIDEBY4,
                    1 => PR_A::DIVIDEBY8,
                    2 => PR_A::DIVIDEBY16,
                    3 => PR_A::DIVIDEBY32,
                    4 => PR_A::DIVIDEBY64,
                    5 => PR_A::DIVIDEBY128,
                    6 => PR_A::DIVIDEBY256,
                    7 => PR_A::DIVIDEBY256BIS,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIVIDEBY4`
            #[inline(always)]
            pub fn is_divide_by4(&self) -> bool {
                **self == PR_A::DIVIDEBY4
            }
            ///Checks if the value of the field is `DIVIDEBY8`
            #[inline(always)]
            pub fn is_divide_by8(&self) -> bool {
                **self == PR_A::DIVIDEBY8
            }
            ///Checks if the value of the field is `DIVIDEBY16`
            #[inline(always)]
            pub fn is_divide_by16(&self) -> bool {
                **self == PR_A::DIVIDEBY16
            }
            ///Checks if the value of the field is `DIVIDEBY32`
            #[inline(always)]
            pub fn is_divide_by32(&self) -> bool {
                **self == PR_A::DIVIDEBY32
            }
            ///Checks if the value of the field is `DIVIDEBY64`
            #[inline(always)]
            pub fn is_divide_by64(&self) -> bool {
                **self == PR_A::DIVIDEBY64
            }
            ///Checks if the value of the field is `DIVIDEBY128`
            #[inline(always)]
            pub fn is_divide_by128(&self) -> bool {
                **self == PR_A::DIVIDEBY128
            }
            ///Checks if the value of the field is `DIVIDEBY256`
            #[inline(always)]
            pub fn is_divide_by256(&self) -> bool {
                **self == PR_A::DIVIDEBY256
            }
            ///Checks if the value of the field is `DIVIDEBY256BIS`
            #[inline(always)]
            pub fn is_divide_by256bis(&self) -> bool {
                **self == PR_A::DIVIDEBY256BIS
            }
        }
        impl core::ops::Deref for PR_R {
            type Target = crate::FieldReader<u8, PR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PR` writer - Prescaler divider
        pub struct PR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PR_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Divider /4
            #[inline(always)]
            pub fn divide_by4(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY4)
            }
            ///Divider /8
            #[inline(always)]
            pub fn divide_by8(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY8)
            }
            ///Divider /16
            #[inline(always)]
            pub fn divide_by16(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY16)
            }
            ///Divider /32
            #[inline(always)]
            pub fn divide_by32(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY32)
            }
            ///Divider /64
            #[inline(always)]
            pub fn divide_by64(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY64)
            }
            ///Divider /128
            #[inline(always)]
            pub fn divide_by128(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY128)
            }
            ///Divider /256
            #[inline(always)]
            pub fn divide_by256(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256)
            }
            ///Divider /256
            #[inline(always)]
            pub fn divide_by256bis(self) -> &'a mut W {
                self.variant(PR_A::DIVIDEBY256BIS)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        impl R {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            pub fn pr(&self) -> PR_R {
                PR_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Prescaler divider
            #[inline(always)]
            pub fn pr(&mut self) -> PR_W {
                PR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Prescaler register (IWDG_PR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pr](index.html) module
        pub struct PR_SPEC;
        impl crate::RegisterSpec for PR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pr::R](R) reader structure
        impl crate::Readable for PR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pr::W](W) writer structure
        impl crate::Writable for PR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PR to value 0
        impl crate::Resettable for PR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RLR register accessor: an alias for `Reg<RLR_SPEC>`
    pub type RLR = crate::Reg<rlr::RLR_SPEC>;
    ///Reload register (IWDG_RLR)
    pub mod rlr {
        ///Register `RLR` reader
        pub struct R(crate::R<RLR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RLR_SPEC>> for R {
            fn from(reader: crate::R<RLR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RLR` writer
        pub struct W(crate::W<RLR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RLR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RLR_SPEC>> for W {
            fn from(writer: crate::W<RLR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RL` reader - Watchdog counter reload value
        pub struct RL_R(crate::FieldReader<u16, u16>);
        impl RL_R {
            pub(crate) fn new(bits: u16) -> Self {
                RL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RL_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RL` writer - Watchdog counter reload value
        pub struct RL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            pub fn rl(&self) -> RL_R {
                RL_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Watchdog counter reload value
            #[inline(always)]
            pub fn rl(&mut self) -> RL_W {
                RL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Reload register (IWDG_RLR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rlr](index.html) module
        pub struct RLR_SPEC;
        impl crate::RegisterSpec for RLR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rlr::R](R) reader structure
        impl crate::Readable for RLR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rlr::W](W) writer structure
        impl crate::Writable for RLR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RLR to value 0x0fff
        impl crate::Resettable for RLR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x0fff
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///Status register (IWDG_SR)
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PVU` reader - Watchdog prescaler value update
        pub struct PVU_R(crate::FieldReader<bool, bool>);
        impl PVU_R {
            pub(crate) fn new(bits: bool) -> Self {
                PVU_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PVU_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RVU` reader - Watchdog counter reload value update
        pub struct RVU_R(crate::FieldReader<bool, bool>);
        impl RVU_R {
            pub(crate) fn new(bits: bool) -> Self {
                RVU_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RVU_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 0 - Watchdog prescaler value update
            #[inline(always)]
            pub fn pvu(&self) -> PVU_R {
                PVU_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Watchdog counter reload value update
            #[inline(always)]
            pub fn rvu(&self) -> RVU_R {
                RVU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
        }
        ///Status register (IWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Window watchdog
pub struct WWDG {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for WWDG {}
impl WWDG {
    ///Pointer to the register block
    pub const PTR: *const wwdg::RegisterBlock = 0x4000_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const wwdg::RegisterBlock {
        Self::PTR
    }
}
impl Deref for WWDG {
    type Target = wwdg::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for WWDG {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("WWDG").finish()
    }
}
///Window watchdog
pub mod wwdg {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register (WWDG_CR)
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x04 - Configuration register (WWDG_CFR)
        pub cfr: crate::Reg<cfr::CFR_SPEC>,
        ///0x08 - Status register (WWDG_SR)
        pub sr: crate::Reg<sr::SR_SPEC>,
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Control register (WWDG_CR)
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `T` reader - 7-bit counter (MSB to LSB)
        pub struct T_R(crate::FieldReader<u8, u8>);
        impl T_R {
            pub(crate) fn new(bits: u8) -> Self {
                T_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for T_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `T` writer - 7-bit counter (MSB to LSB)
        pub struct T_W<'a> {
            w: &'a mut W,
        }
        impl<'a> T_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | (value as u32 & 0x7f);
                self.w
            }
        }
        ///Activation bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WDGA_A {
            ///0: Watchdog disabled
            DISABLED = 0,
            ///1: Watchdog enabled
            ENABLED = 1,
        }
        impl From<WDGA_A> for bool {
            #[inline(always)]
            fn from(variant: WDGA_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WDGA` reader - Activation bit
        pub struct WDGA_R(crate::FieldReader<bool, WDGA_A>);
        impl WDGA_R {
            pub(crate) fn new(bits: bool) -> Self {
                WDGA_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WDGA_A {
                match self.bits {
                    false => WDGA_A::DISABLED,
                    true => WDGA_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WDGA_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == WDGA_A::ENABLED
            }
        }
        impl core::ops::Deref for WDGA_R {
            type Target = crate::FieldReader<bool, WDGA_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WDGA` writer - Activation bit
        pub struct WDGA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGA_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WDGA_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Watchdog disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WDGA_A::DISABLED)
            }
            ///Watchdog enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(WDGA_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        impl R {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            pub fn t(&self) -> T_R {
                T_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            pub fn wdga(&self) -> WDGA_R {
                WDGA_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit counter (MSB to LSB)
            #[inline(always)]
            pub fn t(&mut self) -> T_W {
                T_W { w: self }
            }
            ///Bit 7 - Activation bit
            #[inline(always)]
            pub fn wdga(&mut self) -> WDGA_W {
                WDGA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register (WWDG_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0x7f
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x7f
            }
        }
    }
    ///CFR register accessor: an alias for `Reg<CFR_SPEC>`
    pub type CFR = crate::Reg<cfr::CFR_SPEC>;
    ///Configuration register (WWDG_CFR)
    pub mod cfr {
        ///Register `CFR` reader
        pub struct R(crate::R<CFR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CFR_SPEC>> for R {
            fn from(reader: crate::R<CFR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFR` writer
        pub struct W(crate::W<CFR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CFR_SPEC>> for W {
            fn from(writer: crate::W<CFR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `W` reader - 7-bit window value
        pub struct W_R(crate::FieldReader<u8, u8>);
        impl W_R {
            pub(crate) fn new(bits: u8) -> Self {
                W_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for W_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `W` writer - 7-bit window value
        pub struct W_W<'a> {
            w: &'a mut W,
        }
        impl<'a> W_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x7f) | (value as u32 & 0x7f);
                self.w
            }
        }
        ///Early Wakeup Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWI_A {
            ///1: interrupt occurs whenever the counter reaches the value 0x40
            ENABLE = 1,
        }
        impl From<EWI_A> for bool {
            #[inline(always)]
            fn from(variant: EWI_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EWI` reader - Early Wakeup Interrupt
        pub struct EWI_R(crate::FieldReader<bool, EWI_A>);
        impl EWI_R {
            pub(crate) fn new(bits: bool) -> Self {
                EWI_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<EWI_A> {
                match self.bits {
                    true => Some(EWI_A::ENABLE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `ENABLE`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                **self == EWI_A::ENABLE
            }
        }
        impl core::ops::Deref for EWI_R {
            type Target = crate::FieldReader<bool, EWI_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EWI` writer - Early Wakeup Interrupt
        pub struct EWI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWI_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EWI_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///interrupt occurs whenever the counter reaches the value 0x40
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(EWI_A::ENABLE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Timer Base
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WDGTB_A {
            ///0: Counter clock (PCLK1 div 4096) div 1
            DIV1 = 0,
            ///1: Counter clock (PCLK1 div 4096) div 2
            DIV2 = 1,
            ///2: Counter clock (PCLK1 div 4096) div 4
            DIV4 = 2,
            ///3: Counter clock (PCLK1 div 4096) div 8
            DIV8 = 3,
        }
        impl From<WDGTB_A> for u8 {
            #[inline(always)]
            fn from(variant: WDGTB_A) -> Self {
                variant as _
            }
        }
        ///Field `WDGTB` reader - Timer Base
        pub struct WDGTB_R(crate::FieldReader<u8, WDGTB_A>);
        impl WDGTB_R {
            pub(crate) fn new(bits: u8) -> Self {
                WDGTB_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WDGTB_A {
                match self.bits {
                    0 => WDGTB_A::DIV1,
                    1 => WDGTB_A::DIV2,
                    2 => WDGTB_A::DIV4,
                    3 => WDGTB_A::DIV8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == WDGTB_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == WDGTB_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == WDGTB_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == WDGTB_A::DIV8
            }
        }
        impl core::ops::Deref for WDGTB_R {
            type Target = crate::FieldReader<u8, WDGTB_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WDGTB` writer - Timer Base
        pub struct WDGTB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WDGTB_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WDGTB_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Counter clock (PCLK1 div 4096) div 1
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV1)
            }
            ///Counter clock (PCLK1 div 4096) div 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV2)
            }
            ///Counter clock (PCLK1 div 4096) div 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV4)
            }
            ///Counter clock (PCLK1 div 4096) div 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(WDGTB_A::DIV8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 7)) | ((value as u32 & 0x03) << 7);
                self.w
            }
        }
        impl R {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            pub fn w(&self) -> W_R {
                W_R::new((self.bits & 0x7f) as u8)
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewi(&self) -> EWI_R {
                EWI_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            pub fn wdgtb(&self) -> WDGTB_R {
                WDGTB_R::new(((self.bits >> 7) & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 0:6 - 7-bit window value
            #[inline(always)]
            pub fn w(&mut self) -> W_W {
                W_W { w: self }
            }
            ///Bit 9 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewi(&mut self) -> EWI_W {
                EWI_W { w: self }
            }
            ///Bits 7:8 - Timer Base
            #[inline(always)]
            pub fn wdgtb(&mut self) -> WDGTB_W {
                WDGTB_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Configuration register (WWDG_CFR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfr](index.html) module
        pub struct CFR_SPEC;
        impl crate::RegisterSpec for CFR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfr::R](R) reader structure
        impl crate::Readable for CFR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfr::W](W) writer structure
        impl crate::Writable for CFR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CFR to value 0x7f
        impl crate::Resettable for CFR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x7f
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///Status register (WWDG_SR)
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Early Wakeup Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_A {
            ///1: The EWI Interrupt Service Routine has been triggered
            PENDING = 1,
            ///0: The EWI Interrupt Service Routine has been serviced
            FINISHED = 0,
        }
        impl From<EWIF_A> for bool {
            #[inline(always)]
            fn from(variant: EWIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EWIF` reader - Early Wakeup Interrupt
        pub struct EWIF_R(crate::FieldReader<bool, EWIF_A>);
        impl EWIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                EWIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EWIF_A {
                match self.bits {
                    true => EWIF_A::PENDING,
                    false => EWIF_A::FINISHED,
                }
            }
            ///Checks if the value of the field is `PENDING`
            #[inline(always)]
            pub fn is_pending(&self) -> bool {
                **self == EWIF_A::PENDING
            }
            ///Checks if the value of the field is `FINISHED`
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                **self == EWIF_A::FINISHED
            }
        }
        impl core::ops::Deref for EWIF_R {
            type Target = crate::FieldReader<bool, EWIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Early Wakeup Interrupt
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EWIF_AW {
            ///0: The EWI Interrupt Service Routine has been serviced
            FINISHED = 0,
        }
        impl From<EWIF_AW> for bool {
            #[inline(always)]
            fn from(variant: EWIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EWIF` writer - Early Wakeup Interrupt
        pub struct EWIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EWIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EWIF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The EWI Interrupt Service Routine has been serviced
            #[inline(always)]
            pub fn finished(self) -> &'a mut W {
                self.variant(EWIF_AW::FINISHED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewif(&self) -> EWIF_R {
                EWIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Early Wakeup Interrupt
            #[inline(always)]
            pub fn ewif(&mut self) -> EWIF_W {
                EWIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register (WWDG_SR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Advanced timer
pub struct TIM1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM1 {}
impl TIM1 {
    ///Pointer to the register block
    pub const PTR: *const tim1::RegisterBlock = 0x4001_2c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM1 {
    type Target = tim1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM1").finish()
    }
}
///Advanced timer
pub mod tim1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - slave mode control register
        pub smcr: crate::Reg<smcr::SMCR_SPEC>,
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved_7_ccmr2: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        ///0x30 - repetition counter register
        pub rcr: crate::Reg<rcr::RCR_SPEC>,
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr::CCR_SPEC>,
        ///0x38 - capture/compare register 1
        pub ccr2: crate::Reg<ccr::CCR_SPEC>,
        ///0x3c - capture/compare register 1
        pub ccr3: crate::Reg<ccr::CCR_SPEC>,
        ///0x40 - capture/compare register 1
        pub ccr4: crate::Reg<ccr::CCR_SPEC>,
        ///0x44 - break and dead-time register
        pub bdtr: crate::Reg<bdtr::BDTR_SPEC>,
        ///0x48 - DMA control register
        pub dcr: crate::Reg<dcr::DCR_SPEC>,
        ///0x4c - DMA address for full transfer
        pub dmar: crate::Reg<dmar::DMAR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub fn ccmr2_input(&self) -> &crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(28usize)
                    as *const crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC>)
            }
        }
        ///0x1c - capture/compare mode register (output mode)
        #[inline(always)]
        pub fn ccmr2_output(&self) -> &crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(28usize)
                    as *const crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Center-aligned mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            ///0: The counter counts up or down depending on the direction bit
            EDGEALIGNED = 0,
            ///1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
            CENTERALIGNED1 = 1,
            ///2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
            CENTERALIGNED2 = 2,
            ///3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        ///Field `CMS` reader - Center-aligned mode selection
        pub struct CMS_R(crate::FieldReader<u8, CMS_A>);
        impl CMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                CMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `EDGEALIGNED`
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                **self == CMS_A::EDGEALIGNED
            }
            ///Checks if the value of the field is `CENTERALIGNED1`
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                **self == CMS_A::CENTERALIGNED1
            }
            ///Checks if the value of the field is `CENTERALIGNED2`
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                **self == CMS_A::CENTERALIGNED2
            }
            ///Checks if the value of the field is `CENTERALIGNED3`
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                **self == CMS_A::CENTERALIGNED3
            }
        }
        impl core::ops::Deref for CMS_R {
            type Target = crate::FieldReader<u8, CMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CMS` writer - Center-aligned mode selection
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The counter counts up or down depending on the direction bit
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | ((value as u32 & 0x03) << 5);
                self.w
            }
        }
        ///Direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            ///0: Counter used as upcounter
            UP = 0,
            ///1: Counter used as downcounter
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DIR` reader - Direction
        pub struct DIR_R(crate::FieldReader<bool, DIR_A>);
        impl DIR_R {
            pub(crate) fn new(bits: bool) -> Self {
                DIR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            ///Checks if the value of the field is `UP`
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                **self == DIR_A::UP
            }
            ///Checks if the value of the field is `DOWN`
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                **self == DIR_A::DOWN
            }
        }
        impl core::ops::Deref for DIR_R {
            type Target = crate::FieldReader<bool, DIR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIR` writer - Direction
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter used as upcounter
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            ///Counter used as downcounter
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            ///0: Counter is not stopped at update event
            DISABLED = 0,
            ///1: Counter stops counting at the next update event (clearing the CEN bit)
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, OPM_A>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OPM_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OPM_A::ENABLED
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, OPM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter is not stopped at update event
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            ///Counter stops counting at the next update event (clearing the CEN bit)
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OIS4` reader - Output Idle state 4
        pub struct OIS4_R(crate::FieldReader<bool, bool>);
        impl OIS4_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS4_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS4_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS4` writer - Output Idle state 4
        pub struct OIS4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS4_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `OIS3N` reader - Output Idle state 3
        pub struct OIS3N_R(crate::FieldReader<bool, bool>);
        impl OIS3N_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS3N_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS3N_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS3N` writer - Output Idle state 3
        pub struct OIS3N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS3N_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `OIS3` reader - Output Idle state 3
        pub struct OIS3_R(crate::FieldReader<bool, bool>);
        impl OIS3_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS3_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS3_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS3` writer - Output Idle state 3
        pub struct OIS3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS3_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `OIS2N` reader - Output Idle state 2
        pub struct OIS2N_R(crate::FieldReader<bool, bool>);
        impl OIS2N_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS2N_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS2N_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS2N` writer - Output Idle state 2
        pub struct OIS2N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2N_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OIS2` reader - Output Idle state 2
        pub struct OIS2_R(crate::FieldReader<bool, bool>);
        impl OIS2_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS2_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS2` writer - Output Idle state 2
        pub struct OIS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `OIS1N` reader - Output Idle state 1
        pub struct OIS1N_R(crate::FieldReader<bool, bool>);
        impl OIS1N_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1N_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS1N_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1N` writer - Output Idle state 1
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `OIS1` reader - Output Idle state 1
        pub struct OIS1_R(crate::FieldReader<bool, bool>);
        impl OIS1_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS1_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1` writer - Output Idle state 1
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///TI1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1S_A {
            ///0: The TIMx_CH1 pin is connected to TI1 input
            NORMAL = 0,
            ///1: The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            XOR = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TI1S` reader - TI1 selection
        pub struct TI1S_R(crate::FieldReader<bool, TI1S_A>);
        impl TI1S_R {
            pub(crate) fn new(bits: bool) -> Self {
                TI1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::NORMAL,
                    true => TI1S_A::XOR,
                }
            }
            ///Checks if the value of the field is `NORMAL`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                **self == TI1S_A::NORMAL
            }
            ///Checks if the value of the field is `XOR`
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                **self == TI1S_A::XOR
            }
        }
        impl core::ops::Deref for TI1S_R {
            type Target = crate::FieldReader<bool, TI1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TI1S` writer - TI1 selection
        pub struct TI1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TI1S_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The TIMx_CH1 pin is connected to TI1 input
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1S_A::NORMAL)
            }
            ///The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::XOR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            ///0: The UG bit from the TIMx_EGR register is used as trigger output
            RESET = 0,
            ///1: The counter enable signal, CNT_EN, is used as trigger output
            ENABLE = 1,
            ///2: The update event is selected as trigger output
            UPDATE = 2,
            ///3: The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
            COMPAREPULSE = 3,
            ///4: OC1REF signal is used as trigger output
            COMPAREOC1 = 4,
            ///5: OC2REF signal is used as trigger output
            COMPAREOC2 = 5,
            ///6: OC3REF signal is used as trigger output
            COMPAREOC3 = 6,
            ///7: OC4REF signal is used as trigger output
            COMPAREOC4 = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub struct MMS_R(crate::FieldReader<u8, MMS_A>);
        impl MMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                MMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::RESET,
                    1 => MMS_A::ENABLE,
                    2 => MMS_A::UPDATE,
                    3 => MMS_A::COMPAREPULSE,
                    4 => MMS_A::COMPAREOC1,
                    5 => MMS_A::COMPAREOC2,
                    6 => MMS_A::COMPAREOC3,
                    7 => MMS_A::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == MMS_A::RESET
            }
            ///Checks if the value of the field is `ENABLE`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                **self == MMS_A::ENABLE
            }
            ///Checks if the value of the field is `UPDATE`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                **self == MMS_A::UPDATE
            }
            ///Checks if the value of the field is `COMPAREPULSE`
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                **self == MMS_A::COMPAREPULSE
            }
            ///Checks if the value of the field is `COMPAREOC1`
            #[inline(always)]
            pub fn is_compare_oc1(&self) -> bool {
                **self == MMS_A::COMPAREOC1
            }
            ///Checks if the value of the field is `COMPAREOC2`
            #[inline(always)]
            pub fn is_compare_oc2(&self) -> bool {
                **self == MMS_A::COMPAREOC2
            }
            ///Checks if the value of the field is `COMPAREOC3`
            #[inline(always)]
            pub fn is_compare_oc3(&self) -> bool {
                **self == MMS_A::COMPAREOC3
            }
            ///Checks if the value of the field is `COMPAREOC4`
            #[inline(always)]
            pub fn is_compare_oc4(&self) -> bool {
                **self == MMS_A::COMPAREOC4
            }
        }
        impl core::ops::Deref for MMS_R {
            type Target = crate::FieldReader<u8, MMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The UG bit from the TIMx_EGR register is used as trigger output
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            ///The counter enable signal, CNT_EN, is used as trigger output
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            ///The update event is selected as trigger output
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            ///The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            ///OC1REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC1)
            }
            ///OC2REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC2)
            }
            ///OC3REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC3)
            }
            ///OC4REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Capture/compare DMA selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            ///0: CCx DMA request sent when CCx event occurs
            ONCOMPARE = 0,
            ///1: CCx DMA request sent when update event occurs
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub struct CCDS_R(crate::FieldReader<bool, CCDS_A>);
        impl CCDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCDS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            ///Checks if the value of the field is `ONCOMPARE`
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                **self == CCDS_A::ONCOMPARE
            }
            ///Checks if the value of the field is `ONUPDATE`
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                **self == CCDS_A::ONUPDATE
            }
        }
        impl core::ops::Deref for CCDS_R {
            type Target = crate::FieldReader<bool, CCDS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request sent when CCx event occurs
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            ///CCx DMA request sent when update event occurs
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CCUS` reader - Capture/compare control update selection
        pub struct CCUS_R(crate::FieldReader<bool, bool>);
        impl CCUS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCUS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCUS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCUS` writer - Capture/compare control update selection
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub struct CCPC_R(crate::FieldReader<bool, bool>);
        impl CCPC_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCPC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCPC_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&self) -> OIS4_R {
                OIS4_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&self) -> OIS3N_R {
                OIS3N_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&self) -> OIS3_R {
                OIS3_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&self) -> OIS2N_R {
                OIS2N_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 14 - Output Idle state 4
            #[inline(always)]
            pub fn ois4(&mut self) -> OIS4_W {
                OIS4_W { w: self }
            }
            ///Bit 13 - Output Idle state 3
            #[inline(always)]
            pub fn ois3n(&mut self) -> OIS3N_W {
                OIS3N_W { w: self }
            }
            ///Bit 12 - Output Idle state 3
            #[inline(always)]
            pub fn ois3(&mut self) -> OIS3_W {
                OIS3_W { w: self }
            }
            ///Bit 11 - Output Idle state 2
            #[inline(always)]
            pub fn ois2n(&mut self) -> OIS2N_W {
                OIS2N_W { w: self }
            }
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&mut self) -> OIS2_W {
                OIS2_W { w: self }
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&mut self) -> TI1S_W {
                TI1S_W { w: self }
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMCR register accessor: an alias for `Reg<SMCR_SPEC>`
    pub type SMCR = crate::Reg<smcr::SMCR_SPEC>;
    ///slave mode control register
    pub mod smcr {
        ///Register `SMCR` reader
        pub struct R(crate::R<SMCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMCR_SPEC>> for R {
            fn from(reader: crate::R<SMCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCR` writer
        pub struct W(crate::W<SMCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMCR_SPEC>> for W {
            fn from(writer: crate::W<SMCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///External trigger polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            ///0: ETR is noninverted, active at high level or rising edge
            NOTINVERTED = 0,
            ///1: ETR is inverted, active at low level or falling edge
            INVERTED = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ETP` reader - External trigger polarity
        pub struct ETP_R(crate::FieldReader<bool, ETP_A>);
        impl ETP_R {
            pub(crate) fn new(bits: bool) -> Self {
                ETP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::NOTINVERTED,
                    true => ETP_A::INVERTED,
                }
            }
            ///Checks if the value of the field is `NOTINVERTED`
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                **self == ETP_A::NOTINVERTED
            }
            ///Checks if the value of the field is `INVERTED`
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                **self == ETP_A::INVERTED
            }
        }
        impl core::ops::Deref for ETP_R {
            type Target = crate::FieldReader<bool, ETP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETP` writer - External trigger polarity
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///ETR is noninverted, active at high level or rising edge
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETP_A::NOTINVERTED)
            }
            ///ETR is inverted, active at low level or falling edge
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETP_A::INVERTED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///External clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            ///0: External clock mode 2 disabled
            DISABLED = 0,
            ///1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ECE` reader - External clock enable
        pub struct ECE_R(crate::FieldReader<bool, ECE_A>);
        impl ECE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ECE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ECE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ECE_A::ENABLED
            }
        }
        impl core::ops::Deref for ECE_R {
            type Target = crate::FieldReader<bool, ECE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ECE` writer - External clock enable
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///External clock mode 2 disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            ///External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///External trigger prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            ///0: Prescaler OFF
            DIV1 = 0,
            ///1: ETRP frequency divided by 2
            DIV2 = 1,
            ///2: ETRP frequency divided by 4
            DIV4 = 2,
            ///3: ETRP frequency divided by 8
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        ///Field `ETPS` reader - External trigger prescaler
        pub struct ETPS_R(crate::FieldReader<u8, ETPS_A>);
        impl ETPS_R {
            pub(crate) fn new(bits: u8) -> Self {
                ETPS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == ETPS_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == ETPS_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == ETPS_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == ETPS_A::DIV8
            }
        }
        impl core::ops::Deref for ETPS_R {
            type Target = crate::FieldReader<u8, ETPS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETPS` writer - External trigger prescaler
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Prescaler OFF
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            ///ETRP frequency divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            ///ETRP frequency divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            ///ETRP frequency divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///External trigger filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            ///0: No filter, sampling is done at fDTS
            NOFILTER = 0,
            ///1: fSAMPLING=fCK_INT, N=2
            FCK_INT_N2 = 1,
            ///2: fSAMPLING=fCK_INT, N=4
            FCK_INT_N4 = 2,
            ///3: fSAMPLING=fCK_INT, N=8
            FCK_INT_N8 = 3,
            ///4: fSAMPLING=fDTS/2, N=6
            FDTS_DIV2_N6 = 4,
            ///5: fSAMPLING=fDTS/2, N=8
            FDTS_DIV2_N8 = 5,
            ///6: fSAMPLING=fDTS/4, N=6
            FDTS_DIV4_N6 = 6,
            ///7: fSAMPLING=fDTS/4, N=8
            FDTS_DIV4_N8 = 7,
            ///8: fSAMPLING=fDTS/8, N=6
            FDTS_DIV8_N6 = 8,
            ///9: fSAMPLING=fDTS/8, N=8
            FDTS_DIV8_N8 = 9,
            ///10: fSAMPLING=fDTS/16, N=5
            FDTS_DIV16_N5 = 10,
            ///11: fSAMPLING=fDTS/16, N=6
            FDTS_DIV16_N6 = 11,
            ///12: fSAMPLING=fDTS/16, N=8
            FDTS_DIV16_N8 = 12,
            ///13: fSAMPLING=fDTS/32, N=5
            FDTS_DIV32_N5 = 13,
            ///14: fSAMPLING=fDTS/32, N=6
            FDTS_DIV32_N6 = 14,
            ///15: fSAMPLING=fDTS/32, N=8
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        ///Field `ETF` reader - External trigger filter
        pub struct ETF_R(crate::FieldReader<u8, ETF_A>);
        impl ETF_R {
            pub(crate) fn new(bits: u8) -> Self {
                ETF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NOFILTER`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                **self == ETF_A::NOFILTER
            }
            ///Checks if the value of the field is `FCK_INT_N2`
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                **self == ETF_A::FCK_INT_N2
            }
            ///Checks if the value of the field is `FCK_INT_N4`
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                **self == ETF_A::FCK_INT_N4
            }
            ///Checks if the value of the field is `FCK_INT_N8`
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                **self == ETF_A::FCK_INT_N8
            }
            ///Checks if the value of the field is `FDTS_DIV2_N6`
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV2_N6
            }
            ///Checks if the value of the field is `FDTS_DIV2_N8`
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV2_N8
            }
            ///Checks if the value of the field is `FDTS_DIV4_N6`
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV4_N6
            }
            ///Checks if the value of the field is `FDTS_DIV4_N8`
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV4_N8
            }
            ///Checks if the value of the field is `FDTS_DIV8_N6`
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV8_N6
            }
            ///Checks if the value of the field is `FDTS_DIV8_N8`
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV8_N8
            }
            ///Checks if the value of the field is `FDTS_DIV16_N5`
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N5
            }
            ///Checks if the value of the field is `FDTS_DIV16_N6`
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N6
            }
            ///Checks if the value of the field is `FDTS_DIV16_N8`
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N8
            }
            ///Checks if the value of the field is `FDTS_DIV32_N5`
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N5
            }
            ///Checks if the value of the field is `FDTS_DIV32_N6`
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N6
            }
            ///Checks if the value of the field is `FDTS_DIV32_N8`
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N8
            }
        }
        impl core::ops::Deref for ETF_R {
            type Target = crate::FieldReader<u8, ETF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETF` writer - External trigger filter
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///No filter, sampling is done at fDTS
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            ///fSAMPLING=fCK_INT, N=2
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            ///fSAMPLING=fCK_INT, N=4
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            ///fSAMPLING=fCK_INT, N=8
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            ///fSAMPLING=fDTS/2, N=6
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            ///fSAMPLING=fDTS/2, N=8
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            ///fSAMPLING=fDTS/4, N=6
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            ///fSAMPLING=fDTS/4, N=8
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            ///fSAMPLING=fDTS/8, N=6
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            ///fSAMPLING=fDTS/8, N=8
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            ///fSAMPLING=fDTS/16, N=5
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            ///fSAMPLING=fDTS/16, N=6
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            ///fSAMPLING=fDTS/16, N=8
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            ///fSAMPLING=fDTS/32, N=5
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            ///fSAMPLING=fDTS/32, N=6
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            ///fSAMPLING=fDTS/32, N=8
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Master/Slave mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            ///0: No action
            NOSYNC = 0,
            ///1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub struct MSM_R(crate::FieldReader<bool, MSM_A>);
        impl MSM_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            ///Checks if the value of the field is `NOSYNC`
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                **self == MSM_A::NOSYNC
            }
            ///Checks if the value of the field is `SYNC`
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                **self == MSM_A::SYNC
            }
        }
        impl core::ops::Deref for MSM_R {
            type Target = crate::FieldReader<bool, MSM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            ///The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            ///0: Internal Trigger 0 (ITR0)
            ITR0 = 0,
            ///1: Internal Trigger 1 (ITR1)
            ITR1 = 1,
            ///2: Internal Trigger 2 (ITR2)
            ITR2 = 2,
            ///4: TI1 Edge Detector (TI1F_ED)
            TI1F_ED = 4,
            ///5: Filtered Timer Input 1 (TI1FP1)
            TI1FP1 = 5,
            ///6: Filtered Timer Input 2 (TI2FP2)
            TI2FP2 = 6,
            ///7: External Trigger input (ETRF)
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        ///Field `TS` reader - Trigger selection
        pub struct TS_R(crate::FieldReader<u8, TS_A>);
        impl TS_R {
            pub(crate) fn new(bits: u8) -> Self {
                TS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TS_A> {
                match self.bits {
                    0 => Some(TS_A::ITR0),
                    1 => Some(TS_A::ITR1),
                    2 => Some(TS_A::ITR2),
                    4 => Some(TS_A::TI1F_ED),
                    5 => Some(TS_A::TI1FP1),
                    6 => Some(TS_A::TI2FP2),
                    7 => Some(TS_A::ETRF),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `ITR0`
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                **self == TS_A::ITR0
            }
            ///Checks if the value of the field is `ITR1`
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                **self == TS_A::ITR1
            }
            ///Checks if the value of the field is `ITR2`
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                **self == TS_A::ITR2
            }
            ///Checks if the value of the field is `TI1F_ED`
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                **self == TS_A::TI1F_ED
            }
            ///Checks if the value of the field is `TI1FP1`
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                **self == TS_A::TI1FP1
            }
            ///Checks if the value of the field is `TI2FP2`
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                **self == TS_A::TI2FP2
            }
            ///Checks if the value of the field is `ETRF`
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                **self == TS_A::ETRF
            }
        }
        impl core::ops::Deref for TS_R {
            type Target = crate::FieldReader<u8, TS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TS` writer - Trigger selection
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Internal Trigger 0 (ITR0)
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            ///Internal Trigger 1 (ITR1)
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            ///Internal Trigger 2 (ITR2)
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            ///TI1 Edge Detector (TI1F_ED)
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            ///Filtered Timer Input 1 (TI1FP1)
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            ///Filtered Timer Input 2 (TI2FP2)
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            ///External Trigger input (ETRF)
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Slave mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            ///0: Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
            DISABLED = 0,
            ///1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
            ENCODER_MODE_1 = 1,
            ///2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
            ENCODER_MODE_2 = 2,
            ///3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
            ENCODER_MODE_3 = 3,
            ///4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
            RESET_MODE = 4,
            ///5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
            GATED_MODE = 5,
            ///6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
            TRIGGER_MODE = 6,
            ///7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub struct SMS_R(crate::FieldReader<u8, SMS_A>);
        impl SMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SMS_A::DISABLED
            }
            ///Checks if the value of the field is `ENCODER_MODE_1`
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_1
            }
            ///Checks if the value of the field is `ENCODER_MODE_2`
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_2
            }
            ///Checks if the value of the field is `ENCODER_MODE_3`
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_3
            }
            ///Checks if the value of the field is `RESET_MODE`
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                **self == SMS_A::RESET_MODE
            }
            ///Checks if the value of the field is `GATED_MODE`
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                **self == SMS_A::GATED_MODE
            }
            ///Checks if the value of the field is `TRIGGER_MODE`
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                **self == SMS_A::TRIGGER_MODE
            }
            ///Checks if the value of the field is `EXT_CLOCK_MODE`
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                **self == SMS_A::EXT_CLOCK_MODE
            }
        }
        impl core::ops::Deref for SMS_R {
            type Target = crate::FieldReader<u8, SMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            ///Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            ///Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            ///Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            ///Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            ///Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            ///Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            ///External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        impl R {
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcr](index.html) module
        pub struct SMCR_SPEC;
        impl crate::RegisterSpec for SMCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcr::R](R) reader structure
        impl crate::Readable for SMCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcr::W](W) writer structure
        impl crate::Writable for SMCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMCR to value 0
        impl crate::Resettable for SMCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Capture/Compare 1 interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1IE_A {
            ///0: CCx interrupt disabled
            DISABLED = 0,
            ///1: CCx interrupt enabled
            ENABLED = 1,
        }
        impl From<CC1IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1IE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub struct CC1IE_R(crate::FieldReader<bool, CC1IE_A>);
        impl CC1IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1IE_A {
                match self.bits {
                    false => CC1IE_A::DISABLED,
                    true => CC1IE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC1IE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC1IE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC1IE_R {
            type Target = crate::FieldReader<bool, CC1IE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Capture/Compare 2 interrupt enable
        pub type CC2IE_A = CC1IE_A;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = CC1IE_R;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 3 interrupt enable
        pub type CC3IE_A = CC1IE_A;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = CC1IE_R;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub struct CC3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC3IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC3IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/Compare 4 interrupt enable
        pub type CC4IE_A = CC1IE_A;
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub type CC4IE_R = CC1IE_R;
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub struct CC4IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `COMIE` reader - COM interrupt enable
        pub struct COMIE_R(crate::FieldReader<bool, bool>);
        impl COMIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIE` writer - COM interrupt enable
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Trigger interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            ///0: Trigger interrupt disabled
            DISABLED = 0,
            ///1: Trigger interrupt enabled
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIE` reader - Trigger interrupt enable
        pub struct TIE_R(crate::FieldReader<bool, TIE_A>);
        impl TIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TIE_R {
            type Target = crate::FieldReader<bool, TIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIE` writer - Trigger interrupt enable
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Trigger interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            ///Trigger interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `BIE` reader - Break interrupt enable
        pub struct BIE_R(crate::FieldReader<bool, bool>);
        impl BIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIE` writer - Break interrupt enable
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Update DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            ///0: Update DMA request disabled
            DISABLED = 0,
            ///1: Update DMA request enabled
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDE` reader - Update DMA request enable
        pub struct UDE_R(crate::FieldReader<bool, UDE_A>);
        impl UDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDE_A::ENABLED
            }
        }
        impl core::ops::Deref for UDE_R {
            type Target = crate::FieldReader<bool, UDE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            ///Update DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Capture/Compare 1 DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1DE_A {
            ///0: CCx DMA request disabled
            DISABLED = 0,
            ///1: CCx DMA request enabled
            ENABLED = 1,
        }
        impl From<CC1DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1DE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub struct CC1DE_R(crate::FieldReader<bool, CC1DE_A>);
        impl CC1DE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1DE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1DE_A {
                match self.bits {
                    false => CC1DE_A::DISABLED,
                    true => CC1DE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC1DE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC1DE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC1DE_R {
            type Target = crate::FieldReader<bool, CC1DE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Capture/Compare 2 DMA request enable
        pub type CC2DE_A = CC1DE_A;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = CC1DE_R;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 3 DMA request enable
        pub type CC3DE_A = CC1DE_A;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = CC1DE_R;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub struct CC3DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC3DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC3DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Capture/Compare 4 DMA request enable
        pub type CC4DE_A = CC1DE_A;
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub type CC4DE_R = CC1DE_R;
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub struct CC4DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `COMDE` reader - COM DMA request enable
        pub struct COMDE_R(crate::FieldReader<bool, bool>);
        impl COMDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMDE` writer - COM DMA request enable
        pub struct COMDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Trigger DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDE_A {
            ///0: Trigger DMA request disabled
            DISABLED = 0,
            ///1: Trigger DMA request enabled
            ENABLED = 1,
        }
        impl From<TDE_A> for bool {
            #[inline(always)]
            fn from(variant: TDE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TDE` reader - Trigger DMA request enable
        pub struct TDE_R(crate::FieldReader<bool, TDE_A>);
        impl TDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TDE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TDE_A {
                match self.bits {
                    false => TDE_A::DISABLED,
                    true => TDE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TDE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TDE_A::ENABLED
            }
        }
        impl core::ops::Deref for TDE_R {
            type Target = crate::FieldReader<bool, TDE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TDE` writer - Trigger DMA request enable
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TDE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Trigger DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDE_A::DISABLED)
            }
            ///Trigger DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&self) -> COMDE_R {
                COMDE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&mut self) -> CC3IE_W {
                CC3IE_W { w: self }
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&mut self) -> CC4IE_W {
                CC4IE_W { w: self }
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&mut self) -> CC3DE_W {
                CC3DE_W { w: self }
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&mut self) -> CC4DE_W {
                CC4DE_W { w: self }
            }
            ///Bit 13 - COM DMA request enable
            #[inline(always)]
            pub fn comde(&mut self) -> COMDE_W {
                COMDE_W { w: self }
            }
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Capture/Compare 4 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_A {
            ///1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
            OVERCAPTURE = 1,
        }
        impl From<CC4OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub struct CC4OF_R(crate::FieldReader<bool, CC4OF_A>);
        impl CC4OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4OF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4OF_A> {
                match self.bits {
                    true => Some(CC4OF_A::OVERCAPTURE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OVERCAPTURE`
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                **self == CC4OF_A::OVERCAPTURE
            }
        }
        impl core::ops::Deref for CC4OF_R {
            type Target = crate::FieldReader<bool, CC4OF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Capture/Compare 4 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<CC4OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub struct CC4OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Capture/Compare 3 overcapture flag
        pub type CC3OF_A = CC4OF_A;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = CC4OF_R;
        ///Capture/Compare 3 overcapture flag
        pub type CC3OF_AW = CC4OF_AW;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub struct CC3OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC3OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Capture/compare 2 overcapture flag
        pub type CC2OF_A = CC4OF_A;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = CC4OF_R;
        ///Capture/compare 2 overcapture flag
        pub type CC2OF_AW = CC4OF_AW;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 1 overcapture flag
        pub type CC1OF_A = CC4OF_A;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = CC4OF_R;
        ///Capture/Compare 1 overcapture flag
        pub type CC1OF_AW = CC4OF_AW;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `BIF` reader - Break interrupt flag
        pub struct BIF_R(crate::FieldReader<bool, bool>);
        impl BIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIF` writer - Break interrupt flag
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Trigger interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            ///0: No trigger event occurred
            NOTRIGGER = 0,
            ///1: Trigger interrupt pending
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIF` reader - Trigger interrupt flag
        pub struct TIF_R(crate::FieldReader<bool, TIF_A>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            ///Checks if the value of the field is `NOTRIGGER`
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                **self == TIF_A::NOTRIGGER
            }
            ///Checks if the value of the field is `TRIGGER`
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                **self == TIF_A::TRIGGER
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, TIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Trigger interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIF` writer - Trigger interrupt flag
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMIF` reader - COM interrupt flag
        pub struct COMIF_R(crate::FieldReader<bool, bool>);
        impl COMIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIF` writer - COM interrupt flag
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Capture/Compare 4 interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_A {
            ///1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
            MATCH = 1,
        }
        impl From<CC4IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub struct CC4IF_R(crate::FieldReader<bool, CC4IF_A>);
        impl CC4IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4IF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4IF_A> {
                match self.bits {
                    true => Some(CC4IF_A::MATCH),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `MATCH`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                **self == CC4IF_A::MATCH
            }
        }
        impl core::ops::Deref for CC4IF_R {
            type Target = crate::FieldReader<bool, CC4IF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Capture/Compare 4 interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<CC4IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub struct CC4IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Capture/Compare 3 interrupt flag
        pub type CC3IF_A = CC4IF_A;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = CC4IF_R;
        ///Capture/Compare 3 interrupt flag
        pub type CC3IF_AW = CC4IF_AW;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub struct CC3IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC3IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/Compare 2 interrupt flag
        pub type CC2IF_A = CC4IF_A;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = CC4IF_R;
        ///Capture/Compare 2 interrupt flag
        pub type CC2IF_AW = CC4IF_AW;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/compare 1 interrupt flag
        pub type CC1IF_A = CC4IF_A;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = CC4IF_R;
        ///Capture/compare 1 interrupt flag
        pub type CC1IF_AW = CC4IF_AW;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&mut self) -> CC4OF_W {
                CC4OF_W { w: self }
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&mut self) -> CC3OF_W {
                CC3OF_W { w: self }
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&mut self) -> CC4IF_W {
                CC4IF_W { w: self }
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&mut self) -> CC3IF_W {
                CC3IF_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BG` writer - Break generation
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Trigger generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            ///1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TG` writer - Trigger generation
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMG` writer - Capture/Compare control update generation
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Capture/compare 4 generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4G_AW {
            ///1: If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            TRIGGER = 1,
        }
        impl From<CC4G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4G_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub struct CC4G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Capture/compare 3 generation
        pub type CC3G_AW = CC4G_AW;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub struct CC3G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC3G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/compare 2 generation
        pub type CC2G_AW = CC4G_AW;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/compare 1 generation
        pub type CC1G_AW = CC4G_AW;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC1G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 7 - Break generation
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            pub fn cc4g(&mut self) -> CC4G_W {
                CC4G_W { w: self }
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            pub fn cc3g(&mut self) -> CC3G_W {
                CC3G_W { w: self }
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC2CE` reader - Output Compare 2 clear enable
        pub struct OC2CE_R(crate::FieldReader<bool, bool>);
        impl OC2CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2CE` writer - Output Compare 2 clear enable
        pub struct OC2CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Output Compare 2 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            ///0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            FROZEN = 0,
            ///1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            ACTIVEONMATCH = 1,
            ///2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            INACTIVEONMATCH = 2,
            ///3: OCyREF toggles when TIMx_CNT=TIMx_CCRy
            TOGGLE = 3,
            ///4: OCyREF is forced low
            FORCEINACTIVE = 4,
            ///5: OCyREF is forced high
            FORCEACTIVE = 5,
            ///6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            PWMMODE1 = 6,
            ///7: Inversely to PwmMode1
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        ///Field `OC2M` reader - Output Compare 2 mode
        pub struct OC2M_R(crate::FieldReader<u8, OC2M_A>);
        impl OC2M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC2M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `FROZEN`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                **self == OC2M_A::FROZEN
            }
            ///Checks if the value of the field is `ACTIVEONMATCH`
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                **self == OC2M_A::ACTIVEONMATCH
            }
            ///Checks if the value of the field is `INACTIVEONMATCH`
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                **self == OC2M_A::INACTIVEONMATCH
            }
            ///Checks if the value of the field is `TOGGLE`
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                **self == OC2M_A::TOGGLE
            }
            ///Checks if the value of the field is `FORCEINACTIVE`
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                **self == OC2M_A::FORCEINACTIVE
            }
            ///Checks if the value of the field is `FORCEACTIVE`
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                **self == OC2M_A::FORCEACTIVE
            }
            ///Checks if the value of the field is `PWMMODE1`
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                **self == OC2M_A::PWMMODE1
            }
            ///Checks if the value of the field is `PWMMODE2`
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                **self == OC2M_A::PWMMODE2
            }
        }
        impl core::ops::Deref for OC2M_R {
            type Target = crate::FieldReader<u8, OC2M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2M` writer - Output Compare 2 mode
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Output Compare 2 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            ///0: Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub struct OC2PE_R(crate::FieldReader<bool, OC2PE_A>);
        impl OC2PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC2PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC2PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC2PE_R {
            type Target = crate::FieldReader<bool, OC2PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            ///Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub struct OC2FE_R(crate::FieldReader<bool, bool>);
        impl OC2FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, CC2S_A>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC2S_A> {
                match self.bits {
                    0 => Some(CC2S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC2S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, CC2S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC2 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC1CE` reader - Output Compare 1 clear enable
        pub struct OC1CE_R(crate::FieldReader<bool, bool>);
        impl OC1CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1CE` writer - Output Compare 1 clear enable
        pub struct OC1CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Output Compare 1 mode
        pub type OC1M_A = OC2M_A;
        ///Field `OC1M` reader - Output Compare 1 mode
        pub type OC1M_R = OC2M_R;
        ///Field `OC1M` writer - Output Compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC1M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC1M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC1M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC1M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC1M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC1M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC1M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC1M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Output Compare 1 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC1PE_A {
            ///0: Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, OC1PE_A>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::DISABLED,
                    true => OC1PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC1PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC1PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, OC1PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::DISABLED)
            }
            ///Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, CC1S_A>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC1S_A> {
                match self.bits {
                    0 => Some(CC1S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC1S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, CC1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC1 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bit 15 - Output Compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&mut self) -> OC2CE_W {
                OC2CE_W { w: self }
            }
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bit 7 - Output Compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&mut self) -> OC1CE_W {
                OC1CE_W { w: self }
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub struct IC2F_R(crate::FieldReader<u8, u8>);
        impl IC2F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2F` writer - Input capture 2 filter
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 15)) | ((value as u32 & 0x0f) << 15);
                self.w
            }
        }
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub struct IC2PSC_R(crate::FieldReader<u8, u8>);
        impl IC2PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///1: CC2 channel is configured as input, IC2 is mapped on TI2
            TI2 = 1,
            ///2: CC2 channel is configured as input, IC2 is mapped on TI1
            TI1 = 2,
            ///3: CC2 channel is configured as input, IC2 is mapped on TRC
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, CC2S_A>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC2S_A> {
                match self.bits {
                    1 => Some(CC2S_A::TI2),
                    2 => Some(CC2S_A::TI1),
                    3 => Some(CC2S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI2`
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                **self == CC2S_A::TI2
            }
            ///Checks if the value of the field is `TI1`
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                **self == CC2S_A::TI1
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC2S_A::TRC
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, CC2S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC2 channel is configured as input, IC2 is mapped on TI2
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            ///CC2 channel is configured as input, IC2 is mapped on TI1
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            ///CC2 channel is configured as input, IC2 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Input capture 1 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1F_A {
            ///0: No filter, sampling is done at fDTS
            NOFILTER = 0,
            ///1: fSAMPLING=fCK_INT, N=2
            FCK_INT_N2 = 1,
            ///2: fSAMPLING=fCK_INT, N=4
            FCK_INT_N4 = 2,
            ///3: fSAMPLING=fCK_INT, N=8
            FCK_INT_N8 = 3,
            ///4: fSAMPLING=fDTS/2, N=6
            FDTS_DIV2_N6 = 4,
            ///5: fSAMPLING=fDTS/2, N=8
            FDTS_DIV2_N8 = 5,
            ///6: fSAMPLING=fDTS/4, N=6
            FDTS_DIV4_N6 = 6,
            ///7: fSAMPLING=fDTS/4, N=8
            FDTS_DIV4_N8 = 7,
            ///8: fSAMPLING=fDTS/8, N=6
            FDTS_DIV8_N6 = 8,
            ///9: fSAMPLING=fDTS/8, N=8
            FDTS_DIV8_N8 = 9,
            ///10: fSAMPLING=fDTS/16, N=5
            FDTS_DIV16_N5 = 10,
            ///11: fSAMPLING=fDTS/16, N=6
            FDTS_DIV16_N6 = 11,
            ///12: fSAMPLING=fDTS/16, N=8
            FDTS_DIV16_N8 = 12,
            ///13: fSAMPLING=fDTS/32, N=5
            FDTS_DIV32_N5 = 13,
            ///14: fSAMPLING=fDTS/32, N=6
            FDTS_DIV32_N6 = 14,
            ///15: fSAMPLING=fDTS/32, N=8
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, IC1F_A>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NOFILTER,
                    1 => IC1F_A::FCK_INT_N2,
                    2 => IC1F_A::FCK_INT_N4,
                    3 => IC1F_A::FCK_INT_N8,
                    4 => IC1F_A::FDTS_DIV2_N6,
                    5 => IC1F_A::FDTS_DIV2_N8,
                    6 => IC1F_A::FDTS_DIV4_N6,
                    7 => IC1F_A::FDTS_DIV4_N8,
                    8 => IC1F_A::FDTS_DIV8_N6,
                    9 => IC1F_A::FDTS_DIV8_N8,
                    10 => IC1F_A::FDTS_DIV16_N5,
                    11 => IC1F_A::FDTS_DIV16_N6,
                    12 => IC1F_A::FDTS_DIV16_N8,
                    13 => IC1F_A::FDTS_DIV32_N5,
                    14 => IC1F_A::FDTS_DIV32_N6,
                    15 => IC1F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NOFILTER`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                **self == IC1F_A::NOFILTER
            }
            ///Checks if the value of the field is `FCK_INT_N2`
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                **self == IC1F_A::FCK_INT_N2
            }
            ///Checks if the value of the field is `FCK_INT_N4`
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                **self == IC1F_A::FCK_INT_N4
            }
            ///Checks if the value of the field is `FCK_INT_N8`
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                **self == IC1F_A::FCK_INT_N8
            }
            ///Checks if the value of the field is `FDTS_DIV2_N6`
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV2_N6
            }
            ///Checks if the value of the field is `FDTS_DIV2_N8`
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV2_N8
            }
            ///Checks if the value of the field is `FDTS_DIV4_N6`
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV4_N6
            }
            ///Checks if the value of the field is `FDTS_DIV4_N8`
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV4_N8
            }
            ///Checks if the value of the field is `FDTS_DIV8_N6`
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV8_N6
            }
            ///Checks if the value of the field is `FDTS_DIV8_N8`
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV8_N8
            }
            ///Checks if the value of the field is `FDTS_DIV16_N5`
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N5
            }
            ///Checks if the value of the field is `FDTS_DIV16_N6`
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N6
            }
            ///Checks if the value of the field is `FDTS_DIV16_N8`
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N8
            }
            ///Checks if the value of the field is `FDTS_DIV32_N5`
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N5
            }
            ///Checks if the value of the field is `FDTS_DIV32_N6`
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N6
            }
            ///Checks if the value of the field is `FDTS_DIV32_N8`
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N8
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, IC1F_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///No filter, sampling is done at fDTS
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NOFILTER)
            }
            ///fSAMPLING=fCK_INT, N=2
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N2)
            }
            ///fSAMPLING=fCK_INT, N=4
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N4)
            }
            ///fSAMPLING=fCK_INT, N=8
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N8)
            }
            ///fSAMPLING=fDTS/2, N=6
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N6)
            }
            ///fSAMPLING=fDTS/2, N=8
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N8)
            }
            ///fSAMPLING=fDTS/4, N=6
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N6)
            }
            ///fSAMPLING=fDTS/4, N=8
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N8)
            }
            ///fSAMPLING=fDTS/8, N=6
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N6)
            }
            ///fSAMPLING=fDTS/8, N=8
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N8)
            }
            ///fSAMPLING=fDTS/16, N=5
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N5)
            }
            ///fSAMPLING=fDTS/16, N=6
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N6)
            }
            ///fSAMPLING=fDTS/16, N=8
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N8)
            }
            ///fSAMPLING=fDTS/32, N=5
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N5)
            }
            ///fSAMPLING=fDTS/32, N=6
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N6)
            }
            ///fSAMPLING=fDTS/32, N=8
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///1: CC1 channel is configured as input, IC1 is mapped on TI1
            TI1 = 1,
            ///2: CC1 channel is configured as input, IC1 is mapped on TI2
            TI2 = 2,
            ///3: CC1 channel is configured as input, IC1 is mapped on TRC
            TRC = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, CC1S_A>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC1S_A> {
                match self.bits {
                    1 => Some(CC1S_A::TI1),
                    2 => Some(CC1S_A::TI2),
                    3 => Some(CC1S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI1`
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                **self == CC1S_A::TI1
            }
            ///Checks if the value of the field is `TI2`
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                **self == CC1S_A::TI2
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC1S_A::TRC
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, CC1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC1 channel is configured as input, IC1 is mapped on TI1
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1S_A::TI1)
            }
            ///CC1 channel is configured as input, IC1 is mapped on TI2
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1S_A::TI2)
            }
            ///CC1 channel is configured as input, IC1 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 15:18 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 15) & 0x0f) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 15:18 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR2_Output register accessor: an alias for `Reg<CCMR2_OUTPUT_SPEC>`
    pub type CCMR2_OUTPUT = crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod ccmr2_output {
        ///Register `CCMR2_Output` reader
        pub struct R(crate::R<CCMR2_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR2_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR2_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR2_Output` writer
        pub struct W(crate::W<CCMR2_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR2_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR2_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub struct OC4CE_R(crate::FieldReader<bool, bool>);
        impl OC4CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC4CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub struct OC4CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Output compare 4 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC4M_A {
            ///0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            FROZEN = 0,
            ///1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            ACTIVEONMATCH = 1,
            ///2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            INACTIVEONMATCH = 2,
            ///3: OCyREF toggles when TIMx_CNT=TIMx_CCRy
            TOGGLE = 3,
            ///4: OCyREF is forced low
            FORCEINACTIVE = 4,
            ///5: OCyREF is forced high
            FORCEACTIVE = 5,
            ///6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            PWMMODE1 = 6,
            ///7: Inversely to PwmMode1
            PWMMODE2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        ///Field `OC4M` reader - Output compare 4 mode
        pub struct OC4M_R(crate::FieldReader<u8, OC4M_A>);
        impl OC4M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC4M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::FROZEN,
                    1 => OC4M_A::ACTIVEONMATCH,
                    2 => OC4M_A::INACTIVEONMATCH,
                    3 => OC4M_A::TOGGLE,
                    4 => OC4M_A::FORCEINACTIVE,
                    5 => OC4M_A::FORCEACTIVE,
                    6 => OC4M_A::PWMMODE1,
                    7 => OC4M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `FROZEN`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                **self == OC4M_A::FROZEN
            }
            ///Checks if the value of the field is `ACTIVEONMATCH`
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                **self == OC4M_A::ACTIVEONMATCH
            }
            ///Checks if the value of the field is `INACTIVEONMATCH`
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                **self == OC4M_A::INACTIVEONMATCH
            }
            ///Checks if the value of the field is `TOGGLE`
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                **self == OC4M_A::TOGGLE
            }
            ///Checks if the value of the field is `FORCEINACTIVE`
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                **self == OC4M_A::FORCEINACTIVE
            }
            ///Checks if the value of the field is `FORCEACTIVE`
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                **self == OC4M_A::FORCEACTIVE
            }
            ///Checks if the value of the field is `PWMMODE1`
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                **self == OC4M_A::PWMMODE1
            }
            ///Checks if the value of the field is `PWMMODE2`
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                **self == OC4M_A::PWMMODE2
            }
        }
        impl core::ops::Deref for OC4M_R {
            type Target = crate::FieldReader<u8, OC4M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4M` writer - Output compare 4 mode
        pub struct OC4M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC4M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Output compare 4 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC4PE_A {
            ///0: Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC4PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC4PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub struct OC4PE_R(crate::FieldReader<bool, OC4PE_A>);
        impl OC4PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4PE_A {
                match self.bits {
                    false => OC4PE_A::DISABLED,
                    true => OC4PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC4PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC4PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC4PE_R {
            type Target = crate::FieldReader<bool, OC4PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub struct OC4PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC4PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC4PE_A::DISABLED)
            }
            ///Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC4PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub struct OC4FE_R(crate::FieldReader<bool, bool>);
        impl OC4FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC4FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub struct OC4FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub struct CC4S_R(crate::FieldReader<u8, CC4S_A>);
        impl CC4S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC4S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4S_A> {
                match self.bits {
                    0 => Some(CC4S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC4S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC4S_R {
            type Target = crate::FieldReader<u8, CC4S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC4 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub struct OC3CE_R(crate::FieldReader<bool, bool>);
        impl OC3CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC3CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub struct OC3CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Output compare 3 mode
        pub type OC3M_A = OC4M_A;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = OC4M_R;
        ///Field `OC3M` writer - Output compare 3 mode
        pub struct OC3M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC3M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC3M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC3M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC3M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC3M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC3M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC3M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC3M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC3M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Output compare 3 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC3PE_A {
            ///0: Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub struct OC3PE_R(crate::FieldReader<bool, OC3PE_A>);
        impl OC3PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::DISABLED,
                    true => OC3PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC3PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC3PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC3PE_R {
            type Target = crate::FieldReader<bool, OC3PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub struct OC3PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC3PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::DISABLED)
            }
            ///Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub struct OC3FE_R(crate::FieldReader<bool, bool>);
        impl OC3FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC3FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub struct OC3FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub struct CC3S_R(crate::FieldReader<u8, CC3S_A>);
        impl CC3S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC3S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC3S_A> {
                match self.bits {
                    0 => Some(CC3S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC3S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC3S_R {
            type Target = crate::FieldReader<u8, CC3S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC3 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&mut self) -> OC4CE_W {
                OC4CE_W { w: self }
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&mut self) -> OC4M_W {
                OC4M_W { w: self }
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&mut self) -> OC4PE_W {
                OC4PE_W { w: self }
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&mut self) -> OC4FE_W {
                OC4FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&mut self) -> OC3CE_W {
                OC3CE_W { w: self }
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&mut self) -> OC3M_W {
                OC3M_W { w: self }
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&mut self) -> OC3PE_W {
                OC3PE_W { w: self }
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&mut self) -> OC3FE_W {
                OC3FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr2_output](index.html) module
        pub struct CCMR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR2_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr2_output::R](R) reader structure
        impl crate::Readable for CCMR2_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr2_output::W](W) writer structure
        impl crate::Writable for CCMR2_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR2_Output to value 0
        impl crate::Resettable for CCMR2_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR2_Input register accessor: an alias for `Reg<CCMR2_INPUT_SPEC>`
    pub type CCMR2_INPUT = crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod ccmr2_input {
        ///Register `CCMR2_Input` reader
        pub struct R(crate::R<CCMR2_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR2_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR2_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR2_Input` writer
        pub struct W(crate::W<CCMR2_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR2_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR2_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC4F` reader - Input capture 4 filter
        pub struct IC4F_R(crate::FieldReader<u8, u8>);
        impl IC4F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC4F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC4F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC4F` writer - Input capture 4 filter
        pub struct IC4F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 15)) | ((value as u32 & 0x0f) << 15);
                self.w
            }
        }
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub struct IC4PSC_R(crate::FieldReader<u8, u8>);
        impl IC4PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC4PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC4PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub struct IC4PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///1: CC4 channel is configured as input, IC4 is mapped on TI4
            TI4 = 1,
            ///2: CC4 channel is configured as input, IC4 is mapped on TI3
            TI3 = 2,
            ///3: CC4 channel is configured as input, IC4 is mapped on TRC
            TRC = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub struct CC4S_R(crate::FieldReader<u8, CC4S_A>);
        impl CC4S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC4S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4S_A> {
                match self.bits {
                    1 => Some(CC4S_A::TI4),
                    2 => Some(CC4S_A::TI3),
                    3 => Some(CC4S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI4`
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                **self == CC4S_A::TI4
            }
            ///Checks if the value of the field is `TI3`
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                **self == CC4S_A::TI3
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC4S_A::TRC
            }
        }
        impl core::ops::Deref for CC4S_R {
            type Target = crate::FieldReader<u8, CC4S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC4 channel is configured as input, IC4 is mapped on TI4
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4S_A::TI4)
            }
            ///CC4 channel is configured as input, IC4 is mapped on TI3
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4S_A::TI3)
            }
            ///CC4 channel is configured as input, IC4 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `IC3F` reader - Input capture 3 filter
        pub struct IC3F_R(crate::FieldReader<u8, u8>);
        impl IC3F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC3F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC3F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC3F` writer - Input capture 3 filter
        pub struct IC3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub struct IC3PSC_R(crate::FieldReader<u8, u8>);
        impl IC3PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC3PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC3PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub struct IC3PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Capture/compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///1: CC3 channel is configured as input, IC3 is mapped on TI3
            TI3 = 1,
            ///2: CC3 channel is configured as input, IC3 is mapped on TI4
            TI4 = 2,
            ///3: CC3 channel is configured as input, IC3 is mapped on TRC
            TRC = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC3S` reader - Capture/compare 3 selection
        pub struct CC3S_R(crate::FieldReader<u8, CC3S_A>);
        impl CC3S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC3S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC3S_A> {
                match self.bits {
                    1 => Some(CC3S_A::TI3),
                    2 => Some(CC3S_A::TI4),
                    3 => Some(CC3S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI3`
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                **self == CC3S_A::TI3
            }
            ///Checks if the value of the field is `TI4`
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                **self == CC3S_A::TI4
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC3S_A::TRC
            }
        }
        impl core::ops::Deref for CC3S_R {
            type Target = crate::FieldReader<u8, CC3S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3S` writer - Capture/compare 3 selection
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC3 channel is configured as input, IC3 is mapped on TI3
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3S_A::TI3)
            }
            ///CC3 channel is configured as input, IC3 is mapped on TI4
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3S_A::TI4)
            }
            ///CC3 channel is configured as input, IC3 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 15:18 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 15) & 0x0f) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 15:18 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&mut self) -> IC4F_W {
                IC4F_W { w: self }
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&mut self) -> IC4PSC_W {
                IC4PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&mut self) -> IC3F_W {
                IC3F_W { w: self }
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&mut self) -> IC3PSC_W {
                IC3PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/compare 3 selection
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr2_input](index.html) module
        pub struct CCMR2_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR2_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr2_input::R](R) reader structure
        impl crate::Readable for CCMR2_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr2_input::W](W) writer structure
        impl crate::Writable for CCMR2_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR2_Input to value 0
        impl crate::Resettable for CCMR2_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub struct CC4P_R(crate::FieldReader<bool, bool>);
        impl CC4P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC4P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub struct CC4P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub struct CC4E_R(crate::FieldReader<bool, bool>);
        impl CC4E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC4E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub struct CC4E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `CC3NP` reader - Capture/Compare 3 output Polarity
        pub struct CC3NP_R(crate::FieldReader<bool, bool>);
        impl CC3NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3NP` writer - Capture/Compare 3 output Polarity
        pub struct CC3NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `CC3NE` reader - Capture/Compare 3 complementary output enable
        pub struct CC3NE_R(crate::FieldReader<bool, bool>);
        impl CC3NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3NE` writer - Capture/Compare 3 complementary output enable
        pub struct CC3NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3NE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub struct CC3P_R(crate::FieldReader<bool, bool>);
        impl CC3P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub struct CC3P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub struct CC3E_R(crate::FieldReader<bool, bool>);
        impl CC3E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub struct CC3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub struct CC2NP_R(crate::FieldReader<bool, bool>);
        impl CC2NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `CC2NE` reader - Capture/Compare 2 complementary output enable
        pub struct CC2NE_R(crate::FieldReader<bool, bool>);
        impl CC2NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2NE` writer - Capture/Compare 2 complementary output enable
        pub struct CC2NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub struct CC2P_R(crate::FieldReader<bool, bool>);
        impl CC2P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub struct CC2E_R(crate::FieldReader<bool, bool>);
        impl CC2E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub struct CC1NP_R(crate::FieldReader<bool, bool>);
        impl CC1NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub struct CC1NE_R(crate::FieldReader<bool, bool>);
        impl CC1NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&self) -> CC3NP_R {
                CC3NP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&self) -> CC3NE_R {
                CC3NE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&self) -> CC2NE_R {
                CC2NE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&mut self) -> CC4P_W {
                CC4P_W { w: self }
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&mut self) -> CC4E_W {
                CC4E_W { w: self }
            }
            ///Bit 11 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3np(&mut self) -> CC3NP_W {
                CC3NP_W { w: self }
            }
            ///Bit 10 - Capture/Compare 3 complementary output enable
            #[inline(always)]
            pub fn cc3ne(&mut self) -> CC3NE_W {
                CC3NE_W { w: self }
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&mut self) -> CC3P_W {
                CC3P_W { w: self }
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&mut self) -> CC3E_W {
                CC3E_W { w: self }
            }
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            ///Bit 6 - Capture/Compare 2 complementary output enable
            #[inline(always)]
            pub fn cc2ne(&mut self) -> CC2NE_W {
                CC2NE_W { w: self }
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR register accessor: an alias for `Reg<CCR_SPEC>`
    pub type CCR = crate::Reg<ccr::CCR_SPEC>;
    ///capture/compare register 1
    pub mod ccr {
        ///Register `CCR%s` reader
        pub struct R(crate::R<CCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR_SPEC>> for R {
            fn from(reader: crate::R<CCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR%s` writer
        pub struct W(crate::W<CCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR_SPEC>> for W {
            fn from(writer: crate::W<CCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Capture/Compare 1 value
        pub struct CCR_R(crate::FieldReader<u16, u16>);
        impl CCR_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR` writer - Capture/Compare 1 value
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr](index.html) module
        pub struct CCR_SPEC;
        impl crate::RegisterSpec for CCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr::R](R) reader structure
        impl crate::Readable for CCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr::W](W) writer structure
        impl crate::Writable for CCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR%s to value 0
        impl crate::Resettable for CCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DCR register accessor: an alias for `Reg<DCR_SPEC>`
    pub type DCR = crate::Reg<dcr::DCR_SPEC>;
    ///DMA control register
    pub mod dcr {
        ///Register `DCR` reader
        pub struct R(crate::R<DCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DCR_SPEC>> for R {
            fn from(reader: crate::R<DCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DCR` writer
        pub struct W(crate::W<DCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DCR_SPEC>> for W {
            fn from(writer: crate::W<DCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBL` reader - DMA burst length
        pub struct DBL_R(crate::FieldReader<u8, u8>);
        impl DBL_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBL` writer - DMA burst length
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | ((value as u32 & 0x1f) << 8);
                self.w
            }
        }
        ///Field `DBA` reader - DMA base address
        pub struct DBA_R(crate::FieldReader<u8, u8>);
        impl DBA_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBA_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBA` writer - DMA base address
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dcr](index.html) module
        pub struct DCR_SPEC;
        impl crate::RegisterSpec for DCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dcr::R](R) reader structure
        impl crate::Readable for DCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dcr::W](W) writer structure
        impl crate::Writable for DCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DCR to value 0
        impl crate::Resettable for DCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DMAR register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DMAR_SPEC>> for R {
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DMAR_SPEC>> for W {
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub struct DMAB_R(crate::FieldReader<u16, u16>);
        impl DMAB_R {
            pub(crate) fn new(bits: u16) -> Self {
                DMAB_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DMAB_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAB` writer - DMA register for burst accesses
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RCR register accessor: an alias for `Reg<RCR_SPEC>`
    pub type RCR = crate::Reg<rcr::RCR_SPEC>;
    ///repetition counter register
    pub mod rcr {
        ///Register `RCR` reader
        pub struct R(crate::R<RCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RCR_SPEC>> for R {
            fn from(reader: crate::R<RCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RCR` writer
        pub struct W(crate::W<RCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RCR_SPEC>> for W {
            fn from(writer: crate::W<RCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `REP` reader - Repetition counter value
        pub struct REP_R(crate::FieldReader<u8, u8>);
        impl REP_R {
            pub(crate) fn new(bits: u8) -> Self {
                REP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for REP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `REP` writer - Repetition counter value
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rcr](index.html) module
        pub struct RCR_SPEC;
        impl crate::RegisterSpec for RCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rcr::R](R) reader structure
        impl crate::Readable for RCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rcr::W](W) writer structure
        impl crate::Writable for RCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RCR to value 0
        impl crate::Resettable for RCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BDTR register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BDTR_SPEC>> for R {
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BDTR_SPEC>> for W {
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Main output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MOE_A {
            ///0: OC/OCN are disabled or forced idle depending on OSSI
            DISABLEDIDLE = 0,
            ///1: OC/OCN are enabled if CCxE/CCxNE are set
            ENABLED = 1,
        }
        impl From<MOE_A> for bool {
            #[inline(always)]
            fn from(variant: MOE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MOE` reader - Main output enable
        pub struct MOE_R(crate::FieldReader<bool, MOE_A>);
        impl MOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                MOE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MOE_A {
                match self.bits {
                    false => MOE_A::DISABLEDIDLE,
                    true => MOE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLEDIDLE`
            #[inline(always)]
            pub fn is_disabled_idle(&self) -> bool {
                **self == MOE_A::DISABLEDIDLE
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == MOE_A::ENABLED
            }
        }
        impl core::ops::Deref for MOE_R {
            type Target = crate::FieldReader<bool, MOE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MOE` writer - Main output enable
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MOE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///OC/OCN are disabled or forced idle depending on OSSI
            #[inline(always)]
            pub fn disabled_idle(self) -> &'a mut W {
                self.variant(MOE_A::DISABLEDIDLE)
            }
            ///OC/OCN are enabled if CCxE/CCxNE are set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(MOE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `AOE` reader - Automatic output enable
        pub struct AOE_R(crate::FieldReader<bool, bool>);
        impl AOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                AOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for AOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AOE` writer - Automatic output enable
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `BKP` reader - Break polarity
        pub struct BKP_R(crate::FieldReader<bool, bool>);
        impl BKP_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKP` writer - Break polarity
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `BKE` reader - Break enable
        pub struct BKE_R(crate::FieldReader<bool, bool>);
        impl BKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKE` writer - Break enable
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Off-state selection for Run mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OSSR_A {
            ///0: When inactive, OC/OCN outputs are disabled
            DISABLED = 0,
            ///1: When inactive, OC/OCN outputs are enabled with their inactive level
            IDLELEVEL = 1,
        }
        impl From<OSSR_A> for bool {
            #[inline(always)]
            fn from(variant: OSSR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub struct OSSR_R(crate::FieldReader<bool, OSSR_A>);
        impl OSSR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OSSR_A {
                match self.bits {
                    false => OSSR_A::DISABLED,
                    true => OSSR_A::IDLELEVEL,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OSSR_A::DISABLED
            }
            ///Checks if the value of the field is `IDLELEVEL`
            #[inline(always)]
            pub fn is_idle_level(&self) -> bool {
                **self == OSSR_A::IDLELEVEL
            }
        }
        impl core::ops::Deref for OSSR_R {
            type Target = crate::FieldReader<bool, OSSR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OSSR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///When inactive, OC/OCN outputs are disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OSSR_A::DISABLED)
            }
            ///When inactive, OC/OCN outputs are enabled with their inactive level
            #[inline(always)]
            pub fn idle_level(self) -> &'a mut W {
                self.variant(OSSR_A::IDLELEVEL)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Off-state selection for Idle mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OSSI_A {
            ///0: When inactive, OC/OCN outputs are disabled
            DISABLED = 0,
            ///1: When inactive, OC/OCN outputs are forced to idle level
            IDLELEVEL = 1,
        }
        impl From<OSSI_A> for bool {
            #[inline(always)]
            fn from(variant: OSSI_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub struct OSSI_R(crate::FieldReader<bool, OSSI_A>);
        impl OSSI_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSI_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OSSI_A {
                match self.bits {
                    false => OSSI_A::DISABLED,
                    true => OSSI_A::IDLELEVEL,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OSSI_A::DISABLED
            }
            ///Checks if the value of the field is `IDLELEVEL`
            #[inline(always)]
            pub fn is_idle_level(&self) -> bool {
                **self == OSSI_A::IDLELEVEL
            }
        }
        impl core::ops::Deref for OSSI_R {
            type Target = crate::FieldReader<bool, OSSI_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OSSI_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///When inactive, OC/OCN outputs are disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OSSI_A::DISABLED)
            }
            ///When inactive, OC/OCN outputs are forced to idle level
            #[inline(always)]
            pub fn idle_level(self) -> &'a mut W {
                self.variant(OSSI_A::IDLELEVEL)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `LOCK` reader - Lock configuration
        pub struct LOCK_R(crate::FieldReader<u8, u8>);
        impl LOCK_R {
            pub(crate) fn new(bits: u8) -> Self {
                LOCK_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LOCK_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LOCK` writer - Lock configuration
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub struct DTG_R(crate::FieldReader<u8, u8>);
        impl DTG_R {
            pub(crate) fn new(bits: u8) -> Self {
                DTG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DTG_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DTG` writer - Dead-time generator setup
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose timer
pub struct TIM2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM2 {}
impl TIM2 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM2 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM2").finish()
    }
}
///General purpose timer
pub mod tim2 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - slave mode control register
        pub smcr: crate::Reg<smcr::SMCR_SPEC>,
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved_7_ccmr2: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        _reserved12: [u8; 4usize],
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr::CCR_SPEC>,
        ///0x38 - capture/compare register 1
        pub ccr2: crate::Reg<ccr::CCR_SPEC>,
        ///0x3c - capture/compare register 1
        pub ccr3: crate::Reg<ccr::CCR_SPEC>,
        ///0x40 - capture/compare register 1
        pub ccr4: crate::Reg<ccr::CCR_SPEC>,
        _reserved16: [u8; 4usize],
        ///0x48 - DMA control register
        pub dcr: crate::Reg<dcr::DCR_SPEC>,
        ///0x4c - DMA address for full transfer
        pub dmar: crate::Reg<dmar::DMAR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register 1 (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
        ///0x1c - capture/compare mode register 2 (input mode)
        #[inline(always)]
        pub fn ccmr2_input(&self) -> &crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(28usize)
                    as *const crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC>)
            }
        }
        ///0x1c - capture/compare mode register 2 (output mode)
        #[inline(always)]
        pub fn ccmr2_output(&self) -> &crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(28usize)
                    as *const crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Center-aligned mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CMS_A {
            ///0: The counter counts up or down depending on the direction bit
            EDGEALIGNED = 0,
            ///1: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
            CENTERALIGNED1 = 1,
            ///2: The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
            CENTERALIGNED2 = 2,
            ///3: The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            CENTERALIGNED3 = 3,
        }
        impl From<CMS_A> for u8 {
            #[inline(always)]
            fn from(variant: CMS_A) -> Self {
                variant as _
            }
        }
        ///Field `CMS` reader - Center-aligned mode selection
        pub struct CMS_R(crate::FieldReader<u8, CMS_A>);
        impl CMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                CMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CMS_A {
                match self.bits {
                    0 => CMS_A::EDGEALIGNED,
                    1 => CMS_A::CENTERALIGNED1,
                    2 => CMS_A::CENTERALIGNED2,
                    3 => CMS_A::CENTERALIGNED3,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `EDGEALIGNED`
            #[inline(always)]
            pub fn is_edge_aligned(&self) -> bool {
                **self == CMS_A::EDGEALIGNED
            }
            ///Checks if the value of the field is `CENTERALIGNED1`
            #[inline(always)]
            pub fn is_center_aligned1(&self) -> bool {
                **self == CMS_A::CENTERALIGNED1
            }
            ///Checks if the value of the field is `CENTERALIGNED2`
            #[inline(always)]
            pub fn is_center_aligned2(&self) -> bool {
                **self == CMS_A::CENTERALIGNED2
            }
            ///Checks if the value of the field is `CENTERALIGNED3`
            #[inline(always)]
            pub fn is_center_aligned3(&self) -> bool {
                **self == CMS_A::CENTERALIGNED3
            }
        }
        impl core::ops::Deref for CMS_R {
            type Target = crate::FieldReader<u8, CMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CMS` writer - Center-aligned mode selection
        pub struct CMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The counter counts up or down depending on the direction bit
            #[inline(always)]
            pub fn edge_aligned(self) -> &'a mut W {
                self.variant(CMS_A::EDGEALIGNED)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting down.
            #[inline(always)]
            pub fn center_aligned1(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED1)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set only when the counter is counting up.
            #[inline(always)]
            pub fn center_aligned2(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED2)
            }
            ///The counter counts up and down alternatively. Output compare interrupt flags are set both when the counter is counting up or down.
            #[inline(always)]
            pub fn center_aligned3(self) -> &'a mut W {
                self.variant(CMS_A::CENTERALIGNED3)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 5)) | ((value as u32 & 0x03) << 5);
                self.w
            }
        }
        ///Direction
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DIR_A {
            ///0: Counter used as upcounter
            UP = 0,
            ///1: Counter used as downcounter
            DOWN = 1,
        }
        impl From<DIR_A> for bool {
            #[inline(always)]
            fn from(variant: DIR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DIR` reader - Direction
        pub struct DIR_R(crate::FieldReader<bool, DIR_A>);
        impl DIR_R {
            pub(crate) fn new(bits: bool) -> Self {
                DIR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DIR_A {
                match self.bits {
                    false => DIR_A::UP,
                    true => DIR_A::DOWN,
                }
            }
            ///Checks if the value of the field is `UP`
            #[inline(always)]
            pub fn is_up(&self) -> bool {
                **self == DIR_A::UP
            }
            ///Checks if the value of the field is `DOWN`
            #[inline(always)]
            pub fn is_down(&self) -> bool {
                **self == DIR_A::DOWN
            }
        }
        impl core::ops::Deref for DIR_R {
            type Target = crate::FieldReader<bool, DIR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIR` writer - Direction
        pub struct DIR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DIR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter used as upcounter
            #[inline(always)]
            pub fn up(self) -> &'a mut W {
                self.variant(DIR_A::UP)
            }
            ///Counter used as downcounter
            #[inline(always)]
            pub fn down(self) -> &'a mut W {
                self.variant(DIR_A::DOWN)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            ///0: Counter is not stopped at update event
            DISABLED = 0,
            ///1: Counter stops counting at the next update event (clearing the CEN bit)
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, OPM_A>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OPM_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OPM_A::ENABLED
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, OPM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter is not stopped at update event
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            ///Counter stops counting at the next update event (clearing the CEN bit)
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&self) -> CMS_R {
                CMS_R::new(((self.bits >> 5) & 0x03) as u8)
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&self) -> DIR_R {
                DIR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bits 5:6 - Center-aligned mode selection
            #[inline(always)]
            pub fn cms(&mut self) -> CMS_W {
                CMS_W { w: self }
            }
            ///Bit 4 - Direction
            #[inline(always)]
            pub fn dir(&mut self) -> DIR_W {
                DIR_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///TI1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TI1S_A {
            ///0: The TIMx_CH1 pin is connected to TI1 input
            NORMAL = 0,
            ///1: The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            XOR = 1,
        }
        impl From<TI1S_A> for bool {
            #[inline(always)]
            fn from(variant: TI1S_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TI1S` reader - TI1 selection
        pub struct TI1S_R(crate::FieldReader<bool, TI1S_A>);
        impl TI1S_R {
            pub(crate) fn new(bits: bool) -> Self {
                TI1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TI1S_A {
                match self.bits {
                    false => TI1S_A::NORMAL,
                    true => TI1S_A::XOR,
                }
            }
            ///Checks if the value of the field is `NORMAL`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                **self == TI1S_A::NORMAL
            }
            ///Checks if the value of the field is `XOR`
            #[inline(always)]
            pub fn is_xor(&self) -> bool {
                **self == TI1S_A::XOR
            }
        }
        impl core::ops::Deref for TI1S_R {
            type Target = crate::FieldReader<bool, TI1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TI1S` writer - TI1 selection
        pub struct TI1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TI1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TI1S_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The TIMx_CH1 pin is connected to TI1 input
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(TI1S_A::NORMAL)
            }
            ///The TIMx_CH1, CH2, CH3 pins are connected to TI1 input
            #[inline(always)]
            pub fn xor(self) -> &'a mut W {
                self.variant(TI1S_A::XOR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            ///0: The UG bit from the TIMx_EGR register is used as trigger output
            RESET = 0,
            ///1: The counter enable signal, CNT_EN, is used as trigger output
            ENABLE = 1,
            ///2: The update event is selected as trigger output
            UPDATE = 2,
            ///3: The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
            COMPAREPULSE = 3,
            ///4: OC1REF signal is used as trigger output
            COMPAREOC1 = 4,
            ///5: OC2REF signal is used as trigger output
            COMPAREOC2 = 5,
            ///6: OC3REF signal is used as trigger output
            COMPAREOC3 = 6,
            ///7: OC4REF signal is used as trigger output
            COMPAREOC4 = 7,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub struct MMS_R(crate::FieldReader<u8, MMS_A>);
        impl MMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                MMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MMS_A {
                match self.bits {
                    0 => MMS_A::RESET,
                    1 => MMS_A::ENABLE,
                    2 => MMS_A::UPDATE,
                    3 => MMS_A::COMPAREPULSE,
                    4 => MMS_A::COMPAREOC1,
                    5 => MMS_A::COMPAREOC2,
                    6 => MMS_A::COMPAREOC3,
                    7 => MMS_A::COMPAREOC4,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == MMS_A::RESET
            }
            ///Checks if the value of the field is `ENABLE`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                **self == MMS_A::ENABLE
            }
            ///Checks if the value of the field is `UPDATE`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                **self == MMS_A::UPDATE
            }
            ///Checks if the value of the field is `COMPAREPULSE`
            #[inline(always)]
            pub fn is_compare_pulse(&self) -> bool {
                **self == MMS_A::COMPAREPULSE
            }
            ///Checks if the value of the field is `COMPAREOC1`
            #[inline(always)]
            pub fn is_compare_oc1(&self) -> bool {
                **self == MMS_A::COMPAREOC1
            }
            ///Checks if the value of the field is `COMPAREOC2`
            #[inline(always)]
            pub fn is_compare_oc2(&self) -> bool {
                **self == MMS_A::COMPAREOC2
            }
            ///Checks if the value of the field is `COMPAREOC3`
            #[inline(always)]
            pub fn is_compare_oc3(&self) -> bool {
                **self == MMS_A::COMPAREOC3
            }
            ///Checks if the value of the field is `COMPAREOC4`
            #[inline(always)]
            pub fn is_compare_oc4(&self) -> bool {
                **self == MMS_A::COMPAREOC4
            }
        }
        impl core::ops::Deref for MMS_R {
            type Target = crate::FieldReader<u8, MMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The UG bit from the TIMx_EGR register is used as trigger output
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            ///The counter enable signal, CNT_EN, is used as trigger output
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            ///The update event is selected as trigger output
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            ///The trigger output send a positive pulse when the CC1IF flag it to be set, as soon as a capture or a compare match occurred
            #[inline(always)]
            pub fn compare_pulse(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREPULSE)
            }
            ///OC1REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc1(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC1)
            }
            ///OC2REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc2(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC2)
            }
            ///OC3REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc3(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC3)
            }
            ///OC4REF signal is used as trigger output
            #[inline(always)]
            pub fn compare_oc4(self) -> &'a mut W {
                self.variant(MMS_A::COMPAREOC4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Capture/compare DMA selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            ///0: CCx DMA request sent when CCx event occurs
            ONCOMPARE = 0,
            ///1: CCx DMA request sent when update event occurs
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub struct CCDS_R(crate::FieldReader<bool, CCDS_A>);
        impl CCDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCDS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            ///Checks if the value of the field is `ONCOMPARE`
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                **self == CCDS_A::ONCOMPARE
            }
            ///Checks if the value of the field is `ONUPDATE`
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                **self == CCDS_A::ONUPDATE
            }
        }
        impl core::ops::Deref for CCDS_R {
            type Target = crate::FieldReader<bool, CCDS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request sent when CCx event occurs
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            ///CCx DMA request sent when update event occurs
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        impl R {
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&self) -> TI1S_R {
                TI1S_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 7 - TI1 selection
            #[inline(always)]
            pub fn ti1s(&mut self) -> TI1S_W {
                TI1S_W { w: self }
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMCR register accessor: an alias for `Reg<SMCR_SPEC>`
    pub type SMCR = crate::Reg<smcr::SMCR_SPEC>;
    ///slave mode control register
    pub mod smcr {
        ///Register `SMCR` reader
        pub struct R(crate::R<SMCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMCR_SPEC>> for R {
            fn from(reader: crate::R<SMCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCR` writer
        pub struct W(crate::W<SMCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMCR_SPEC>> for W {
            fn from(writer: crate::W<SMCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///External trigger polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ETP_A {
            ///0: ETR is noninverted, active at high level or rising edge
            NOTINVERTED = 0,
            ///1: ETR is inverted, active at low level or falling edge
            INVERTED = 1,
        }
        impl From<ETP_A> for bool {
            #[inline(always)]
            fn from(variant: ETP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ETP` reader - External trigger polarity
        pub struct ETP_R(crate::FieldReader<bool, ETP_A>);
        impl ETP_R {
            pub(crate) fn new(bits: bool) -> Self {
                ETP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETP_A {
                match self.bits {
                    false => ETP_A::NOTINVERTED,
                    true => ETP_A::INVERTED,
                }
            }
            ///Checks if the value of the field is `NOTINVERTED`
            #[inline(always)]
            pub fn is_not_inverted(&self) -> bool {
                **self == ETP_A::NOTINVERTED
            }
            ///Checks if the value of the field is `INVERTED`
            #[inline(always)]
            pub fn is_inverted(&self) -> bool {
                **self == ETP_A::INVERTED
            }
        }
        impl core::ops::Deref for ETP_R {
            type Target = crate::FieldReader<bool, ETP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETP` writer - External trigger polarity
        pub struct ETP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///ETR is noninverted, active at high level or rising edge
            #[inline(always)]
            pub fn not_inverted(self) -> &'a mut W {
                self.variant(ETP_A::NOTINVERTED)
            }
            ///ETR is inverted, active at low level or falling edge
            #[inline(always)]
            pub fn inverted(self) -> &'a mut W {
                self.variant(ETP_A::INVERTED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///External clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ECE_A {
            ///0: External clock mode 2 disabled
            DISABLED = 0,
            ///1: External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            ENABLED = 1,
        }
        impl From<ECE_A> for bool {
            #[inline(always)]
            fn from(variant: ECE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ECE` reader - External clock enable
        pub struct ECE_R(crate::FieldReader<bool, ECE_A>);
        impl ECE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ECE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ECE_A {
                match self.bits {
                    false => ECE_A::DISABLED,
                    true => ECE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ECE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ECE_A::ENABLED
            }
        }
        impl core::ops::Deref for ECE_R {
            type Target = crate::FieldReader<bool, ECE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ECE` writer - External clock enable
        pub struct ECE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ECE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ECE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///External clock mode 2 disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ECE_A::DISABLED)
            }
            ///External clock mode 2 enabled. The counter is clocked by any active edge on the ETRF signal.
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ECE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///External trigger prescaler
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETPS_A {
            ///0: Prescaler OFF
            DIV1 = 0,
            ///1: ETRP frequency divided by 2
            DIV2 = 1,
            ///2: ETRP frequency divided by 4
            DIV4 = 2,
            ///3: ETRP frequency divided by 8
            DIV8 = 3,
        }
        impl From<ETPS_A> for u8 {
            #[inline(always)]
            fn from(variant: ETPS_A) -> Self {
                variant as _
            }
        }
        ///Field `ETPS` reader - External trigger prescaler
        pub struct ETPS_R(crate::FieldReader<u8, ETPS_A>);
        impl ETPS_R {
            pub(crate) fn new(bits: u8) -> Self {
                ETPS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETPS_A {
                match self.bits {
                    0 => ETPS_A::DIV1,
                    1 => ETPS_A::DIV2,
                    2 => ETPS_A::DIV4,
                    3 => ETPS_A::DIV8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == ETPS_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == ETPS_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == ETPS_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == ETPS_A::DIV8
            }
        }
        impl core::ops::Deref for ETPS_R {
            type Target = crate::FieldReader<u8, ETPS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETPS` writer - External trigger prescaler
        pub struct ETPS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETPS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETPS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Prescaler OFF
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(ETPS_A::DIV1)
            }
            ///ETRP frequency divided by 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(ETPS_A::DIV2)
            }
            ///ETRP frequency divided by 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(ETPS_A::DIV4)
            }
            ///ETRP frequency divided by 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(ETPS_A::DIV8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///External trigger filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum ETF_A {
            ///0: No filter, sampling is done at fDTS
            NOFILTER = 0,
            ///1: fSAMPLING=fCK_INT, N=2
            FCK_INT_N2 = 1,
            ///2: fSAMPLING=fCK_INT, N=4
            FCK_INT_N4 = 2,
            ///3: fSAMPLING=fCK_INT, N=8
            FCK_INT_N8 = 3,
            ///4: fSAMPLING=fDTS/2, N=6
            FDTS_DIV2_N6 = 4,
            ///5: fSAMPLING=fDTS/2, N=8
            FDTS_DIV2_N8 = 5,
            ///6: fSAMPLING=fDTS/4, N=6
            FDTS_DIV4_N6 = 6,
            ///7: fSAMPLING=fDTS/4, N=8
            FDTS_DIV4_N8 = 7,
            ///8: fSAMPLING=fDTS/8, N=6
            FDTS_DIV8_N6 = 8,
            ///9: fSAMPLING=fDTS/8, N=8
            FDTS_DIV8_N8 = 9,
            ///10: fSAMPLING=fDTS/16, N=5
            FDTS_DIV16_N5 = 10,
            ///11: fSAMPLING=fDTS/16, N=6
            FDTS_DIV16_N6 = 11,
            ///12: fSAMPLING=fDTS/16, N=8
            FDTS_DIV16_N8 = 12,
            ///13: fSAMPLING=fDTS/32, N=5
            FDTS_DIV32_N5 = 13,
            ///14: fSAMPLING=fDTS/32, N=6
            FDTS_DIV32_N6 = 14,
            ///15: fSAMPLING=fDTS/32, N=8
            FDTS_DIV32_N8 = 15,
        }
        impl From<ETF_A> for u8 {
            #[inline(always)]
            fn from(variant: ETF_A) -> Self {
                variant as _
            }
        }
        ///Field `ETF` reader - External trigger filter
        pub struct ETF_R(crate::FieldReader<u8, ETF_A>);
        impl ETF_R {
            pub(crate) fn new(bits: u8) -> Self {
                ETF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ETF_A {
                match self.bits {
                    0 => ETF_A::NOFILTER,
                    1 => ETF_A::FCK_INT_N2,
                    2 => ETF_A::FCK_INT_N4,
                    3 => ETF_A::FCK_INT_N8,
                    4 => ETF_A::FDTS_DIV2_N6,
                    5 => ETF_A::FDTS_DIV2_N8,
                    6 => ETF_A::FDTS_DIV4_N6,
                    7 => ETF_A::FDTS_DIV4_N8,
                    8 => ETF_A::FDTS_DIV8_N6,
                    9 => ETF_A::FDTS_DIV8_N8,
                    10 => ETF_A::FDTS_DIV16_N5,
                    11 => ETF_A::FDTS_DIV16_N6,
                    12 => ETF_A::FDTS_DIV16_N8,
                    13 => ETF_A::FDTS_DIV32_N5,
                    14 => ETF_A::FDTS_DIV32_N6,
                    15 => ETF_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NOFILTER`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                **self == ETF_A::NOFILTER
            }
            ///Checks if the value of the field is `FCK_INT_N2`
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                **self == ETF_A::FCK_INT_N2
            }
            ///Checks if the value of the field is `FCK_INT_N4`
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                **self == ETF_A::FCK_INT_N4
            }
            ///Checks if the value of the field is `FCK_INT_N8`
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                **self == ETF_A::FCK_INT_N8
            }
            ///Checks if the value of the field is `FDTS_DIV2_N6`
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV2_N6
            }
            ///Checks if the value of the field is `FDTS_DIV2_N8`
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV2_N8
            }
            ///Checks if the value of the field is `FDTS_DIV4_N6`
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV4_N6
            }
            ///Checks if the value of the field is `FDTS_DIV4_N8`
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV4_N8
            }
            ///Checks if the value of the field is `FDTS_DIV8_N6`
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV8_N6
            }
            ///Checks if the value of the field is `FDTS_DIV8_N8`
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV8_N8
            }
            ///Checks if the value of the field is `FDTS_DIV16_N5`
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N5
            }
            ///Checks if the value of the field is `FDTS_DIV16_N6`
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N6
            }
            ///Checks if the value of the field is `FDTS_DIV16_N8`
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV16_N8
            }
            ///Checks if the value of the field is `FDTS_DIV32_N5`
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N5
            }
            ///Checks if the value of the field is `FDTS_DIV32_N6`
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N6
            }
            ///Checks if the value of the field is `FDTS_DIV32_N8`
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                **self == ETF_A::FDTS_DIV32_N8
            }
        }
        impl core::ops::Deref for ETF_R {
            type Target = crate::FieldReader<u8, ETF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ETF` writer - External trigger filter
        pub struct ETF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ETF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ETF_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///No filter, sampling is done at fDTS
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(ETF_A::NOFILTER)
            }
            ///fSAMPLING=fCK_INT, N=2
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N2)
            }
            ///fSAMPLING=fCK_INT, N=4
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N4)
            }
            ///fSAMPLING=fCK_INT, N=8
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(ETF_A::FCK_INT_N8)
            }
            ///fSAMPLING=fDTS/2, N=6
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N6)
            }
            ///fSAMPLING=fDTS/2, N=8
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV2_N8)
            }
            ///fSAMPLING=fDTS/4, N=6
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N6)
            }
            ///fSAMPLING=fDTS/4, N=8
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV4_N8)
            }
            ///fSAMPLING=fDTS/8, N=6
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N6)
            }
            ///fSAMPLING=fDTS/8, N=8
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV8_N8)
            }
            ///fSAMPLING=fDTS/16, N=5
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N5)
            }
            ///fSAMPLING=fDTS/16, N=6
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N6)
            }
            ///fSAMPLING=fDTS/16, N=8
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV16_N8)
            }
            ///fSAMPLING=fDTS/32, N=5
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N5)
            }
            ///fSAMPLING=fDTS/32, N=6
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N6)
            }
            ///fSAMPLING=fDTS/32, N=8
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(ETF_A::FDTS_DIV32_N8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///Master/Slave mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSM_A {
            ///0: No action
            NOSYNC = 0,
            ///1: The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            SYNC = 1,
        }
        impl From<MSM_A> for bool {
            #[inline(always)]
            fn from(variant: MSM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub struct MSM_R(crate::FieldReader<bool, MSM_A>);
        impl MSM_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSM_A {
                match self.bits {
                    false => MSM_A::NOSYNC,
                    true => MSM_A::SYNC,
                }
            }
            ///Checks if the value of the field is `NOSYNC`
            #[inline(always)]
            pub fn is_no_sync(&self) -> bool {
                **self == MSM_A::NOSYNC
            }
            ///Checks if the value of the field is `SYNC`
            #[inline(always)]
            pub fn is_sync(&self) -> bool {
                **self == MSM_A::SYNC
            }
        }
        impl core::ops::Deref for MSM_R {
            type Target = crate::FieldReader<bool, MSM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MSM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No action
            #[inline(always)]
            pub fn no_sync(self) -> &'a mut W {
                self.variant(MSM_A::NOSYNC)
            }
            ///The effect of an event on the trigger input (TRGI) is delayed to allow a perfect synchronization between the current timer and its slaves (through TRGO). It is useful if we want to synchronize several timers on a single external event.
            #[inline(always)]
            pub fn sync(self) -> &'a mut W {
                self.variant(MSM_A::SYNC)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TS_A {
            ///0: Internal Trigger 0 (ITR0)
            ITR0 = 0,
            ///1: Internal Trigger 1 (ITR1)
            ITR1 = 1,
            ///2: Internal Trigger 2 (ITR2)
            ITR2 = 2,
            ///4: TI1 Edge Detector (TI1F_ED)
            TI1F_ED = 4,
            ///5: Filtered Timer Input 1 (TI1FP1)
            TI1FP1 = 5,
            ///6: Filtered Timer Input 2 (TI2FP2)
            TI2FP2 = 6,
            ///7: External Trigger input (ETRF)
            ETRF = 7,
        }
        impl From<TS_A> for u8 {
            #[inline(always)]
            fn from(variant: TS_A) -> Self {
                variant as _
            }
        }
        ///Field `TS` reader - Trigger selection
        pub struct TS_R(crate::FieldReader<u8, TS_A>);
        impl TS_R {
            pub(crate) fn new(bits: u8) -> Self {
                TS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TS_A> {
                match self.bits {
                    0 => Some(TS_A::ITR0),
                    1 => Some(TS_A::ITR1),
                    2 => Some(TS_A::ITR2),
                    4 => Some(TS_A::TI1F_ED),
                    5 => Some(TS_A::TI1FP1),
                    6 => Some(TS_A::TI2FP2),
                    7 => Some(TS_A::ETRF),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `ITR0`
            #[inline(always)]
            pub fn is_itr0(&self) -> bool {
                **self == TS_A::ITR0
            }
            ///Checks if the value of the field is `ITR1`
            #[inline(always)]
            pub fn is_itr1(&self) -> bool {
                **self == TS_A::ITR1
            }
            ///Checks if the value of the field is `ITR2`
            #[inline(always)]
            pub fn is_itr2(&self) -> bool {
                **self == TS_A::ITR2
            }
            ///Checks if the value of the field is `TI1F_ED`
            #[inline(always)]
            pub fn is_ti1f_ed(&self) -> bool {
                **self == TS_A::TI1F_ED
            }
            ///Checks if the value of the field is `TI1FP1`
            #[inline(always)]
            pub fn is_ti1fp1(&self) -> bool {
                **self == TS_A::TI1FP1
            }
            ///Checks if the value of the field is `TI2FP2`
            #[inline(always)]
            pub fn is_ti2fp2(&self) -> bool {
                **self == TS_A::TI2FP2
            }
            ///Checks if the value of the field is `ETRF`
            #[inline(always)]
            pub fn is_etrf(&self) -> bool {
                **self == TS_A::ETRF
            }
        }
        impl core::ops::Deref for TS_R {
            type Target = crate::FieldReader<u8, TS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TS` writer - Trigger selection
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Internal Trigger 0 (ITR0)
            #[inline(always)]
            pub fn itr0(self) -> &'a mut W {
                self.variant(TS_A::ITR0)
            }
            ///Internal Trigger 1 (ITR1)
            #[inline(always)]
            pub fn itr1(self) -> &'a mut W {
                self.variant(TS_A::ITR1)
            }
            ///Internal Trigger 2 (ITR2)
            #[inline(always)]
            pub fn itr2(self) -> &'a mut W {
                self.variant(TS_A::ITR2)
            }
            ///TI1 Edge Detector (TI1F_ED)
            #[inline(always)]
            pub fn ti1f_ed(self) -> &'a mut W {
                self.variant(TS_A::TI1F_ED)
            }
            ///Filtered Timer Input 1 (TI1FP1)
            #[inline(always)]
            pub fn ti1fp1(self) -> &'a mut W {
                self.variant(TS_A::TI1FP1)
            }
            ///Filtered Timer Input 2 (TI2FP2)
            #[inline(always)]
            pub fn ti2fp2(self) -> &'a mut W {
                self.variant(TS_A::TI2FP2)
            }
            ///External Trigger input (ETRF)
            #[inline(always)]
            pub fn etrf(self) -> &'a mut W {
                self.variant(TS_A::ETRF)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Slave mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMS_A {
            ///0: Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
            DISABLED = 0,
            ///1: Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
            ENCODER_MODE_1 = 1,
            ///2: Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
            ENCODER_MODE_2 = 2,
            ///3: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
            ENCODER_MODE_3 = 3,
            ///4: Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
            RESET_MODE = 4,
            ///5: Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
            GATED_MODE = 5,
            ///6: Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
            TRIGGER_MODE = 6,
            ///7: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            EXT_CLOCK_MODE = 7,
        }
        impl From<SMS_A> for u8 {
            #[inline(always)]
            fn from(variant: SMS_A) -> Self {
                variant as _
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub struct SMS_R(crate::FieldReader<u8, SMS_A>);
        impl SMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMS_A {
                match self.bits {
                    0 => SMS_A::DISABLED,
                    1 => SMS_A::ENCODER_MODE_1,
                    2 => SMS_A::ENCODER_MODE_2,
                    3 => SMS_A::ENCODER_MODE_3,
                    4 => SMS_A::RESET_MODE,
                    5 => SMS_A::GATED_MODE,
                    6 => SMS_A::TRIGGER_MODE,
                    7 => SMS_A::EXT_CLOCK_MODE,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SMS_A::DISABLED
            }
            ///Checks if the value of the field is `ENCODER_MODE_1`
            #[inline(always)]
            pub fn is_encoder_mode_1(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_1
            }
            ///Checks if the value of the field is `ENCODER_MODE_2`
            #[inline(always)]
            pub fn is_encoder_mode_2(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_2
            }
            ///Checks if the value of the field is `ENCODER_MODE_3`
            #[inline(always)]
            pub fn is_encoder_mode_3(&self) -> bool {
                **self == SMS_A::ENCODER_MODE_3
            }
            ///Checks if the value of the field is `RESET_MODE`
            #[inline(always)]
            pub fn is_reset_mode(&self) -> bool {
                **self == SMS_A::RESET_MODE
            }
            ///Checks if the value of the field is `GATED_MODE`
            #[inline(always)]
            pub fn is_gated_mode(&self) -> bool {
                **self == SMS_A::GATED_MODE
            }
            ///Checks if the value of the field is `TRIGGER_MODE`
            #[inline(always)]
            pub fn is_trigger_mode(&self) -> bool {
                **self == SMS_A::TRIGGER_MODE
            }
            ///Checks if the value of the field is `EXT_CLOCK_MODE`
            #[inline(always)]
            pub fn is_ext_clock_mode(&self) -> bool {
                **self == SMS_A::EXT_CLOCK_MODE
            }
        }
        impl core::ops::Deref for SMS_R {
            type Target = crate::FieldReader<u8, SMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMS_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Slave mode disabled - if CEN = ‘1 then the prescaler is clocked directly by the internal clock.
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SMS_A::DISABLED)
            }
            ///Encoder mode 1 - Counter counts up/down on TI2FP1 edge depending on TI1FP2 level.
            #[inline(always)]
            pub fn encoder_mode_1(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_1)
            }
            ///Encoder mode 2 - Counter counts up/down on TI1FP2 edge depending on TI2FP1 level.
            #[inline(always)]
            pub fn encoder_mode_2(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_2)
            }
            ///Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 edges depending on the level of the other input.
            #[inline(always)]
            pub fn encoder_mode_3(self) -> &'a mut W {
                self.variant(SMS_A::ENCODER_MODE_3)
            }
            ///Reset Mode - Rising edge of the selected trigger input (TRGI) reinitializes the counter and generates an update of the registers.
            #[inline(always)]
            pub fn reset_mode(self) -> &'a mut W {
                self.variant(SMS_A::RESET_MODE)
            }
            ///Gated Mode - The counter clock is enabled when the trigger input (TRGI) is high. The counter stops (but is not reset) as soon as the trigger becomes low. Both start and stop of the counter are controlled.
            #[inline(always)]
            pub fn gated_mode(self) -> &'a mut W {
                self.variant(SMS_A::GATED_MODE)
            }
            ///Trigger Mode - The counter starts at a rising edge of the trigger TRGI (but it is not reset). Only the start of the counter is controlled.
            #[inline(always)]
            pub fn trigger_mode(self) -> &'a mut W {
                self.variant(SMS_A::TRIGGER_MODE)
            }
            ///External Clock Mode 1 - Rising edges of the selected trigger (TRGI) clock the counter.
            #[inline(always)]
            pub fn ext_clock_mode(self) -> &'a mut W {
                self.variant(SMS_A::EXT_CLOCK_MODE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        ///Field `OCCS` reader - OCREF clear selection
        pub struct OCCS_R(crate::FieldReader<bool, bool>);
        impl OCCS_R {
            pub(crate) fn new(bits: bool) -> Self {
                OCCS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OCCS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OCCS` writer - OCREF clear selection
        pub struct OCCS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OCCS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        impl R {
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&self) -> ETP_R {
                ETP_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&self) -> ECE_R {
                ECE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&self) -> ETPS_R {
                ETPS_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&self) -> ETF_R {
                ETF_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
            ///Bit 3 - OCREF clear selection
            #[inline(always)]
            pub fn occs(&self) -> OCCS_R {
                OCCS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 15 - External trigger polarity
            #[inline(always)]
            pub fn etp(&mut self) -> ETP_W {
                ETP_W { w: self }
            }
            ///Bit 14 - External clock enable
            #[inline(always)]
            pub fn ece(&mut self) -> ECE_W {
                ECE_W { w: self }
            }
            ///Bits 12:13 - External trigger prescaler
            #[inline(always)]
            pub fn etps(&mut self) -> ETPS_W {
                ETPS_W { w: self }
            }
            ///Bits 8:11 - External trigger filter
            #[inline(always)]
            pub fn etf(&mut self) -> ETF_W {
                ETF_W { w: self }
            }
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            ///Bit 3 - OCREF clear selection
            #[inline(always)]
            pub fn occs(&mut self) -> OCCS_W {
                OCCS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcr](index.html) module
        pub struct SMCR_SPEC;
        impl crate::RegisterSpec for SMCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcr::R](R) reader structure
        impl crate::Readable for SMCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcr::W](W) writer structure
        impl crate::Writable for SMCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMCR to value 0
        impl crate::Resettable for SMCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Trigger DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TDE_A {
            ///0: Trigger DMA request disabled
            DISABLED = 0,
            ///1: Trigger DMA request enabled
            ENABLED = 1,
        }
        impl From<TDE_A> for bool {
            #[inline(always)]
            fn from(variant: TDE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TDE` reader - Trigger DMA request enable
        pub struct TDE_R(crate::FieldReader<bool, TDE_A>);
        impl TDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TDE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TDE_A {
                match self.bits {
                    false => TDE_A::DISABLED,
                    true => TDE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TDE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TDE_A::ENABLED
            }
        }
        impl core::ops::Deref for TDE_R {
            type Target = crate::FieldReader<bool, TDE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TDE` writer - Trigger DMA request enable
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TDE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Trigger DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TDE_A::DISABLED)
            }
            ///Trigger DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TDE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Capture/Compare 4 DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4DE_A {
            ///0: CCx DMA request disabled
            DISABLED = 0,
            ///1: CCx DMA request enabled
            ENABLED = 1,
        }
        impl From<CC4DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4DE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4DE` reader - Capture/Compare 4 DMA request enable
        pub struct CC4DE_R(crate::FieldReader<bool, CC4DE_A>);
        impl CC4DE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4DE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4DE_A {
                match self.bits {
                    false => CC4DE_A::DISABLED,
                    true => CC4DE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC4DE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC4DE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC4DE_R {
            type Target = crate::FieldReader<bool, CC4DE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4DE` writer - Capture/Compare 4 DMA request enable
        pub struct CC4DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Capture/Compare 3 DMA request enable
        pub type CC3DE_A = CC4DE_A;
        ///Field `CC3DE` reader - Capture/Compare 3 DMA request enable
        pub type CC3DE_R = CC4DE_R;
        ///Field `CC3DE` writer - Capture/Compare 3 DMA request enable
        pub struct CC3DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC3DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC3DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Capture/Compare 2 DMA request enable
        pub type CC2DE_A = CC4DE_A;
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub type CC2DE_R = CC4DE_R;
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 1 DMA request enable
        pub type CC1DE_A = CC4DE_A;
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub type CC1DE_R = CC4DE_R;
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            ///CCx DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Update DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            ///0: Update DMA request disabled
            DISABLED = 0,
            ///1: Update DMA request enabled
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDE` reader - Update DMA request enable
        pub struct UDE_R(crate::FieldReader<bool, UDE_A>);
        impl UDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDE_A::ENABLED
            }
        }
        impl core::ops::Deref for UDE_R {
            type Target = crate::FieldReader<bool, UDE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            ///Update DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Trigger interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIE_A {
            ///0: Trigger interrupt disabled
            DISABLED = 0,
            ///1: Trigger interrupt enabled
            ENABLED = 1,
        }
        impl From<TIE_A> for bool {
            #[inline(always)]
            fn from(variant: TIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIE` reader - Trigger interrupt enable
        pub struct TIE_R(crate::FieldReader<bool, TIE_A>);
        impl TIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIE_A {
                match self.bits {
                    false => TIE_A::DISABLED,
                    true => TIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TIE_R {
            type Target = crate::FieldReader<bool, TIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIE` writer - Trigger interrupt enable
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Trigger interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TIE_A::DISABLED)
            }
            ///Trigger interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Capture/Compare 4 interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IE_A {
            ///0: CCx interrupt disabled
            DISABLED = 0,
            ///1: CCx interrupt enabled
            ENABLED = 1,
        }
        impl From<CC4IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4IE` reader - Capture/Compare 4 interrupt enable
        pub struct CC4IE_R(crate::FieldReader<bool, CC4IE_A>);
        impl CC4IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4IE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC4IE_A {
                match self.bits {
                    false => CC4IE_A::DISABLED,
                    true => CC4IE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC4IE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC4IE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC4IE_R {
            type Target = crate::FieldReader<bool, CC4IE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4IE` writer - Capture/Compare 4 interrupt enable
        pub struct CC4IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC4IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC4IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Capture/Compare 3 interrupt enable
        pub type CC3IE_A = CC4IE_A;
        ///Field `CC3IE` reader - Capture/Compare 3 interrupt enable
        pub type CC3IE_R = CC4IE_R;
        ///Field `CC3IE` writer - Capture/Compare 3 interrupt enable
        pub struct CC3IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC3IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC3IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/Compare 2 interrupt enable
        pub type CC2IE_A = CC4IE_A;
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub type CC2IE_R = CC4IE_R;
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC2IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC2IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 1 interrupt enable
        pub type CC1IE_A = CC4IE_A;
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub type CC1IE_R = CC4IE_R;
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            ///CCx interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&self) -> CC4DE_R {
                CC4DE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&self) -> CC3DE_R {
                CC3DE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&self) -> CC4IE_R {
                CC4IE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&self) -> CC3IE_R {
                CC3IE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            ///Bit 12 - Capture/Compare 4 DMA request enable
            #[inline(always)]
            pub fn cc4de(&mut self) -> CC4DE_W {
                CC4DE_W { w: self }
            }
            ///Bit 11 - Capture/Compare 3 DMA request enable
            #[inline(always)]
            pub fn cc3de(&mut self) -> CC3DE_W {
                CC3DE_W { w: self }
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            ///Bit 4 - Capture/Compare 4 interrupt enable
            #[inline(always)]
            pub fn cc4ie(&mut self) -> CC4IE_W {
                CC4IE_W { w: self }
            }
            ///Bit 3 - Capture/Compare 3 interrupt enable
            #[inline(always)]
            pub fn cc3ie(&mut self) -> CC3IE_W {
                CC3IE_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Capture/Compare 4 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_A {
            ///1: The counter value has been captured in TIMx_CCRx register while CCxIF flag was already set
            OVERCAPTURE = 1,
        }
        impl From<CC4OF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4OF` reader - Capture/Compare 4 overcapture flag
        pub struct CC4OF_R(crate::FieldReader<bool, CC4OF_A>);
        impl CC4OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4OF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4OF_A> {
                match self.bits {
                    true => Some(CC4OF_A::OVERCAPTURE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OVERCAPTURE`
            #[inline(always)]
            pub fn is_overcapture(&self) -> bool {
                **self == CC4OF_A::OVERCAPTURE
            }
        }
        impl core::ops::Deref for CC4OF_R {
            type Target = crate::FieldReader<bool, CC4OF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Capture/Compare 4 overcapture flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4OF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<CC4OF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4OF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4OF` writer - Capture/Compare 4 overcapture flag
        pub struct CC4OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Capture/Compare 3 overcapture flag
        pub type CC3OF_A = CC4OF_A;
        ///Field `CC3OF` reader - Capture/Compare 3 overcapture flag
        pub type CC3OF_R = CC4OF_R;
        ///Capture/Compare 3 overcapture flag
        pub type CC3OF_AW = CC4OF_AW;
        ///Field `CC3OF` writer - Capture/Compare 3 overcapture flag
        pub struct CC3OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC3OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Capture/compare 2 overcapture flag
        pub type CC2OF_A = CC4OF_A;
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub type CC2OF_R = CC4OF_R;
        ///Capture/compare 2 overcapture flag
        pub type CC2OF_AW = CC4OF_AW;
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 1 overcapture flag
        pub type CC1OF_A = CC4OF_A;
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub type CC1OF_R = CC4OF_R;
        ///Capture/Compare 1 overcapture flag
        pub type CC1OF_AW = CC4OF_AW;
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1OF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1OF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Trigger interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_A {
            ///0: No trigger event occurred
            NOTRIGGER = 0,
            ///1: Trigger interrupt pending
            TRIGGER = 1,
        }
        impl From<TIF_A> for bool {
            #[inline(always)]
            fn from(variant: TIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIF` reader - Trigger interrupt flag
        pub struct TIF_R(crate::FieldReader<bool, TIF_A>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIF_A {
                match self.bits {
                    false => TIF_A::NOTRIGGER,
                    true => TIF_A::TRIGGER,
                }
            }
            ///Checks if the value of the field is `NOTRIGGER`
            #[inline(always)]
            pub fn is_no_trigger(&self) -> bool {
                **self == TIF_A::NOTRIGGER
            }
            ///Checks if the value of the field is `TRIGGER`
            #[inline(always)]
            pub fn is_trigger(&self) -> bool {
                **self == TIF_A::TRIGGER
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, TIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Trigger interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<TIF_AW> for bool {
            #[inline(always)]
            fn from(variant: TIF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIF` writer - Trigger interrupt flag
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(TIF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Capture/Compare 4 interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_A {
            ///1: If CC1 is an output: The content of the counter TIMx_CNT matches the content of the TIMx_CCR1 register. If CC1 is an input: The counter value has been captured in TIMx_CCR1 register.
            MATCH = 1,
        }
        impl From<CC4IF_A> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4IF` reader - Capture/Compare 4 interrupt flag
        pub struct CC4IF_R(crate::FieldReader<bool, CC4IF_A>);
        impl CC4IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4IF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4IF_A> {
                match self.bits {
                    true => Some(CC4IF_A::MATCH),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `MATCH`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                **self == CC4IF_A::MATCH
            }
        }
        impl core::ops::Deref for CC4IF_R {
            type Target = crate::FieldReader<bool, CC4IF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Capture/Compare 4 interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4IF_AW {
            ///0: Clear flag
            CLEAR = 0,
        }
        impl From<CC4IF_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4IF_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4IF` writer - Capture/Compare 4 interrupt flag
        pub struct CC4IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC4IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Capture/Compare 3 interrupt flag
        pub type CC3IF_A = CC4IF_A;
        ///Field `CC3IF` reader - Capture/Compare 3 interrupt flag
        pub type CC3IF_R = CC4IF_R;
        ///Capture/Compare 3 interrupt flag
        pub type CC3IF_AW = CC4IF_AW;
        ///Field `CC3IF` writer - Capture/Compare 3 interrupt flag
        pub struct CC3IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC3IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/Compare 2 interrupt flag
        pub type CC2IF_A = CC4IF_A;
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub type CC2IF_R = CC4IF_R;
        ///Capture/Compare 2 interrupt flag
        pub type CC2IF_AW = CC4IF_AW;
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC2IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/compare 1 interrupt flag
        pub type CC1IF_A = CC4IF_A;
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub type CC1IF_R = CC4IF_R;
        ///Capture/compare 1 interrupt flag
        pub type CC1IF_AW = CC4IF_AW;
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1IF_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(CC1IF_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&self) -> CC4OF_R {
                CC4OF_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&self) -> CC3OF_R {
                CC3OF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&self) -> CC4IF_R {
                CC4IF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&self) -> CC3IF_R {
                CC3IF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 12 - Capture/Compare 4 overcapture flag
            #[inline(always)]
            pub fn cc4of(&mut self) -> CC4OF_W {
                CC4OF_W { w: self }
            }
            ///Bit 11 - Capture/Compare 3 overcapture flag
            #[inline(always)]
            pub fn cc3of(&mut self) -> CC3OF_W {
                CC3OF_W { w: self }
            }
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            ///Bit 4 - Capture/Compare 4 interrupt flag
            #[inline(always)]
            pub fn cc4if(&mut self) -> CC4IF_W {
                CC4IF_W { w: self }
            }
            ///Bit 3 - Capture/Compare 3 interrupt flag
            #[inline(always)]
            pub fn cc3if(&mut self) -> CC3IF_W {
                CC3IF_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Trigger generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TG_AW {
            ///1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            TRIGGER = 1,
        }
        impl From<TG_AW> for bool {
            #[inline(always)]
            fn from(variant: TG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TG` writer - Trigger generation
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The TIF flag is set in TIMx_SR register. Related interrupt or DMA transfer can occur if enabled.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(TG_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Capture/compare 4 generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC4G_AW {
            ///1: If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            TRIGGER = 1,
        }
        impl From<CC4G_AW> for bool {
            #[inline(always)]
            fn from(variant: CC4G_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC4G` writer - Capture/compare 4 generation
        pub struct CC4G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC4G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Capture/compare 3 generation
        pub type CC3G_AW = CC4G_AW;
        ///Field `CC3G` writer - Capture/compare 3 generation
        pub struct CC3G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC3G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/compare 2 generation
        pub type CC2G_AW = CC4G_AW;
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC2G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/compare 1 generation
        pub type CC1G_AW = CC4G_AW;
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1G_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///If CC1 is an output: CC1IF flag is set, Corresponding interrupt or DMA request is sent if enabled. If CC1 is an input: The current value of the counter is captured in TIMx_CCR1 register.
            #[inline(always)]
            pub fn trigger(self) -> &'a mut W {
                self.variant(CC1G_AW::TRIGGER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 6 - Trigger generation
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            ///Bit 4 - Capture/compare 4 generation
            #[inline(always)]
            pub fn cc4g(&mut self) -> CC4G_W {
                CC4G_W { w: self }
            }
            ///Bit 3 - Capture/compare 3 generation
            #[inline(always)]
            pub fn cc3g(&mut self) -> CC3G_W {
                CC3G_W { w: self }
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register 1 (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC2CE` reader - Output compare 2 clear enable
        pub struct OC2CE_R(crate::FieldReader<bool, bool>);
        impl OC2CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2CE` writer - Output compare 2 clear enable
        pub struct OC2CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Output compare 2 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC2M_A {
            ///0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            FROZEN = 0,
            ///1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            ACTIVEONMATCH = 1,
            ///2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            INACTIVEONMATCH = 2,
            ///3: OCyREF toggles when TIMx_CNT=TIMx_CCRy
            TOGGLE = 3,
            ///4: OCyREF is forced low
            FORCEINACTIVE = 4,
            ///5: OCyREF is forced high
            FORCEACTIVE = 5,
            ///6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            PWMMODE1 = 6,
            ///7: Inversely to PwmMode1
            PWMMODE2 = 7,
        }
        impl From<OC2M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC2M_A) -> Self {
                variant as _
            }
        }
        ///Field `OC2M` reader - Output compare 2 mode
        pub struct OC2M_R(crate::FieldReader<u8, OC2M_A>);
        impl OC2M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC2M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2M_A {
                match self.bits {
                    0 => OC2M_A::FROZEN,
                    1 => OC2M_A::ACTIVEONMATCH,
                    2 => OC2M_A::INACTIVEONMATCH,
                    3 => OC2M_A::TOGGLE,
                    4 => OC2M_A::FORCEINACTIVE,
                    5 => OC2M_A::FORCEACTIVE,
                    6 => OC2M_A::PWMMODE1,
                    7 => OC2M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `FROZEN`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                **self == OC2M_A::FROZEN
            }
            ///Checks if the value of the field is `ACTIVEONMATCH`
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                **self == OC2M_A::ACTIVEONMATCH
            }
            ///Checks if the value of the field is `INACTIVEONMATCH`
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                **self == OC2M_A::INACTIVEONMATCH
            }
            ///Checks if the value of the field is `TOGGLE`
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                **self == OC2M_A::TOGGLE
            }
            ///Checks if the value of the field is `FORCEINACTIVE`
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                **self == OC2M_A::FORCEINACTIVE
            }
            ///Checks if the value of the field is `FORCEACTIVE`
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                **self == OC2M_A::FORCEACTIVE
            }
            ///Checks if the value of the field is `PWMMODE1`
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                **self == OC2M_A::PWMMODE1
            }
            ///Checks if the value of the field is `PWMMODE2`
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                **self == OC2M_A::PWMMODE2
            }
        }
        impl core::ops::Deref for OC2M_R {
            type Target = crate::FieldReader<u8, OC2M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2M` writer - Output compare 2 mode
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC2M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC2M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC2M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC2M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC2M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC2M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Output compare 2 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC2PE_A {
            ///0: Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC2PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC2PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC2PE` reader - Output compare 2 preload enable
        pub struct OC2PE_R(crate::FieldReader<bool, OC2PE_A>);
        impl OC2PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC2PE_A {
                match self.bits {
                    false => OC2PE_A::DISABLED,
                    true => OC2PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC2PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC2PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC2PE_R {
            type Target = crate::FieldReader<bool, OC2PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2PE` writer - Output compare 2 preload enable
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC2PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR2 disabled. New values written to CCR2 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC2PE_A::DISABLED)
            }
            ///Preload register on CCR2 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC2PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC2FE` reader - Output compare 2 fast enable
        pub struct OC2FE_R(crate::FieldReader<bool, bool>);
        impl OC2FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2FE` writer - Output compare 2 fast enable
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///0: CC2 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, CC2S_A>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC2S_A> {
                match self.bits {
                    0 => Some(CC2S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC2S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, CC2S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC2 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC2S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC1CE` reader - Output compare 1 clear enable
        pub struct OC1CE_R(crate::FieldReader<bool, bool>);
        impl OC1CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1CE` writer - Output compare 1 clear enable
        pub struct OC1CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Output compare 1 mode
        pub type OC1M_A = OC2M_A;
        ///Field `OC1M` reader - Output compare 1 mode
        pub type OC1M_R = OC2M_R;
        ///Field `OC1M` writer - Output compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC1M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC1M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC1M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC1M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC1M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC1M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC1M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC1M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC1M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Output compare 1 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC1PE_A {
            ///0: Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC1PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC1PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC1PE` reader - Output compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, OC1PE_A>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC1PE_A {
                match self.bits {
                    false => OC1PE_A::DISABLED,
                    true => OC1PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC1PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC1PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, OC1PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC1PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR1 disabled. New values written to CCR1 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC1PE_A::DISABLED)
            }
            ///Preload register on CCR1 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC1PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///0: CC1 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, CC1S_A>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC1S_A> {
                match self.bits {
                    0 => Some(CC1S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC1S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, CC1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC1 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC1S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&self) -> OC2CE_R {
                OC2CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&self) -> OC1CE_R {
                OC1CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bit 15 - Output compare 2 clear enable
            #[inline(always)]
            pub fn oc2ce(&mut self) -> OC2CE_W {
                OC2CE_W { w: self }
            }
            ///Bits 12:14 - Output compare 2 mode
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            ///Bit 11 - Output compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            ///Bit 10 - Output compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bit 7 - Output compare 1 clear enable
            #[inline(always)]
            pub fn oc1ce(&mut self) -> OC1CE_W {
                OC1CE_W { w: self }
            }
            ///Bits 4:6 - Output compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Bit 3 - Output compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub struct IC2F_R(crate::FieldReader<u8, u8>);
        impl IC2F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2F` writer - Input capture 2 filter
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub struct IC2PSC_R(crate::FieldReader<u8, u8>);
        impl IC2PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Capture/compare 2 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC2S_A {
            ///1: CC2 channel is configured as input, IC2 is mapped on TI2
            TI2 = 1,
            ///2: CC2 channel is configured as input, IC2 is mapped on TI1
            TI1 = 2,
            ///3: CC2 channel is configured as input, IC2 is mapped on TRC
            TRC = 3,
        }
        impl From<CC2S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC2S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC2S` reader - Capture/compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, CC2S_A>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC2S_A> {
                match self.bits {
                    1 => Some(CC2S_A::TI2),
                    2 => Some(CC2S_A::TI1),
                    3 => Some(CC2S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI2`
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                **self == CC2S_A::TI2
            }
            ///Checks if the value of the field is `TI1`
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                **self == CC2S_A::TI1
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC2S_A::TRC
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, CC2S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC2S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC2 channel is configured as input, IC2 is mapped on TI2
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC2S_A::TI2)
            }
            ///CC2 channel is configured as input, IC2 is mapped on TI1
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC2S_A::TI1)
            }
            ///CC2 channel is configured as input, IC2 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC2S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Input capture 1 filter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum IC1F_A {
            ///0: No filter, sampling is done at fDTS
            NOFILTER = 0,
            ///1: fSAMPLING=fCK_INT, N=2
            FCK_INT_N2 = 1,
            ///2: fSAMPLING=fCK_INT, N=4
            FCK_INT_N4 = 2,
            ///3: fSAMPLING=fCK_INT, N=8
            FCK_INT_N8 = 3,
            ///4: fSAMPLING=fDTS/2, N=6
            FDTS_DIV2_N6 = 4,
            ///5: fSAMPLING=fDTS/2, N=8
            FDTS_DIV2_N8 = 5,
            ///6: fSAMPLING=fDTS/4, N=6
            FDTS_DIV4_N6 = 6,
            ///7: fSAMPLING=fDTS/4, N=8
            FDTS_DIV4_N8 = 7,
            ///8: fSAMPLING=fDTS/8, N=6
            FDTS_DIV8_N6 = 8,
            ///9: fSAMPLING=fDTS/8, N=8
            FDTS_DIV8_N8 = 9,
            ///10: fSAMPLING=fDTS/16, N=5
            FDTS_DIV16_N5 = 10,
            ///11: fSAMPLING=fDTS/16, N=6
            FDTS_DIV16_N6 = 11,
            ///12: fSAMPLING=fDTS/16, N=8
            FDTS_DIV16_N8 = 12,
            ///13: fSAMPLING=fDTS/32, N=5
            FDTS_DIV32_N5 = 13,
            ///14: fSAMPLING=fDTS/32, N=6
            FDTS_DIV32_N6 = 14,
            ///15: fSAMPLING=fDTS/32, N=8
            FDTS_DIV32_N8 = 15,
        }
        impl From<IC1F_A> for u8 {
            #[inline(always)]
            fn from(variant: IC1F_A) -> Self {
                variant as _
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, IC1F_A>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IC1F_A {
                match self.bits {
                    0 => IC1F_A::NOFILTER,
                    1 => IC1F_A::FCK_INT_N2,
                    2 => IC1F_A::FCK_INT_N4,
                    3 => IC1F_A::FCK_INT_N8,
                    4 => IC1F_A::FDTS_DIV2_N6,
                    5 => IC1F_A::FDTS_DIV2_N8,
                    6 => IC1F_A::FDTS_DIV4_N6,
                    7 => IC1F_A::FDTS_DIV4_N8,
                    8 => IC1F_A::FDTS_DIV8_N6,
                    9 => IC1F_A::FDTS_DIV8_N8,
                    10 => IC1F_A::FDTS_DIV16_N5,
                    11 => IC1F_A::FDTS_DIV16_N6,
                    12 => IC1F_A::FDTS_DIV16_N8,
                    13 => IC1F_A::FDTS_DIV32_N5,
                    14 => IC1F_A::FDTS_DIV32_N6,
                    15 => IC1F_A::FDTS_DIV32_N8,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `NOFILTER`
            #[inline(always)]
            pub fn is_no_filter(&self) -> bool {
                **self == IC1F_A::NOFILTER
            }
            ///Checks if the value of the field is `FCK_INT_N2`
            #[inline(always)]
            pub fn is_fck_int_n2(&self) -> bool {
                **self == IC1F_A::FCK_INT_N2
            }
            ///Checks if the value of the field is `FCK_INT_N4`
            #[inline(always)]
            pub fn is_fck_int_n4(&self) -> bool {
                **self == IC1F_A::FCK_INT_N4
            }
            ///Checks if the value of the field is `FCK_INT_N8`
            #[inline(always)]
            pub fn is_fck_int_n8(&self) -> bool {
                **self == IC1F_A::FCK_INT_N8
            }
            ///Checks if the value of the field is `FDTS_DIV2_N6`
            #[inline(always)]
            pub fn is_fdts_div2_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV2_N6
            }
            ///Checks if the value of the field is `FDTS_DIV2_N8`
            #[inline(always)]
            pub fn is_fdts_div2_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV2_N8
            }
            ///Checks if the value of the field is `FDTS_DIV4_N6`
            #[inline(always)]
            pub fn is_fdts_div4_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV4_N6
            }
            ///Checks if the value of the field is `FDTS_DIV4_N8`
            #[inline(always)]
            pub fn is_fdts_div4_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV4_N8
            }
            ///Checks if the value of the field is `FDTS_DIV8_N6`
            #[inline(always)]
            pub fn is_fdts_div8_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV8_N6
            }
            ///Checks if the value of the field is `FDTS_DIV8_N8`
            #[inline(always)]
            pub fn is_fdts_div8_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV8_N8
            }
            ///Checks if the value of the field is `FDTS_DIV16_N5`
            #[inline(always)]
            pub fn is_fdts_div16_n5(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N5
            }
            ///Checks if the value of the field is `FDTS_DIV16_N6`
            #[inline(always)]
            pub fn is_fdts_div16_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N6
            }
            ///Checks if the value of the field is `FDTS_DIV16_N8`
            #[inline(always)]
            pub fn is_fdts_div16_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV16_N8
            }
            ///Checks if the value of the field is `FDTS_DIV32_N5`
            #[inline(always)]
            pub fn is_fdts_div32_n5(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N5
            }
            ///Checks if the value of the field is `FDTS_DIV32_N6`
            #[inline(always)]
            pub fn is_fdts_div32_n6(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N6
            }
            ///Checks if the value of the field is `FDTS_DIV32_N8`
            #[inline(always)]
            pub fn is_fdts_div32_n8(&self) -> bool {
                **self == IC1F_A::FDTS_DIV32_N8
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, IC1F_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IC1F_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///No filter, sampling is done at fDTS
            #[inline(always)]
            pub fn no_filter(self) -> &'a mut W {
                self.variant(IC1F_A::NOFILTER)
            }
            ///fSAMPLING=fCK_INT, N=2
            #[inline(always)]
            pub fn fck_int_n2(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N2)
            }
            ///fSAMPLING=fCK_INT, N=4
            #[inline(always)]
            pub fn fck_int_n4(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N4)
            }
            ///fSAMPLING=fCK_INT, N=8
            #[inline(always)]
            pub fn fck_int_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FCK_INT_N8)
            }
            ///fSAMPLING=fDTS/2, N=6
            #[inline(always)]
            pub fn fdts_div2_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N6)
            }
            ///fSAMPLING=fDTS/2, N=8
            #[inline(always)]
            pub fn fdts_div2_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV2_N8)
            }
            ///fSAMPLING=fDTS/4, N=6
            #[inline(always)]
            pub fn fdts_div4_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N6)
            }
            ///fSAMPLING=fDTS/4, N=8
            #[inline(always)]
            pub fn fdts_div4_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV4_N8)
            }
            ///fSAMPLING=fDTS/8, N=6
            #[inline(always)]
            pub fn fdts_div8_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N6)
            }
            ///fSAMPLING=fDTS/8, N=8
            #[inline(always)]
            pub fn fdts_div8_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV8_N8)
            }
            ///fSAMPLING=fDTS/16, N=5
            #[inline(always)]
            pub fn fdts_div16_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N5)
            }
            ///fSAMPLING=fDTS/16, N=6
            #[inline(always)]
            pub fn fdts_div16_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N6)
            }
            ///fSAMPLING=fDTS/16, N=8
            #[inline(always)]
            pub fn fdts_div16_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV16_N8)
            }
            ///fSAMPLING=fDTS/32, N=5
            #[inline(always)]
            pub fn fdts_div32_n5(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N5)
            }
            ///fSAMPLING=fDTS/32, N=6
            #[inline(always)]
            pub fn fdts_div32_n6(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N6)
            }
            ///fSAMPLING=fDTS/32, N=8
            #[inline(always)]
            pub fn fdts_div32_n8(self) -> &'a mut W {
                self.variant(IC1F_A::FDTS_DIV32_N8)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Capture/Compare 1 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC1S_A {
            ///1: CC1 channel is configured as input, IC1 is mapped on TI1
            TI1 = 1,
            ///2: CC1 channel is configured as input, IC1 is mapped on TI2
            TI2 = 2,
            ///3: CC1 channel is configured as input, IC1 is mapped on TRC
            TRC = 3,
        }
        impl From<CC1S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC1S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, CC1S_A>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC1S_A> {
                match self.bits {
                    1 => Some(CC1S_A::TI1),
                    2 => Some(CC1S_A::TI2),
                    3 => Some(CC1S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI1`
            #[inline(always)]
            pub fn is_ti1(&self) -> bool {
                **self == CC1S_A::TI1
            }
            ///Checks if the value of the field is `TI2`
            #[inline(always)]
            pub fn is_ti2(&self) -> bool {
                **self == CC1S_A::TI2
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC1S_A::TRC
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, CC1S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC1 channel is configured as input, IC1 is mapped on TI1
            #[inline(always)]
            pub fn ti1(self) -> &'a mut W {
                self.variant(CC1S_A::TI1)
            }
            ///CC1 channel is configured as input, IC1 is mapped on TI2
            #[inline(always)]
            pub fn ti2(self) -> &'a mut W {
                self.variant(CC1S_A::TI2)
            }
            ///CC1 channel is configured as input, IC1 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC1S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR2_Output register accessor: an alias for `Reg<CCMR2_OUTPUT_SPEC>`
    pub type CCMR2_OUTPUT = crate::Reg<ccmr2_output::CCMR2_OUTPUT_SPEC>;
    ///capture/compare mode register 2 (output mode)
    pub mod ccmr2_output {
        ///Register `CCMR2_Output` reader
        pub struct R(crate::R<CCMR2_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR2_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR2_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR2_Output` writer
        pub struct W(crate::W<CCMR2_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR2_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR2_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR2_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC4CE` reader - Output compare 4 clear enable
        pub struct OC4CE_R(crate::FieldReader<bool, bool>);
        impl OC4CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC4CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4CE` writer - Output compare 4 clear enable
        pub struct OC4CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Output compare 4 mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum OC4M_A {
            ///0: The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            FROZEN = 0,
            ///1: Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            ACTIVEONMATCH = 1,
            ///2: Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            INACTIVEONMATCH = 2,
            ///3: OCyREF toggles when TIMx_CNT=TIMx_CCRy
            TOGGLE = 3,
            ///4: OCyREF is forced low
            FORCEINACTIVE = 4,
            ///5: OCyREF is forced high
            FORCEACTIVE = 5,
            ///6: In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            PWMMODE1 = 6,
            ///7: Inversely to PwmMode1
            PWMMODE2 = 7,
        }
        impl From<OC4M_A> for u8 {
            #[inline(always)]
            fn from(variant: OC4M_A) -> Self {
                variant as _
            }
        }
        ///Field `OC4M` reader - Output compare 4 mode
        pub struct OC4M_R(crate::FieldReader<u8, OC4M_A>);
        impl OC4M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC4M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4M_A {
                match self.bits {
                    0 => OC4M_A::FROZEN,
                    1 => OC4M_A::ACTIVEONMATCH,
                    2 => OC4M_A::INACTIVEONMATCH,
                    3 => OC4M_A::TOGGLE,
                    4 => OC4M_A::FORCEINACTIVE,
                    5 => OC4M_A::FORCEACTIVE,
                    6 => OC4M_A::PWMMODE1,
                    7 => OC4M_A::PWMMODE2,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `FROZEN`
            #[inline(always)]
            pub fn is_frozen(&self) -> bool {
                **self == OC4M_A::FROZEN
            }
            ///Checks if the value of the field is `ACTIVEONMATCH`
            #[inline(always)]
            pub fn is_active_on_match(&self) -> bool {
                **self == OC4M_A::ACTIVEONMATCH
            }
            ///Checks if the value of the field is `INACTIVEONMATCH`
            #[inline(always)]
            pub fn is_inactive_on_match(&self) -> bool {
                **self == OC4M_A::INACTIVEONMATCH
            }
            ///Checks if the value of the field is `TOGGLE`
            #[inline(always)]
            pub fn is_toggle(&self) -> bool {
                **self == OC4M_A::TOGGLE
            }
            ///Checks if the value of the field is `FORCEINACTIVE`
            #[inline(always)]
            pub fn is_force_inactive(&self) -> bool {
                **self == OC4M_A::FORCEINACTIVE
            }
            ///Checks if the value of the field is `FORCEACTIVE`
            #[inline(always)]
            pub fn is_force_active(&self) -> bool {
                **self == OC4M_A::FORCEACTIVE
            }
            ///Checks if the value of the field is `PWMMODE1`
            #[inline(always)]
            pub fn is_pwm_mode1(&self) -> bool {
                **self == OC4M_A::PWMMODE1
            }
            ///Checks if the value of the field is `PWMMODE2`
            #[inline(always)]
            pub fn is_pwm_mode2(&self) -> bool {
                **self == OC4M_A::PWMMODE2
            }
        }
        impl core::ops::Deref for OC4M_R {
            type Target = crate::FieldReader<u8, OC4M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4M` writer - Output compare 4 mode
        pub struct OC4M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC4M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC4M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC4M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC4M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC4M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC4M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Output compare 4 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC4PE_A {
            ///0: Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC4PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC4PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC4PE` reader - Output compare 4 preload enable
        pub struct OC4PE_R(crate::FieldReader<bool, OC4PE_A>);
        impl OC4PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC4PE_A {
                match self.bits {
                    false => OC4PE_A::DISABLED,
                    true => OC4PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC4PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC4PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC4PE_R {
            type Target = crate::FieldReader<bool, OC4PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4PE` writer - Output compare 4 preload enable
        pub struct OC4PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC4PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR4 disabled. New values written to CCR4 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC4PE_A::DISABLED)
            }
            ///Preload register on CCR4 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC4PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC4FE` reader - Output compare 4 fast enable
        pub struct OC4FE_R(crate::FieldReader<bool, bool>);
        impl OC4FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC4FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC4FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC4FE` writer - Output compare 4 fast enable
        pub struct OC4FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC4FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///0: CC4 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub struct CC4S_R(crate::FieldReader<u8, CC4S_A>);
        impl CC4S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC4S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4S_A> {
                match self.bits {
                    0 => Some(CC4S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC4S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC4S_R {
            type Target = crate::FieldReader<u8, CC4S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC4 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC4S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC3CE` reader - Output compare 3 clear enable
        pub struct OC3CE_R(crate::FieldReader<bool, bool>);
        impl OC3CE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3CE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC3CE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3CE` writer - Output compare 3 clear enable
        pub struct OC3CE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3CE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Output compare 3 mode
        pub type OC3M_A = OC4M_A;
        ///Field `OC3M` reader - Output compare 3 mode
        pub type OC3M_R = OC4M_R;
        ///Field `OC3M` writer - Output compare 3 mode
        pub struct OC3M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC3M_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///The comparison between the output compare register TIMx_CCRy and the counter TIMx_CNT has no effect on the outputs
            #[inline(always)]
            pub fn frozen(self) -> &'a mut W {
                self.variant(OC3M_A::FROZEN)
            }
            ///Set channel to active level on match. OCyREF signal is forced high when the counter matches the capture/compare register
            #[inline(always)]
            pub fn active_on_match(self) -> &'a mut W {
                self.variant(OC3M_A::ACTIVEONMATCH)
            }
            ///Set channel to inactive level on match. OCyREF signal is forced low when the counter matches the capture/compare register
            #[inline(always)]
            pub fn inactive_on_match(self) -> &'a mut W {
                self.variant(OC3M_A::INACTIVEONMATCH)
            }
            ///OCyREF toggles when TIMx_CNT=TIMx_CCRy
            #[inline(always)]
            pub fn toggle(self) -> &'a mut W {
                self.variant(OC3M_A::TOGGLE)
            }
            ///OCyREF is forced low
            #[inline(always)]
            pub fn force_inactive(self) -> &'a mut W {
                self.variant(OC3M_A::FORCEINACTIVE)
            }
            ///OCyREF is forced high
            #[inline(always)]
            pub fn force_active(self) -> &'a mut W {
                self.variant(OC3M_A::FORCEACTIVE)
            }
            ///In upcounting, channel is active as long as TIMx_CNT<TIMx_CCRy else inactive. In downcounting, channel is inactive as long as TIMx_CNT>TIMx_CCRy else active
            #[inline(always)]
            pub fn pwm_mode1(self) -> &'a mut W {
                self.variant(OC3M_A::PWMMODE1)
            }
            ///Inversely to PwmMode1
            #[inline(always)]
            pub fn pwm_mode2(self) -> &'a mut W {
                self.variant(OC3M_A::PWMMODE2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Output compare 3 preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OC3PE_A {
            ///0: Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
            DISABLED = 0,
            ///1: Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            ENABLED = 1,
        }
        impl From<OC3PE_A> for bool {
            #[inline(always)]
            fn from(variant: OC3PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OC3PE` reader - Output compare 3 preload enable
        pub struct OC3PE_R(crate::FieldReader<bool, OC3PE_A>);
        impl OC3PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OC3PE_A {
                match self.bits {
                    false => OC3PE_A::DISABLED,
                    true => OC3PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OC3PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OC3PE_A::ENABLED
            }
        }
        impl core::ops::Deref for OC3PE_R {
            type Target = crate::FieldReader<bool, OC3PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3PE` writer - Output compare 3 preload enable
        pub struct OC3PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OC3PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Preload register on CCR3 disabled. New values written to CCR3 are taken into account immediately
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OC3PE_A::DISABLED)
            }
            ///Preload register on CCR3 enabled. Preload value is loaded into active register on each update event
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OC3PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC3FE` reader - Output compare 3 fast enable
        pub struct OC3FE_R(crate::FieldReader<bool, bool>);
        impl OC3FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC3FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC3FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC3FE` writer - Output compare 3 fast enable
        pub struct OC3FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC3FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/Compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///0: CC3 channel is configured as output
            OUTPUT = 0,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub struct CC3S_R(crate::FieldReader<u8, CC3S_A>);
        impl CC3S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC3S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC3S_A> {
                match self.bits {
                    0 => Some(CC3S_A::OUTPUT),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `OUTPUT`
            #[inline(always)]
            pub fn is_output(&self) -> bool {
                **self == CC3S_A::OUTPUT
            }
        }
        impl core::ops::Deref for CC3S_R {
            type Target = crate::FieldReader<u8, CC3S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC3 channel is configured as output
            #[inline(always)]
            pub fn output(self) -> &'a mut W {
                self.variant(CC3S_A::OUTPUT)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&self) -> OC4CE_R {
                OC4CE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&self) -> OC4M_R {
                OC4M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&self) -> OC4PE_R {
                OC4PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&self) -> OC4FE_R {
                OC4FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&self) -> OC3CE_R {
                OC3CE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&self) -> OC3M_R {
                OC3M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&self) -> OC3PE_R {
                OC3PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&self) -> OC3FE_R {
                OC3FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bit 15 - Output compare 4 clear enable
            #[inline(always)]
            pub fn oc4ce(&mut self) -> OC4CE_W {
                OC4CE_W { w: self }
            }
            ///Bits 12:14 - Output compare 4 mode
            #[inline(always)]
            pub fn oc4m(&mut self) -> OC4M_W {
                OC4M_W { w: self }
            }
            ///Bit 11 - Output compare 4 preload enable
            #[inline(always)]
            pub fn oc4pe(&mut self) -> OC4PE_W {
                OC4PE_W { w: self }
            }
            ///Bit 10 - Output compare 4 fast enable
            #[inline(always)]
            pub fn oc4fe(&mut self) -> OC4FE_W {
                OC4FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            ///Bit 7 - Output compare 3 clear enable
            #[inline(always)]
            pub fn oc3ce(&mut self) -> OC3CE_W {
                OC3CE_W { w: self }
            }
            ///Bits 4:6 - Output compare 3 mode
            #[inline(always)]
            pub fn oc3m(&mut self) -> OC3M_W {
                OC3M_W { w: self }
            }
            ///Bit 3 - Output compare 3 preload enable
            #[inline(always)]
            pub fn oc3pe(&mut self) -> OC3PE_W {
                OC3PE_W { w: self }
            }
            ///Bit 2 - Output compare 3 fast enable
            #[inline(always)]
            pub fn oc3fe(&mut self) -> OC3FE_W {
                OC3FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr2_output](index.html) module
        pub struct CCMR2_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR2_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr2_output::R](R) reader structure
        impl crate::Readable for CCMR2_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr2_output::W](W) writer structure
        impl crate::Writable for CCMR2_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR2_Output to value 0
        impl crate::Resettable for CCMR2_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR2_Input register accessor: an alias for `Reg<CCMR2_INPUT_SPEC>`
    pub type CCMR2_INPUT = crate::Reg<ccmr2_input::CCMR2_INPUT_SPEC>;
    ///capture/compare mode register 2 (input mode)
    pub mod ccmr2_input {
        ///Register `CCMR2_Input` reader
        pub struct R(crate::R<CCMR2_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR2_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR2_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR2_Input` writer
        pub struct W(crate::W<CCMR2_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR2_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR2_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR2_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC4F` reader - Input capture 4 filter
        pub struct IC4F_R(crate::FieldReader<u8, u8>);
        impl IC4F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC4F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC4F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC4F` writer - Input capture 4 filter
        pub struct IC4F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        ///Field `IC4PSC` reader - Input capture 4 prescaler
        pub struct IC4PSC_R(crate::FieldReader<u8, u8>);
        impl IC4PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC4PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC4PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC4PSC` writer - Input capture 4 prescaler
        pub struct IC4PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC4PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Capture/Compare 4 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC4S_A {
            ///1: CC4 channel is configured as input, IC4 is mapped on TI4
            TI4 = 1,
            ///2: CC4 channel is configured as input, IC4 is mapped on TI3
            TI3 = 2,
            ///3: CC4 channel is configured as input, IC4 is mapped on TRC
            TRC = 3,
        }
        impl From<CC4S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC4S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC4S` reader - Capture/Compare 4 selection
        pub struct CC4S_R(crate::FieldReader<u8, CC4S_A>);
        impl CC4S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC4S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC4S_A> {
                match self.bits {
                    1 => Some(CC4S_A::TI4),
                    2 => Some(CC4S_A::TI3),
                    3 => Some(CC4S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI4`
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                **self == CC4S_A::TI4
            }
            ///Checks if the value of the field is `TI3`
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                **self == CC4S_A::TI3
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC4S_A::TRC
            }
        }
        impl core::ops::Deref for CC4S_R {
            type Target = crate::FieldReader<u8, CC4S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4S` writer - Capture/Compare 4 selection
        pub struct CC4S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC4S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC4 channel is configured as input, IC4 is mapped on TI4
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC4S_A::TI4)
            }
            ///CC4 channel is configured as input, IC4 is mapped on TI3
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC4S_A::TI3)
            }
            ///CC4 channel is configured as input, IC4 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC4S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `IC3F` reader - Input capture 3 filter
        pub struct IC3F_R(crate::FieldReader<u8, u8>);
        impl IC3F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC3F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC3F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC3F` writer - Input capture 3 filter
        pub struct IC3F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC3PSC` reader - Input capture 3 prescaler
        pub struct IC3PSC_R(crate::FieldReader<u8, u8>);
        impl IC3PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC3PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC3PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC3PSC` writer - Input capture 3 prescaler
        pub struct IC3PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC3PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Capture/Compare 3 selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CC3S_A {
            ///1: CC3 channel is configured as input, IC3 is mapped on TI3
            TI3 = 1,
            ///2: CC3 channel is configured as input, IC3 is mapped on TI4
            TI4 = 2,
            ///3: CC3 channel is configured as input, IC3 is mapped on TRC
            TRC = 3,
        }
        impl From<CC3S_A> for u8 {
            #[inline(always)]
            fn from(variant: CC3S_A) -> Self {
                variant as _
            }
        }
        ///Field `CC3S` reader - Capture/Compare 3 selection
        pub struct CC3S_R(crate::FieldReader<u8, CC3S_A>);
        impl CC3S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC3S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CC3S_A> {
                match self.bits {
                    1 => Some(CC3S_A::TI3),
                    2 => Some(CC3S_A::TI4),
                    3 => Some(CC3S_A::TRC),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TI3`
            #[inline(always)]
            pub fn is_ti3(&self) -> bool {
                **self == CC3S_A::TI3
            }
            ///Checks if the value of the field is `TI4`
            #[inline(always)]
            pub fn is_ti4(&self) -> bool {
                **self == CC3S_A::TI4
            }
            ///Checks if the value of the field is `TRC`
            #[inline(always)]
            pub fn is_trc(&self) -> bool {
                **self == CC3S_A::TRC
            }
        }
        impl core::ops::Deref for CC3S_R {
            type Target = crate::FieldReader<u8, CC3S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3S` writer - Capture/Compare 3 selection
        pub struct CC3S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC3S_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///CC3 channel is configured as input, IC3 is mapped on TI3
            #[inline(always)]
            pub fn ti3(self) -> &'a mut W {
                self.variant(CC3S_A::TI3)
            }
            ///CC3 channel is configured as input, IC3 is mapped on TI4
            #[inline(always)]
            pub fn ti4(self) -> &'a mut W {
                self.variant(CC3S_A::TI4)
            }
            ///CC3 channel is configured as input, IC3 is mapped on TRC
            #[inline(always)]
            pub fn trc(self) -> &'a mut W {
                self.variant(CC3S_A::TRC)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&self) -> IC4F_R {
                IC4F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&self) -> IC4PSC_R {
                IC4PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&self) -> CC4S_R {
                CC4S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&self) -> IC3F_R {
                IC3F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&self) -> IC3PSC_R {
                IC3PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&self) -> CC3S_R {
                CC3S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:15 - Input capture 4 filter
            #[inline(always)]
            pub fn ic4f(&mut self) -> IC4F_W {
                IC4F_W { w: self }
            }
            ///Bits 10:11 - Input capture 4 prescaler
            #[inline(always)]
            pub fn ic4psc(&mut self) -> IC4PSC_W {
                IC4PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 4 selection
            #[inline(always)]
            pub fn cc4s(&mut self) -> CC4S_W {
                CC4S_W { w: self }
            }
            ///Bits 4:7 - Input capture 3 filter
            #[inline(always)]
            pub fn ic3f(&mut self) -> IC3F_W {
                IC3F_W { w: self }
            }
            ///Bits 2:3 - Input capture 3 prescaler
            #[inline(always)]
            pub fn ic3psc(&mut self) -> IC3PSC_W {
                IC3PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 3 selection
            #[inline(always)]
            pub fn cc3s(&mut self) -> CC3S_W {
                CC3S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 2 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr2_input](index.html) module
        pub struct CCMR2_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR2_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr2_input::R](R) reader structure
        impl crate::Readable for CCMR2_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr2_input::W](W) writer structure
        impl crate::Writable for CCMR2_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR2_Input to value 0
        impl crate::Resettable for CCMR2_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC4P` reader - Capture/Compare 3 output Polarity
        pub struct CC4P_R(crate::FieldReader<bool, bool>);
        impl CC4P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC4P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4P` writer - Capture/Compare 3 output Polarity
        pub struct CC4P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `CC4E` reader - Capture/Compare 4 output enable
        pub struct CC4E_R(crate::FieldReader<bool, bool>);
        impl CC4E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC4E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC4E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC4E` writer - Capture/Compare 4 output enable
        pub struct CC4E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC4E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `CC3P` reader - Capture/Compare 3 output Polarity
        pub struct CC3P_R(crate::FieldReader<bool, bool>);
        impl CC3P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3P` writer - Capture/Compare 3 output Polarity
        pub struct CC3P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `CC3E` reader - Capture/Compare 3 output enable
        pub struct CC3E_R(crate::FieldReader<bool, bool>);
        impl CC3E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC3E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC3E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC3E` writer - Capture/Compare 3 output enable
        pub struct CC3E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC3E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub struct CC2P_R(crate::FieldReader<bool, bool>);
        impl CC2P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub struct CC2E_R(crate::FieldReader<bool, bool>);
        impl CC2E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&self) -> CC4P_R {
                CC4P_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&self) -> CC4E_R {
                CC4E_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&self) -> CC3P_R {
                CC3P_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&self) -> CC3E_R {
                CC3E_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 13 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc4p(&mut self) -> CC4P_W {
                CC4P_W { w: self }
            }
            ///Bit 12 - Capture/Compare 4 output enable
            #[inline(always)]
            pub fn cc4e(&mut self) -> CC4E_W {
                CC4E_W { w: self }
            }
            ///Bit 9 - Capture/Compare 3 output Polarity
            #[inline(always)]
            pub fn cc3p(&mut self) -> CC3P_W {
                CC3P_W { w: self }
            }
            ///Bit 8 - Capture/Compare 3 output enable
            #[inline(always)]
            pub fn cc3e(&mut self) -> CC3E_W {
                CC3E_W { w: self }
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR register accessor: an alias for `Reg<CCR_SPEC>`
    pub type CCR = crate::Reg<ccr::CCR_SPEC>;
    ///capture/compare register 1
    pub mod ccr {
        ///Register `CCR%s` reader
        pub struct R(crate::R<CCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR_SPEC>> for R {
            fn from(reader: crate::R<CCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR%s` writer
        pub struct W(crate::W<CCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR_SPEC>> for W {
            fn from(writer: crate::W<CCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Capture/Compare 1 value
        pub struct CCR_R(crate::FieldReader<u16, u16>);
        impl CCR_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR` writer - Capture/Compare 1 value
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr](index.html) module
        pub struct CCR_SPEC;
        impl crate::RegisterSpec for CCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr::R](R) reader structure
        impl crate::Readable for CCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr::W](W) writer structure
        impl crate::Writable for CCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR%s to value 0
        impl crate::Resettable for CCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DCR register accessor: an alias for `Reg<DCR_SPEC>`
    pub type DCR = crate::Reg<dcr::DCR_SPEC>;
    ///DMA control register
    pub mod dcr {
        ///Register `DCR` reader
        pub struct R(crate::R<DCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DCR_SPEC>> for R {
            fn from(reader: crate::R<DCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DCR` writer
        pub struct W(crate::W<DCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DCR_SPEC>> for W {
            fn from(writer: crate::W<DCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBL` reader - DMA burst length
        pub struct DBL_R(crate::FieldReader<u8, u8>);
        impl DBL_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBL` writer - DMA burst length
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | ((value as u32 & 0x1f) << 8);
                self.w
            }
        }
        ///Field `DBA` reader - DMA base address
        pub struct DBA_R(crate::FieldReader<u8, u8>);
        impl DBA_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBA_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBA` writer - DMA base address
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dcr](index.html) module
        pub struct DCR_SPEC;
        impl crate::RegisterSpec for DCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dcr::R](R) reader structure
        impl crate::Readable for DCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dcr::W](W) writer structure
        impl crate::Writable for DCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DCR to value 0
        impl crate::Resettable for DCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DMAR register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DMAR_SPEC>> for R {
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DMAR_SPEC>> for W {
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub struct DMAB_R(crate::FieldReader<u16, u16>);
        impl DMAB_R {
            pub(crate) fn new(bits: u16) -> Self {
                DMAB_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DMAB_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAB` writer - DMA register for burst accesses
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose timer
pub struct TIM3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM3 {}
impl TIM3 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM3 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM3").finish()
    }
}
///General purpose timer
pub struct TIM4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM4 {}
impl TIM4 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM4 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM4").finish()
    }
}
///General purpose timer
pub struct TIM5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM5 {}
impl TIM5 {
    ///Pointer to the register block
    pub const PTR: *const tim2::RegisterBlock = 0x4000_0c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim2::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM5 {
    type Target = tim2::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM5").finish()
    }
}
///General purpose timer
pub struct TIM12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM12 {}
impl TIM12 {
    ///Pointer to the register block
    pub const PTR: *const tim12::RegisterBlock = 0x4000_1800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim12::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM12 {
    type Target = tim12::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM12").finish()
    }
}
///General purpose timer
pub mod tim12 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - slave mode control register
        pub smcr: crate::Reg<smcr::SMCR_SPEC>,
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        _reserved11: [u8; 4usize],
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr::CCR_SPEC>,
        ///0x38 - capture/compare register 1
        pub ccr2: crate::Reg<ccr::CCR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register 1 (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            ///0: Counter is not stopped at update event
            DISABLED = 0,
            ///1: Counter stops counting at the next update event (clearing the CEN bit)
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, OPM_A>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OPM_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OPM_A::ENABLED
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, OPM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter is not stopped at update event
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            ///Counter stops counting at the next update event (clearing the CEN bit)
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub struct MMS_R(crate::FieldReader<u8, u8>);
        impl MMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                MMS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MMS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMCR register accessor: an alias for `Reg<SMCR_SPEC>`
    pub type SMCR = crate::Reg<smcr::SMCR_SPEC>;
    ///slave mode control register
    pub mod smcr {
        ///Register `SMCR` reader
        pub struct R(crate::R<SMCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMCR_SPEC>> for R {
            fn from(reader: crate::R<SMCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCR` writer
        pub struct W(crate::W<SMCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMCR_SPEC>> for W {
            fn from(writer: crate::W<SMCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub struct MSM_R(crate::FieldReader<bool, bool>);
        impl MSM_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MSM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TS` reader - Trigger selection
        pub struct TS_R(crate::FieldReader<u8, u8>);
        impl TS_R {
            pub(crate) fn new(bits: u8) -> Self {
                TS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TS` writer - Trigger selection
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub struct SMS_R(crate::FieldReader<u8, u8>);
        impl SMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SMS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcr](index.html) module
        pub struct SMCR_SPEC;
        impl crate::RegisterSpec for SMCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcr::R](R) reader structure
        impl crate::Readable for SMCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcr::W](W) writer structure
        impl crate::Writable for SMCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMCR to value 0
        impl crate::Resettable for SMCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TIE` reader - Trigger interrupt enable
        pub struct TIE_R(crate::FieldReader<bool, bool>);
        impl TIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIE` writer - Trigger interrupt enable
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub struct CC2IE_R(crate::FieldReader<bool, bool>);
        impl CC2IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub struct CC1IE_R(crate::FieldReader<bool, bool>);
        impl CC1IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub struct CC2OF_R(crate::FieldReader<bool, bool>);
        impl CC2OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub struct CC1OF_R(crate::FieldReader<bool, bool>);
        impl CC1OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `TIF` reader - Trigger interrupt flag
        pub struct TIF_R(crate::FieldReader<bool, bool>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIF` writer - Trigger interrupt flag
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub struct CC2IF_R(crate::FieldReader<bool, bool>);
        impl CC2IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub struct CC1IF_R(crate::FieldReader<bool, bool>);
        impl CC1IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TG` writer - Trigger generation
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 6 - Trigger generation
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register 1 (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC2M` reader - Output Compare 2 mode
        pub struct OC2M_R(crate::FieldReader<u8, u8>);
        impl OC2M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC2M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2M` writer - Output Compare 2 mode
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub struct OC2PE_R(crate::FieldReader<bool, bool>);
        impl OC2PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub struct OC2FE_R(crate::FieldReader<bool, bool>);
        impl OC2FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, u8>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub struct OC1M_R(crate::FieldReader<u8, u8>);
        impl OC1M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC1M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, bool>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub struct IC2F_R(crate::FieldReader<u8, u8>);
        impl IC2F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2F` writer - Input capture 2 filter
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub struct IC2PSC_R(crate::FieldReader<u8, u8>);
        impl IC2PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, u8>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, u8>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:14 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:14 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub struct CC2NP_R(crate::FieldReader<bool, bool>);
        impl CC2NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub struct CC2P_R(crate::FieldReader<bool, bool>);
        impl CC2P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub struct CC2E_R(crate::FieldReader<bool, bool>);
        impl CC2E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub struct CC1NP_R(crate::FieldReader<bool, bool>);
        impl CC1NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR register accessor: an alias for `Reg<CCR_SPEC>`
    pub type CCR = crate::Reg<ccr::CCR_SPEC>;
    ///capture/compare register 1
    pub mod ccr {
        ///Register `CCR%s` reader
        pub struct R(crate::R<CCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR_SPEC>> for R {
            fn from(reader: crate::R<CCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR%s` writer
        pub struct W(crate::W<CCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR_SPEC>> for W {
            fn from(writer: crate::W<CCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Capture/Compare 1 value
        pub struct CCR_R(crate::FieldReader<u16, u16>);
        impl CCR_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR` writer - Capture/Compare 1 value
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr](index.html) module
        pub struct CCR_SPEC;
        impl crate::RegisterSpec for CCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr::R](R) reader structure
        impl crate::Readable for CCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr::W](W) writer structure
        impl crate::Writable for CCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR%s to value 0
        impl crate::Resettable for CCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose timer
pub struct TIM13 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM13 {}
impl TIM13 {
    ///Pointer to the register block
    pub const PTR: *const tim13::RegisterBlock = 0x4000_1c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim13::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM13 {
    type Target = tim13::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM13 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM13").finish()
    }
}
///General purpose timer
pub mod tim13 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        _reserved1: [u8; 8usize],
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_4_ccmr1: [u8; 4usize],
        _reserved5: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        _reserved9: [u8; 4usize],
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr::CCR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub struct CC1IE_R(crate::FieldReader<bool, bool>);
        impl CC1IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub struct CC1OF_R(crate::FieldReader<bool, bool>);
        impl CC1OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub struct CC1IF_R(crate::FieldReader<bool, bool>);
        impl CC1IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, bool>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub struct OC1M_R(crate::FieldReader<u8, u8>);
        impl OC1M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC1M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Bit 2 - Output compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, u8>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub struct CC1NP_R(crate::FieldReader<bool, bool>);
        impl CC1NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR register accessor: an alias for `Reg<CCR_SPEC>`
    pub type CCR = crate::Reg<ccr::CCR_SPEC>;
    ///capture/compare register 1
    pub mod ccr {
        ///Register `CCR%s` reader
        pub struct R(crate::R<CCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR_SPEC>> for R {
            fn from(reader: crate::R<CCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR%s` writer
        pub struct W(crate::W<CCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR_SPEC>> for W {
            fn from(writer: crate::W<CCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR` reader - Capture/Compare 1 value
        pub struct CCR_R(crate::FieldReader<u16, u16>);
        impl CCR_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR` writer - Capture/Compare 1 value
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr](index.html) module
        pub struct CCR_SPEC;
        impl crate::RegisterSpec for CCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr::R](R) reader structure
        impl crate::Readable for CCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr::W](W) writer structure
        impl crate::Writable for CCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR%s to value 0
        impl crate::Resettable for CCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General purpose timer
pub struct TIM14 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM14 {}
impl TIM14 {
    ///Pointer to the register block
    pub const PTR: *const tim13::RegisterBlock = 0x4000_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim13::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM14 {
    type Target = tim13::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM14 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM14").finish()
    }
}
///Basic timer
pub struct TIM6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM6 {}
impl TIM6 {
    ///Pointer to the register block
    pub const PTR: *const tim6::RegisterBlock = 0x4000_1000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM6 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM6").finish()
    }
}
///Basic timer
pub mod tim6 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        _reserved2: [u8; 4usize],
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved5: [u8; 12usize],
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            ///0: Counter is not stopped at update event
            DISABLED = 0,
            ///1: Counter stops counting at the next update event (clearing the CEN bit)
            ENABLED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, OPM_A>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::DISABLED,
                    true => OPM_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == OPM_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == OPM_A::ENABLED
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, OPM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter is not stopped at update event
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(OPM_A::DISABLED)
            }
            ///Counter stops counting at the next update event (clearing the CEN bit)
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(OPM_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum MMS_A {
            ///0: Use UG bit from TIMx_EGR register
            RESET = 0,
            ///1: Use CNT bit from TIMx_CEN register
            ENABLE = 1,
            ///2: Use the update event
            UPDATE = 2,
        }
        impl From<MMS_A> for u8 {
            #[inline(always)]
            fn from(variant: MMS_A) -> Self {
                variant as _
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub struct MMS_R(crate::FieldReader<u8, MMS_A>);
        impl MMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                MMS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<MMS_A> {
                match self.bits {
                    0 => Some(MMS_A::RESET),
                    1 => Some(MMS_A::ENABLE),
                    2 => Some(MMS_A::UPDATE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == MMS_A::RESET
            }
            ///Checks if the value of the field is `ENABLE`
            #[inline(always)]
            pub fn is_enable(&self) -> bool {
                **self == MMS_A::ENABLE
            }
            ///Checks if the value of the field is `UPDATE`
            #[inline(always)]
            pub fn is_update(&self) -> bool {
                **self == MMS_A::UPDATE
            }
        }
        impl core::ops::Deref for MMS_R {
            type Target = crate::FieldReader<u8, MMS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MMS_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Use UG bit from TIMx_EGR register
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(MMS_A::RESET)
            }
            ///Use CNT bit from TIMx_CEN register
            #[inline(always)]
            pub fn enable(self) -> &'a mut W {
                self.variant(MMS_A::ENABLE)
            }
            ///Use the update event
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(MMS_A::UPDATE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDE_A {
            ///0: Update DMA request disabled
            DISABLED = 0,
            ///1: Update DMA request enabled
            ENABLED = 1,
        }
        impl From<UDE_A> for bool {
            #[inline(always)]
            fn from(variant: UDE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDE` reader - Update DMA request enable
        pub struct UDE_R(crate::FieldReader<bool, UDE_A>);
        impl UDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDE_A {
                match self.bits {
                    false => UDE_A::DISABLED,
                    true => UDE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDE_A::ENABLED
            }
        }
        impl core::ops::Deref for UDE_R {
            type Target = crate::FieldReader<bool, UDE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDE_A::DISABLED)
            }
            ///Update DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - Low counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - Low counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Low counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Low counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Low Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Low Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Low Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Low Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Basic timer
pub struct TIM7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM7 {}
impl TIM7 {
    ///Pointer to the register block
    pub const PTR: *const tim6::RegisterBlock = 0x4000_1400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim6::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM7 {
    type Target = tim6::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM7").finish()
    }
}
///Inter integrated circuit
pub struct I2C1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C1 {}
impl I2C1 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C1 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C1").finish()
    }
}
///Inter integrated circuit
pub mod i2c1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - Control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - Own address register 1
        pub oar1: crate::Reg<oar1::OAR1_SPEC>,
        ///0x0c - Own address register 2
        pub oar2: crate::Reg<oar2::OAR2_SPEC>,
        ///0x10 - Data register
        pub dr: crate::Reg<dr::DR_SPEC>,
        ///0x14 - Status register 1
        pub sr1: crate::Reg<sr1::SR1_SPEC>,
        ///0x18 - Status register 2
        pub sr2: crate::Reg<sr2::SR2_SPEC>,
        ///0x1c - Clock control register
        pub ccr: crate::Reg<ccr::CCR_SPEC>,
        ///0x20 - TRISE register
        pub trise: crate::Reg<trise::TRISE_SPEC>,
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///Control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Software reset
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWRST_A {
            ///0: I2C peripheral not under reset
            NOTRESET = 0,
            ///1: I2C peripheral under reset
            RESET = 1,
        }
        impl From<SWRST_A> for bool {
            #[inline(always)]
            fn from(variant: SWRST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SWRST` reader - Software reset
        pub struct SWRST_R(crate::FieldReader<bool, SWRST_A>);
        impl SWRST_R {
            pub(crate) fn new(bits: bool) -> Self {
                SWRST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SWRST_A {
                match self.bits {
                    false => SWRST_A::NOTRESET,
                    true => SWRST_A::RESET,
                }
            }
            ///Checks if the value of the field is `NOTRESET`
            #[inline(always)]
            pub fn is_not_reset(&self) -> bool {
                **self == SWRST_A::NOTRESET
            }
            ///Checks if the value of the field is `RESET`
            #[inline(always)]
            pub fn is_reset(&self) -> bool {
                **self == SWRST_A::RESET
            }
        }
        impl core::ops::Deref for SWRST_R {
            type Target = crate::FieldReader<bool, SWRST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SWRST` writer - Software reset
        pub struct SWRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///I2C peripheral not under reset
            #[inline(always)]
            pub fn not_reset(self) -> &'a mut W {
                self.variant(SWRST_A::NOTRESET)
            }
            ///I2C peripheral under reset
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(SWRST_A::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///SMBus alert
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALERT_A {
            ///0: SMBA pin released high
            RELEASE = 0,
            ///1: SMBA pin driven low
            DRIVE = 1,
        }
        impl From<ALERT_A> for bool {
            #[inline(always)]
            fn from(variant: ALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ALERT` reader - SMBus alert
        pub struct ALERT_R(crate::FieldReader<bool, ALERT_A>);
        impl ALERT_R {
            pub(crate) fn new(bits: bool) -> Self {
                ALERT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ALERT_A {
                match self.bits {
                    false => ALERT_A::RELEASE,
                    true => ALERT_A::DRIVE,
                }
            }
            ///Checks if the value of the field is `RELEASE`
            #[inline(always)]
            pub fn is_release(&self) -> bool {
                **self == ALERT_A::RELEASE
            }
            ///Checks if the value of the field is `DRIVE`
            #[inline(always)]
            pub fn is_drive(&self) -> bool {
                **self == ALERT_A::DRIVE
            }
        }
        impl core::ops::Deref for ALERT_R {
            type Target = crate::FieldReader<bool, ALERT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ALERT` writer - SMBus alert
        pub struct ALERT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALERT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ALERT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///SMBA pin released high
            #[inline(always)]
            pub fn release(self) -> &'a mut W {
                self.variant(ALERT_A::RELEASE)
            }
            ///SMBA pin driven low
            #[inline(always)]
            pub fn drive(self) -> &'a mut W {
                self.variant(ALERT_A::DRIVE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Packet error checking
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEC_A {
            ///0: No PEC transfer
            DISABLED = 0,
            ///1: PEC transfer
            ENABLED = 1,
        }
        impl From<PEC_A> for bool {
            #[inline(always)]
            fn from(variant: PEC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PEC` reader - Packet error checking
        pub struct PEC_R(crate::FieldReader<bool, PEC_A>);
        impl PEC_R {
            pub(crate) fn new(bits: bool) -> Self {
                PEC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PEC_A {
                match self.bits {
                    false => PEC_A::DISABLED,
                    true => PEC_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PEC_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PEC_A::ENABLED
            }
        }
        impl core::ops::Deref for PEC_R {
            type Target = crate::FieldReader<bool, PEC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PEC` writer - Packet error checking
        pub struct PEC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PEC_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No PEC transfer
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEC_A::DISABLED)
            }
            ///PEC transfer
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEC_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Acknowledge/PEC Position (for data reception)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum POS_A {
            ///0: ACK bit controls the (N)ACK of the current byte being received
            CURRENT = 0,
            ///1: ACK bit controls the (N)ACK of the next byte to be received
            NEXT = 1,
        }
        impl From<POS_A> for bool {
            #[inline(always)]
            fn from(variant: POS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `POS` reader - Acknowledge/PEC Position (for data reception)
        pub struct POS_R(crate::FieldReader<bool, POS_A>);
        impl POS_R {
            pub(crate) fn new(bits: bool) -> Self {
                POS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> POS_A {
                match self.bits {
                    false => POS_A::CURRENT,
                    true => POS_A::NEXT,
                }
            }
            ///Checks if the value of the field is `CURRENT`
            #[inline(always)]
            pub fn is_current(&self) -> bool {
                **self == POS_A::CURRENT
            }
            ///Checks if the value of the field is `NEXT`
            #[inline(always)]
            pub fn is_next(&self) -> bool {
                **self == POS_A::NEXT
            }
        }
        impl core::ops::Deref for POS_R {
            type Target = crate::FieldReader<bool, POS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `POS` writer - Acknowledge/PEC Position (for data reception)
        pub struct POS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> POS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: POS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///ACK bit controls the (N)ACK of the current byte being received
            #[inline(always)]
            pub fn current(self) -> &'a mut W {
                self.variant(POS_A::CURRENT)
            }
            ///ACK bit controls the (N)ACK of the next byte to be received
            #[inline(always)]
            pub fn next(self) -> &'a mut W {
                self.variant(POS_A::NEXT)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Acknowledge enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ACK_A {
            ///0: No acknowledge returned
            NAK = 0,
            ///1: Acknowledge returned after a byte is received
            ACK = 1,
        }
        impl From<ACK_A> for bool {
            #[inline(always)]
            fn from(variant: ACK_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ACK` reader - Acknowledge enable
        pub struct ACK_R(crate::FieldReader<bool, ACK_A>);
        impl ACK_R {
            pub(crate) fn new(bits: bool) -> Self {
                ACK_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ACK_A {
                match self.bits {
                    false => ACK_A::NAK,
                    true => ACK_A::ACK,
                }
            }
            ///Checks if the value of the field is `NAK`
            #[inline(always)]
            pub fn is_nak(&self) -> bool {
                **self == ACK_A::NAK
            }
            ///Checks if the value of the field is `ACK`
            #[inline(always)]
            pub fn is_ack(&self) -> bool {
                **self == ACK_A::ACK
            }
        }
        impl core::ops::Deref for ACK_R {
            type Target = crate::FieldReader<bool, ACK_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ACK` writer - Acknowledge enable
        pub struct ACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ACK_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ACK_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No acknowledge returned
            #[inline(always)]
            pub fn nak(self) -> &'a mut W {
                self.variant(ACK_A::NAK)
            }
            ///Acknowledge returned after a byte is received
            #[inline(always)]
            pub fn ack(self) -> &'a mut W {
                self.variant(ACK_A::ACK)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Stop generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOP_A {
            ///0: No Stop generation
            NOSTOP = 0,
            ///1: In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            STOP = 1,
        }
        impl From<STOP_A> for bool {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `STOP` reader - Stop generation
        pub struct STOP_R(crate::FieldReader<bool, STOP_A>);
        impl STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                STOP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    false => STOP_A::NOSTOP,
                    true => STOP_A::STOP,
                }
            }
            ///Checks if the value of the field is `NOSTOP`
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                **self == STOP_A::NOSTOP
            }
            ///Checks if the value of the field is `STOP`
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                **self == STOP_A::STOP
            }
        }
        impl core::ops::Deref for STOP_R {
            type Target = crate::FieldReader<bool, STOP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `STOP` writer - Stop generation
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No Stop generation
            #[inline(always)]
            pub fn no_stop(self) -> &'a mut W {
                self.variant(STOP_A::NOSTOP)
            }
            ///In master mode: stop generation after current byte/start, in slave mode: release SCL and SDA after current byte
            #[inline(always)]
            pub fn stop(self) -> &'a mut W {
                self.variant(STOP_A::STOP)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Start generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum START_A {
            ///0: No Start generation
            NOSTART = 0,
            ///1: In master mode: repeated start generation, in slave mode: start generation when bus is free
            START = 1,
        }
        impl From<START_A> for bool {
            #[inline(always)]
            fn from(variant: START_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `START` reader - Start generation
        pub struct START_R(crate::FieldReader<bool, START_A>);
        impl START_R {
            pub(crate) fn new(bits: bool) -> Self {
                START_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> START_A {
                match self.bits {
                    false => START_A::NOSTART,
                    true => START_A::START,
                }
            }
            ///Checks if the value of the field is `NOSTART`
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                **self == START_A::NOSTART
            }
            ///Checks if the value of the field is `START`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                **self == START_A::START
            }
        }
        impl core::ops::Deref for START_R {
            type Target = crate::FieldReader<bool, START_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `START` writer - Start generation
        pub struct START_W<'a> {
            w: &'a mut W,
        }
        impl<'a> START_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: START_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No Start generation
            #[inline(always)]
            pub fn no_start(self) -> &'a mut W {
                self.variant(START_A::NOSTART)
            }
            ///In master mode: repeated start generation, in slave mode: start generation when bus is free
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(START_A::START)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Clock stretching disable (Slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NOSTRETCH_A {
            ///0: Clock stretching enabled
            ENABLED = 0,
            ///1: Clock stretching disabled
            DISABLED = 1,
        }
        impl From<NOSTRETCH_A> for bool {
            #[inline(always)]
            fn from(variant: NOSTRETCH_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `NOSTRETCH` reader - Clock stretching disable (Slave mode)
        pub struct NOSTRETCH_R(crate::FieldReader<bool, NOSTRETCH_A>);
        impl NOSTRETCH_R {
            pub(crate) fn new(bits: bool) -> Self {
                NOSTRETCH_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> NOSTRETCH_A {
                match self.bits {
                    false => NOSTRETCH_A::ENABLED,
                    true => NOSTRETCH_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == NOSTRETCH_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == NOSTRETCH_A::DISABLED
            }
        }
        impl core::ops::Deref for NOSTRETCH_R {
            type Target = crate::FieldReader<bool, NOSTRETCH_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `NOSTRETCH` writer - Clock stretching disable (Slave mode)
        pub struct NOSTRETCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NOSTRETCH_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: NOSTRETCH_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clock stretching enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::ENABLED)
            }
            ///Clock stretching disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NOSTRETCH_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///General call enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENGC_A {
            ///0: General call disabled
            DISABLED = 0,
            ///1: General call enabled
            ENABLED = 1,
        }
        impl From<ENGC_A> for bool {
            #[inline(always)]
            fn from(variant: ENGC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ENGC` reader - General call enable
        pub struct ENGC_R(crate::FieldReader<bool, ENGC_A>);
        impl ENGC_R {
            pub(crate) fn new(bits: bool) -> Self {
                ENGC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENGC_A {
                match self.bits {
                    false => ENGC_A::DISABLED,
                    true => ENGC_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ENGC_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ENGC_A::ENABLED
            }
        }
        impl core::ops::Deref for ENGC_R {
            type Target = crate::FieldReader<bool, ENGC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ENGC` writer - General call enable
        pub struct ENGC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENGC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ENGC_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///General call disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENGC_A::DISABLED)
            }
            ///General call enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENGC_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///PEC enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENPEC_A {
            ///0: PEC calculation disabled
            DISABLED = 0,
            ///1: PEC calculation enabled
            ENABLED = 1,
        }
        impl From<ENPEC_A> for bool {
            #[inline(always)]
            fn from(variant: ENPEC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ENPEC` reader - PEC enable
        pub struct ENPEC_R(crate::FieldReader<bool, ENPEC_A>);
        impl ENPEC_R {
            pub(crate) fn new(bits: bool) -> Self {
                ENPEC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENPEC_A {
                match self.bits {
                    false => ENPEC_A::DISABLED,
                    true => ENPEC_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ENPEC_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ENPEC_A::ENABLED
            }
        }
        impl core::ops::Deref for ENPEC_R {
            type Target = crate::FieldReader<bool, ENPEC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ENPEC` writer - PEC enable
        pub struct ENPEC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENPEC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ENPEC_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///PEC calculation disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENPEC_A::DISABLED)
            }
            ///PEC calculation enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENPEC_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///ARP enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENARP_A {
            ///0: ARP disabled
            DISABLED = 0,
            ///1: ARP enabled
            ENABLED = 1,
        }
        impl From<ENARP_A> for bool {
            #[inline(always)]
            fn from(variant: ENARP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ENARP` reader - ARP enable
        pub struct ENARP_R(crate::FieldReader<bool, ENARP_A>);
        impl ENARP_R {
            pub(crate) fn new(bits: bool) -> Self {
                ENARP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENARP_A {
                match self.bits {
                    false => ENARP_A::DISABLED,
                    true => ENARP_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ENARP_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ENARP_A::ENABLED
            }
        }
        impl core::ops::Deref for ENARP_R {
            type Target = crate::FieldReader<bool, ENARP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ENARP` writer - ARP enable
        pub struct ENARP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENARP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ENARP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///ARP disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ENARP_A::DISABLED)
            }
            ///ARP enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ENARP_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///SMBus type
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBTYPE_A {
            ///0: SMBus Device
            DEVICE = 0,
            ///1: SMBus Host
            HOST = 1,
        }
        impl From<SMBTYPE_A> for bool {
            #[inline(always)]
            fn from(variant: SMBTYPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SMBTYPE` reader - SMBus type
        pub struct SMBTYPE_R(crate::FieldReader<bool, SMBTYPE_A>);
        impl SMBTYPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                SMBTYPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBTYPE_A {
                match self.bits {
                    false => SMBTYPE_A::DEVICE,
                    true => SMBTYPE_A::HOST,
                }
            }
            ///Checks if the value of the field is `DEVICE`
            #[inline(always)]
            pub fn is_device(&self) -> bool {
                **self == SMBTYPE_A::DEVICE
            }
            ///Checks if the value of the field is `HOST`
            #[inline(always)]
            pub fn is_host(&self) -> bool {
                **self == SMBTYPE_A::HOST
            }
        }
        impl core::ops::Deref for SMBTYPE_R {
            type Target = crate::FieldReader<bool, SMBTYPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMBTYPE` writer - SMBus type
        pub struct SMBTYPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBTYPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMBTYPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///SMBus Device
            #[inline(always)]
            pub fn device(self) -> &'a mut W {
                self.variant(SMBTYPE_A::DEVICE)
            }
            ///SMBus Host
            #[inline(always)]
            pub fn host(self) -> &'a mut W {
                self.variant(SMBTYPE_A::HOST)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///SMBus mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBUS_A {
            ///0: I2C Mode
            I2C = 0,
            ///1: SMBus
            SMBUS = 1,
        }
        impl From<SMBUS_A> for bool {
            #[inline(always)]
            fn from(variant: SMBUS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SMBUS` reader - SMBus mode
        pub struct SMBUS_R(crate::FieldReader<bool, SMBUS_A>);
        impl SMBUS_R {
            pub(crate) fn new(bits: bool) -> Self {
                SMBUS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBUS_A {
                match self.bits {
                    false => SMBUS_A::I2C,
                    true => SMBUS_A::SMBUS,
                }
            }
            ///Checks if the value of the field is `I2C`
            #[inline(always)]
            pub fn is_i2c(&self) -> bool {
                **self == SMBUS_A::I2C
            }
            ///Checks if the value of the field is `SMBUS`
            #[inline(always)]
            pub fn is_smbus(&self) -> bool {
                **self == SMBUS_A::SMBUS
            }
        }
        impl core::ops::Deref for SMBUS_R {
            type Target = crate::FieldReader<bool, SMBUS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMBUS` writer - SMBus mode
        pub struct SMBUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBUS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMBUS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///I2C Mode
            #[inline(always)]
            pub fn i2c(self) -> &'a mut W {
                self.variant(SMBUS_A::I2C)
            }
            ///SMBus
            #[inline(always)]
            pub fn smbus(self) -> &'a mut W {
                self.variant(SMBUS_A::SMBUS)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Peripheral enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PE_A {
            ///0: Peripheral disabled
            DISABLED = 0,
            ///1: Peripheral enabled
            ENABLED = 1,
        }
        impl From<PE_A> for bool {
            #[inline(always)]
            fn from(variant: PE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PE` reader - Peripheral enable
        pub struct PE_R(crate::FieldReader<bool, PE_A>);
        impl PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PE_A {
                match self.bits {
                    false => PE_A::DISABLED,
                    true => PE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PE_A::ENABLED
            }
        }
        impl core::ops::Deref for PE_R {
            type Target = crate::FieldReader<bool, PE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PE` writer - Peripheral enable
        pub struct PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Peripheral disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PE_A::DISABLED)
            }
            ///Peripheral enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Software reset
            #[inline(always)]
            pub fn swrst(&self) -> SWRST_R {
                SWRST_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            pub fn alert(&self) -> ALERT_R {
                ALERT_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&self) -> POS_R {
                POS_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            pub fn ack(&self) -> ACK_R {
                ACK_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            pub fn start(&self) -> START_R {
                START_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&self) -> NOSTRETCH_R {
                NOSTRETCH_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            pub fn engc(&self) -> ENGC_R {
                ENGC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            pub fn enpec(&self) -> ENPEC_R {
                ENPEC_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            pub fn enarp(&self) -> ENARP_R {
                ENARP_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            pub fn smbtype(&self) -> SMBTYPE_R {
                SMBTYPE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            pub fn smbus(&self) -> SMBUS_R {
                SMBUS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 15 - Software reset
            #[inline(always)]
            pub fn swrst(&mut self) -> SWRST_W {
                SWRST_W { w: self }
            }
            ///Bit 13 - SMBus alert
            #[inline(always)]
            pub fn alert(&mut self) -> ALERT_W {
                ALERT_W { w: self }
            }
            ///Bit 12 - Packet error checking
            #[inline(always)]
            pub fn pec(&mut self) -> PEC_W {
                PEC_W { w: self }
            }
            ///Bit 11 - Acknowledge/PEC Position (for data reception)
            #[inline(always)]
            pub fn pos(&mut self) -> POS_W {
                POS_W { w: self }
            }
            ///Bit 10 - Acknowledge enable
            #[inline(always)]
            pub fn ack(&mut self) -> ACK_W {
                ACK_W { w: self }
            }
            ///Bit 9 - Stop generation
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            ///Bit 8 - Start generation
            #[inline(always)]
            pub fn start(&mut self) -> START_W {
                START_W { w: self }
            }
            ///Bit 7 - Clock stretching disable (Slave mode)
            #[inline(always)]
            pub fn nostretch(&mut self) -> NOSTRETCH_W {
                NOSTRETCH_W { w: self }
            }
            ///Bit 6 - General call enable
            #[inline(always)]
            pub fn engc(&mut self) -> ENGC_W {
                ENGC_W { w: self }
            }
            ///Bit 5 - PEC enable
            #[inline(always)]
            pub fn enpec(&mut self) -> ENPEC_W {
                ENPEC_W { w: self }
            }
            ///Bit 4 - ARP enable
            #[inline(always)]
            pub fn enarp(&mut self) -> ENARP_W {
                ENARP_W { w: self }
            }
            ///Bit 3 - SMBus type
            #[inline(always)]
            pub fn smbtype(&mut self) -> SMBTYPE_W {
                SMBTYPE_W { w: self }
            }
            ///Bit 1 - SMBus mode
            #[inline(always)]
            pub fn smbus(&mut self) -> SMBUS_W {
                SMBUS_W { w: self }
            }
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W {
                PE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///Control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///DMA last transfer
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LAST_A {
            ///0: Next DMA EOT is not the last transfer
            NOTLAST = 0,
            ///1: Next DMA EOT is the last transfer
            LAST = 1,
        }
        impl From<LAST_A> for bool {
            #[inline(always)]
            fn from(variant: LAST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LAST` reader - DMA last transfer
        pub struct LAST_R(crate::FieldReader<bool, LAST_A>);
        impl LAST_R {
            pub(crate) fn new(bits: bool) -> Self {
                LAST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LAST_A {
                match self.bits {
                    false => LAST_A::NOTLAST,
                    true => LAST_A::LAST,
                }
            }
            ///Checks if the value of the field is `NOTLAST`
            #[inline(always)]
            pub fn is_not_last(&self) -> bool {
                **self == LAST_A::NOTLAST
            }
            ///Checks if the value of the field is `LAST`
            #[inline(always)]
            pub fn is_last(&self) -> bool {
                **self == LAST_A::LAST
            }
        }
        impl core::ops::Deref for LAST_R {
            type Target = crate::FieldReader<bool, LAST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LAST` writer - DMA last transfer
        pub struct LAST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LAST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LAST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Next DMA EOT is not the last transfer
            #[inline(always)]
            pub fn not_last(self) -> &'a mut W {
                self.variant(LAST_A::NOTLAST)
            }
            ///Next DMA EOT is the last transfer
            #[inline(always)]
            pub fn last(self) -> &'a mut W {
                self.variant(LAST_A::LAST)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///DMA requests enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN_A {
            ///0: DMA requests disabled
            DISABLED = 0,
            ///1: DMA request enabled when TxE=1 or RxNE=1
            ENABLED = 1,
        }
        impl From<DMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAEN` reader - DMA requests enable
        pub struct DMAEN_R(crate::FieldReader<bool, DMAEN_A>);
        impl DMAEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAEN_A {
                match self.bits {
                    false => DMAEN_A::DISABLED,
                    true => DMAEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAEN_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAEN_R {
            type Target = crate::FieldReader<bool, DMAEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAEN` writer - DMA requests enable
        pub struct DMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA requests disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN_A::DISABLED)
            }
            ///DMA request enabled when TxE=1 or RxNE=1
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Buffer interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITBUFEN_A {
            ///0: TxE=1 or RxNE=1 does not generate any interrupt
            DISABLED = 0,
            ///1: TxE=1 or RxNE=1 generates Event interrupt
            ENABLED = 1,
        }
        impl From<ITBUFEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITBUFEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ITBUFEN` reader - Buffer interrupt enable
        pub struct ITBUFEN_R(crate::FieldReader<bool, ITBUFEN_A>);
        impl ITBUFEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                ITBUFEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITBUFEN_A {
                match self.bits {
                    false => ITBUFEN_A::DISABLED,
                    true => ITBUFEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ITBUFEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ITBUFEN_A::ENABLED
            }
        }
        impl core::ops::Deref for ITBUFEN_R {
            type Target = crate::FieldReader<bool, ITBUFEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ITBUFEN` writer - Buffer interrupt enable
        pub struct ITBUFEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITBUFEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ITBUFEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TxE=1 or RxNE=1 does not generate any interrupt
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::DISABLED)
            }
            ///TxE=1 or RxNE=1 generates Event interrupt
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITBUFEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Event interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITEVTEN_A {
            ///0: Event interrupt disabled
            DISABLED = 0,
            ///1: Event interrupt enabled
            ENABLED = 1,
        }
        impl From<ITEVTEN_A> for bool {
            #[inline(always)]
            fn from(variant: ITEVTEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ITEVTEN` reader - Event interrupt enable
        pub struct ITEVTEN_R(crate::FieldReader<bool, ITEVTEN_A>);
        impl ITEVTEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                ITEVTEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITEVTEN_A {
                match self.bits {
                    false => ITEVTEN_A::DISABLED,
                    true => ITEVTEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ITEVTEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ITEVTEN_A::ENABLED
            }
        }
        impl core::ops::Deref for ITEVTEN_R {
            type Target = crate::FieldReader<bool, ITEVTEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ITEVTEN` writer - Event interrupt enable
        pub struct ITEVTEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITEVTEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ITEVTEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Event interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::DISABLED)
            }
            ///Event interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITEVTEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ITERREN_A {
            ///0: Error interrupt disabled
            DISABLED = 0,
            ///1: Error interrupt enabled
            ENABLED = 1,
        }
        impl From<ITERREN_A> for bool {
            #[inline(always)]
            fn from(variant: ITERREN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ITERREN` reader - Error interrupt enable
        pub struct ITERREN_R(crate::FieldReader<bool, ITERREN_A>);
        impl ITERREN_R {
            pub(crate) fn new(bits: bool) -> Self {
                ITERREN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ITERREN_A {
                match self.bits {
                    false => ITERREN_A::DISABLED,
                    true => ITERREN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ITERREN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ITERREN_A::ENABLED
            }
        }
        impl core::ops::Deref for ITERREN_R {
            type Target = crate::FieldReader<bool, ITERREN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ITERREN` writer - Error interrupt enable
        pub struct ITERREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ITERREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ITERREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Error interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ITERREN_A::DISABLED)
            }
            ///Error interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ITERREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `FREQ` reader - Peripheral clock frequency
        pub struct FREQ_R(crate::FieldReader<u8, u8>);
        impl FREQ_R {
            pub(crate) fn new(bits: u8) -> Self {
                FREQ_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for FREQ_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FREQ` writer - Peripheral clock frequency
        pub struct FREQ_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FREQ_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | (value as u32 & 0x3f);
                self.w
            }
        }
        impl R {
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            pub fn last(&self) -> LAST_R {
                LAST_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            pub fn dmaen(&self) -> DMAEN_R {
                DMAEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&self) -> ITBUFEN_R {
                ITBUFEN_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            pub fn itevten(&self) -> ITEVTEN_R {
                ITEVTEN_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            pub fn iterren(&self) -> ITERREN_R {
                ITERREN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            pub fn freq(&self) -> FREQ_R {
                FREQ_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bit 12 - DMA last transfer
            #[inline(always)]
            pub fn last(&mut self) -> LAST_W {
                LAST_W { w: self }
            }
            ///Bit 11 - DMA requests enable
            #[inline(always)]
            pub fn dmaen(&mut self) -> DMAEN_W {
                DMAEN_W { w: self }
            }
            ///Bit 10 - Buffer interrupt enable
            #[inline(always)]
            pub fn itbufen(&mut self) -> ITBUFEN_W {
                ITBUFEN_W { w: self }
            }
            ///Bit 9 - Event interrupt enable
            #[inline(always)]
            pub fn itevten(&mut self) -> ITEVTEN_W {
                ITEVTEN_W { w: self }
            }
            ///Bit 8 - Error interrupt enable
            #[inline(always)]
            pub fn iterren(&mut self) -> ITERREN_W {
                ITERREN_W { w: self }
            }
            ///Bits 0:5 - Peripheral clock frequency
            #[inline(always)]
            pub fn freq(&mut self) -> FREQ_W {
                FREQ_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///OAR1 register accessor: an alias for `Reg<OAR1_SPEC>`
    pub type OAR1 = crate::Reg<oar1::OAR1_SPEC>;
    ///Own address register 1
    pub mod oar1 {
        ///Register `OAR1` reader
        pub struct R(crate::R<OAR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<OAR1_SPEC>> for R {
            fn from(reader: crate::R<OAR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OAR1` writer
        pub struct W(crate::W<OAR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OAR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<OAR1_SPEC>> for W {
            fn from(writer: crate::W<OAR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Addressing mode (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDMODE_A {
            ///0: 7-bit slave address
            ADD7 = 0,
            ///1: 10-bit slave address
            ADD10 = 1,
        }
        impl From<ADDMODE_A> for bool {
            #[inline(always)]
            fn from(variant: ADDMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ADDMODE` reader - Addressing mode (slave mode)
        pub struct ADDMODE_R(crate::FieldReader<bool, ADDMODE_A>);
        impl ADDMODE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ADDMODE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADDMODE_A {
                match self.bits {
                    false => ADDMODE_A::ADD7,
                    true => ADDMODE_A::ADD10,
                }
            }
            ///Checks if the value of the field is `ADD7`
            #[inline(always)]
            pub fn is_add7(&self) -> bool {
                **self == ADDMODE_A::ADD7
            }
            ///Checks if the value of the field is `ADD10`
            #[inline(always)]
            pub fn is_add10(&self) -> bool {
                **self == ADDMODE_A::ADD10
            }
        }
        impl core::ops::Deref for ADDMODE_R {
            type Target = crate::FieldReader<bool, ADDMODE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADDMODE` writer - Addressing mode (slave mode)
        pub struct ADDMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADDMODE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ADDMODE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///7-bit slave address
            #[inline(always)]
            pub fn add7(self) -> &'a mut W {
                self.variant(ADDMODE_A::ADD7)
            }
            ///10-bit slave address
            #[inline(always)]
            pub fn add10(self) -> &'a mut W {
                self.variant(ADDMODE_A::ADD10)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `ADD` reader - Interface address
        pub struct ADD_R(crate::FieldReader<u16, u16>);
        impl ADD_R {
            pub(crate) fn new(bits: u16) -> Self {
                ADD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADD_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADD` writer - Interface address
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03ff) | (value as u32 & 0x03ff);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            pub fn addmode(&self) -> ADDMODE_R {
                ADDMODE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 0:9 - Interface address
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x03ff) as u16)
            }
        }
        impl W {
            ///Bit 15 - Addressing mode (slave mode)
            #[inline(always)]
            pub fn addmode(&mut self) -> ADDMODE_W {
                ADDMODE_W { w: self }
            }
            ///Bits 0:9 - Interface address
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oar1](index.html) module
        pub struct OAR1_SPEC;
        impl crate::RegisterSpec for OAR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [oar1::R](R) reader structure
        impl crate::Readable for OAR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oar1::W](W) writer structure
        impl crate::Writable for OAR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets OAR1 to value 0
        impl crate::Resettable for OAR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///OAR2 register accessor: an alias for `Reg<OAR2_SPEC>`
    pub type OAR2 = crate::Reg<oar2::OAR2_SPEC>;
    ///Own address register 2
    pub mod oar2 {
        ///Register `OAR2` reader
        pub struct R(crate::R<OAR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<OAR2_SPEC>> for R {
            fn from(reader: crate::R<OAR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OAR2` writer
        pub struct W(crate::W<OAR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OAR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<OAR2_SPEC>> for W {
            fn from(writer: crate::W<OAR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD2` reader - Interface address
        pub struct ADD2_R(crate::FieldReader<u8, u8>);
        impl ADD2_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADD2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADD2_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADD2` writer - Interface address
        pub struct ADD2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x7f << 1)) | ((value as u32 & 0x7f) << 1);
                self.w
            }
        }
        ///Dual addressing mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ENDUAL_A {
            ///0: Single addressing mode
            SINGLE = 0,
            ///1: Dual addressing mode
            DUAL = 1,
        }
        impl From<ENDUAL_A> for bool {
            #[inline(always)]
            fn from(variant: ENDUAL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ENDUAL` reader - Dual addressing mode enable
        pub struct ENDUAL_R(crate::FieldReader<bool, ENDUAL_A>);
        impl ENDUAL_R {
            pub(crate) fn new(bits: bool) -> Self {
                ENDUAL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ENDUAL_A {
                match self.bits {
                    false => ENDUAL_A::SINGLE,
                    true => ENDUAL_A::DUAL,
                }
            }
            ///Checks if the value of the field is `SINGLE`
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                **self == ENDUAL_A::SINGLE
            }
            ///Checks if the value of the field is `DUAL`
            #[inline(always)]
            pub fn is_dual(&self) -> bool {
                **self == ENDUAL_A::DUAL
            }
        }
        impl core::ops::Deref for ENDUAL_R {
            type Target = crate::FieldReader<bool, ENDUAL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ENDUAL` writer - Dual addressing mode enable
        pub struct ENDUAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENDUAL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ENDUAL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Single addressing mode
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(ENDUAL_A::SINGLE)
            }
            ///Dual addressing mode
            #[inline(always)]
            pub fn dual(self) -> &'a mut W {
                self.variant(ENDUAL_A::DUAL)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add2(&self) -> ADD2_R {
                ADD2_R::new(((self.bits >> 1) & 0x7f) as u8)
            }
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&self) -> ENDUAL_R {
                ENDUAL_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 1:7 - Interface address
            #[inline(always)]
            pub fn add2(&mut self) -> ADD2_W {
                ADD2_W { w: self }
            }
            ///Bit 0 - Dual addressing mode enable
            #[inline(always)]
            pub fn endual(&mut self) -> ENDUAL_W {
                ENDUAL_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Own address register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oar2](index.html) module
        pub struct OAR2_SPEC;
        impl crate::RegisterSpec for OAR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [oar2::R](R) reader structure
        impl crate::Readable for OAR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oar2::W](W) writer structure
        impl crate::Writable for OAR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets OAR2 to value 0
        impl crate::Resettable for OAR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///Data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - 8-bit data register
        pub struct DR_R(crate::FieldReader<u8, u8>);
        impl DR_R {
            pub(crate) fn new(bits: u8) -> Self {
                DR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DR` writer - 8-bit data register
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - 8-bit data register
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR1 register accessor: an alias for `Reg<SR1_SPEC>`
    pub type SR1 = crate::Reg<sr1::SR1_SPEC>;
    ///Status register 1
    pub mod sr1 {
        ///Register `SR1` reader
        pub struct R(crate::R<SR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR1_SPEC>> for R {
            fn from(reader: crate::R<SR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR1` writer
        pub struct W(crate::W<SR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR1_SPEC>> for W {
            fn from(writer: crate::W<SR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///SMBus alert
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SMBALERT_A {
            ///0: No SMBALERT occured
            NOALERT = 0,
            ///1: SMBALERT occurred
            ALERT = 1,
        }
        impl From<SMBALERT_A> for bool {
            #[inline(always)]
            fn from(variant: SMBALERT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SMBALERT` reader - SMBus alert
        pub struct SMBALERT_R(crate::FieldReader<bool, SMBALERT_A>);
        impl SMBALERT_R {
            pub(crate) fn new(bits: bool) -> Self {
                SMBALERT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMBALERT_A {
                match self.bits {
                    false => SMBALERT_A::NOALERT,
                    true => SMBALERT_A::ALERT,
                }
            }
            ///Checks if the value of the field is `NOALERT`
            #[inline(always)]
            pub fn is_no_alert(&self) -> bool {
                **self == SMBALERT_A::NOALERT
            }
            ///Checks if the value of the field is `ALERT`
            #[inline(always)]
            pub fn is_alert(&self) -> bool {
                **self == SMBALERT_A::ALERT
            }
        }
        impl core::ops::Deref for SMBALERT_R {
            type Target = crate::FieldReader<bool, SMBALERT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMBALERT` writer - SMBus alert
        pub struct SMBALERT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMBALERT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMBALERT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No SMBALERT occured
            #[inline(always)]
            pub fn no_alert(self) -> &'a mut W {
                self.variant(SMBALERT_A::NOALERT)
            }
            ///SMBALERT occurred
            #[inline(always)]
            pub fn alert(self) -> &'a mut W {
                self.variant(SMBALERT_A::ALERT)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Timeout or Tlow error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TIMEOUT_A {
            ///0: No Timeout error
            NOTIMEOUT = 0,
            ///1: SCL remained LOW for 25 ms
            TIMEOUT = 1,
        }
        impl From<TIMEOUT_A> for bool {
            #[inline(always)]
            fn from(variant: TIMEOUT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TIMEOUT` reader - Timeout or Tlow error
        pub struct TIMEOUT_R(crate::FieldReader<bool, TIMEOUT_A>);
        impl TIMEOUT_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIMEOUT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TIMEOUT_A {
                match self.bits {
                    false => TIMEOUT_A::NOTIMEOUT,
                    true => TIMEOUT_A::TIMEOUT,
                }
            }
            ///Checks if the value of the field is `NOTIMEOUT`
            #[inline(always)]
            pub fn is_no_timeout(&self) -> bool {
                **self == TIMEOUT_A::NOTIMEOUT
            }
            ///Checks if the value of the field is `TIMEOUT`
            #[inline(always)]
            pub fn is_timeout(&self) -> bool {
                **self == TIMEOUT_A::TIMEOUT
            }
        }
        impl core::ops::Deref for TIMEOUT_R {
            type Target = crate::FieldReader<bool, TIMEOUT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIMEOUT` writer - Timeout or Tlow error
        pub struct TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIMEOUT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TIMEOUT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No Timeout error
            #[inline(always)]
            pub fn no_timeout(self) -> &'a mut W {
                self.variant(TIMEOUT_A::NOTIMEOUT)
            }
            ///SCL remained LOW for 25 ms
            #[inline(always)]
            pub fn timeout(self) -> &'a mut W {
                self.variant(TIMEOUT_A::TIMEOUT)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///PEC Error in reception
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PECERR_A {
            ///0: no PEC error: receiver returns ACK after PEC reception (if ACK=1)
            NOERROR = 0,
            ///1: PEC error: receiver returns NACK after PEC reception (whatever ACK)
            ERROR = 1,
        }
        impl From<PECERR_A> for bool {
            #[inline(always)]
            fn from(variant: PECERR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PECERR` reader - PEC Error in reception
        pub struct PECERR_R(crate::FieldReader<bool, PECERR_A>);
        impl PECERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                PECERR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PECERR_A {
                match self.bits {
                    false => PECERR_A::NOERROR,
                    true => PECERR_A::ERROR,
                }
            }
            ///Checks if the value of the field is `NOERROR`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                **self == PECERR_A::NOERROR
            }
            ///Checks if the value of the field is `ERROR`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                **self == PECERR_A::ERROR
            }
        }
        impl core::ops::Deref for PECERR_R {
            type Target = crate::FieldReader<bool, PECERR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PECERR` writer - PEC Error in reception
        pub struct PECERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PECERR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PECERR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///no PEC error: receiver returns ACK after PEC reception (if ACK=1)
            #[inline(always)]
            pub fn no_error(self) -> &'a mut W {
                self.variant(PECERR_A::NOERROR)
            }
            ///PEC error: receiver returns NACK after PEC reception (whatever ACK)
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(PECERR_A::ERROR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Overrun/Underrun
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            ///0: No overrun/underrun occured
            NOOVERRUN = 0,
            ///1: Overrun/underrun occured
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OVR` reader - Overrun/Underrun
        pub struct OVR_R(crate::FieldReader<bool, OVR_A>);
        impl OVR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OVR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            ///Checks if the value of the field is `NOOVERRUN`
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                **self == OVR_A::NOOVERRUN
            }
            ///Checks if the value of the field is `OVERRUN`
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                **self == OVR_A::OVERRUN
            }
        }
        impl core::ops::Deref for OVR_R {
            type Target = crate::FieldReader<bool, OVR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OVR` writer - Overrun/Underrun
        pub struct OVR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OVR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OVR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No overrun/underrun occured
            #[inline(always)]
            pub fn no_overrun(self) -> &'a mut W {
                self.variant(OVR_A::NOOVERRUN)
            }
            ///Overrun/underrun occured
            #[inline(always)]
            pub fn overrun(self) -> &'a mut W {
                self.variant(OVR_A::OVERRUN)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Acknowledge failure
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AF_A {
            ///0: No acknowledge failure
            NOFAILURE = 0,
            ///1: Acknowledge failure
            FAILURE = 1,
        }
        impl From<AF_A> for bool {
            #[inline(always)]
            fn from(variant: AF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AF` reader - Acknowledge failure
        pub struct AF_R(crate::FieldReader<bool, AF_A>);
        impl AF_R {
            pub(crate) fn new(bits: bool) -> Self {
                AF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AF_A {
                match self.bits {
                    false => AF_A::NOFAILURE,
                    true => AF_A::FAILURE,
                }
            }
            ///Checks if the value of the field is `NOFAILURE`
            #[inline(always)]
            pub fn is_no_failure(&self) -> bool {
                **self == AF_A::NOFAILURE
            }
            ///Checks if the value of the field is `FAILURE`
            #[inline(always)]
            pub fn is_failure(&self) -> bool {
                **self == AF_A::FAILURE
            }
        }
        impl core::ops::Deref for AF_R {
            type Target = crate::FieldReader<bool, AF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AF` writer - Acknowledge failure
        pub struct AF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No acknowledge failure
            #[inline(always)]
            pub fn no_failure(self) -> &'a mut W {
                self.variant(AF_A::NOFAILURE)
            }
            ///Acknowledge failure
            #[inline(always)]
            pub fn failure(self) -> &'a mut W {
                self.variant(AF_A::FAILURE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Arbitration lost (master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARLO_A {
            ///0: No Arbitration Lost detected
            NOLOST = 0,
            ///1: Arbitration Lost detected
            LOST = 1,
        }
        impl From<ARLO_A> for bool {
            #[inline(always)]
            fn from(variant: ARLO_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARLO` reader - Arbitration lost (master mode)
        pub struct ARLO_R(crate::FieldReader<bool, ARLO_A>);
        impl ARLO_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARLO_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARLO_A {
                match self.bits {
                    false => ARLO_A::NOLOST,
                    true => ARLO_A::LOST,
                }
            }
            ///Checks if the value of the field is `NOLOST`
            #[inline(always)]
            pub fn is_no_lost(&self) -> bool {
                **self == ARLO_A::NOLOST
            }
            ///Checks if the value of the field is `LOST`
            #[inline(always)]
            pub fn is_lost(&self) -> bool {
                **self == ARLO_A::LOST
            }
        }
        impl core::ops::Deref for ARLO_R {
            type Target = crate::FieldReader<bool, ARLO_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARLO` writer - Arbitration lost (master mode)
        pub struct ARLO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARLO_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARLO_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No Arbitration Lost detected
            #[inline(always)]
            pub fn no_lost(self) -> &'a mut W {
                self.variant(ARLO_A::NOLOST)
            }
            ///Arbitration Lost detected
            #[inline(always)]
            pub fn lost(self) -> &'a mut W {
                self.variant(ARLO_A::LOST)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Bus error
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BERR_A {
            ///0: No misplaced Start or Stop condition
            NOERROR = 0,
            ///1: Misplaced Start or Stop condition
            ERROR = 1,
        }
        impl From<BERR_A> for bool {
            #[inline(always)]
            fn from(variant: BERR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BERR` reader - Bus error
        pub struct BERR_R(crate::FieldReader<bool, BERR_A>);
        impl BERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                BERR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BERR_A {
                match self.bits {
                    false => BERR_A::NOERROR,
                    true => BERR_A::ERROR,
                }
            }
            ///Checks if the value of the field is `NOERROR`
            #[inline(always)]
            pub fn is_no_error(&self) -> bool {
                **self == BERR_A::NOERROR
            }
            ///Checks if the value of the field is `ERROR`
            #[inline(always)]
            pub fn is_error(&self) -> bool {
                **self == BERR_A::ERROR
            }
        }
        impl core::ops::Deref for BERR_R {
            type Target = crate::FieldReader<bool, BERR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BERR` writer - Bus error
        pub struct BERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BERR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BERR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No misplaced Start or Stop condition
            #[inline(always)]
            pub fn no_error(self) -> &'a mut W {
                self.variant(BERR_A::NOERROR)
            }
            ///Misplaced Start or Stop condition
            #[inline(always)]
            pub fn error(self) -> &'a mut W {
                self.variant(BERR_A::ERROR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Data register empty (transmitters)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            ///0: Data register not empty
            NOTEMPTY = 0,
            ///1: Data register empty
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TxE` reader - Data register empty (transmitters)
        pub struct TXE_R(crate::FieldReader<bool, TXE_A>);
        impl TXE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            ///Checks if the value of the field is `NOTEMPTY`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                **self == TXE_A::NOTEMPTY
            }
            ///Checks if the value of the field is `EMPTY`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                **self == TXE_A::EMPTY
            }
        }
        impl core::ops::Deref for TXE_R {
            type Target = crate::FieldReader<bool, TXE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Data register not empty (receivers)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            ///0: Data register empty
            EMPTY = 0,
            ///1: Data register not empty
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RxNE` reader - Data register not empty (receivers)
        pub struct RXNE_R(crate::FieldReader<bool, RXNE_A>);
        impl RXNE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            ///Checks if the value of the field is `EMPTY`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                **self == RXNE_A::EMPTY
            }
            ///Checks if the value of the field is `NOTEMPTY`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                **self == RXNE_A::NOTEMPTY
            }
        }
        impl core::ops::Deref for RXNE_R {
            type Target = crate::FieldReader<bool, RXNE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Stop detection (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STOPF_A {
            ///0: No Stop condition detected
            NOSTOP = 0,
            ///1: Stop condition detected
            STOP = 1,
        }
        impl From<STOPF_A> for bool {
            #[inline(always)]
            fn from(variant: STOPF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `STOPF` reader - Stop detection (slave mode)
        pub struct STOPF_R(crate::FieldReader<bool, STOPF_A>);
        impl STOPF_R {
            pub(crate) fn new(bits: bool) -> Self {
                STOPF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOPF_A {
                match self.bits {
                    false => STOPF_A::NOSTOP,
                    true => STOPF_A::STOP,
                }
            }
            ///Checks if the value of the field is `NOSTOP`
            #[inline(always)]
            pub fn is_no_stop(&self) -> bool {
                **self == STOPF_A::NOSTOP
            }
            ///Checks if the value of the field is `STOP`
            #[inline(always)]
            pub fn is_stop(&self) -> bool {
                **self == STOPF_A::STOP
            }
        }
        impl core::ops::Deref for STOPF_R {
            type Target = crate::FieldReader<bool, STOPF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADD10` reader - 10-bit header sent (Master mode)
        pub struct ADD10_R(crate::FieldReader<bool, bool>);
        impl ADD10_R {
            pub(crate) fn new(bits: bool) -> Self {
                ADD10_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADD10_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Byte transfer finished
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BTF_A {
            ///0: Data byte transfer not done
            NOTFINISHED = 0,
            ///1: Data byte transfer successful
            FINISHED = 1,
        }
        impl From<BTF_A> for bool {
            #[inline(always)]
            fn from(variant: BTF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BTF` reader - Byte transfer finished
        pub struct BTF_R(crate::FieldReader<bool, BTF_A>);
        impl BTF_R {
            pub(crate) fn new(bits: bool) -> Self {
                BTF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BTF_A {
                match self.bits {
                    false => BTF_A::NOTFINISHED,
                    true => BTF_A::FINISHED,
                }
            }
            ///Checks if the value of the field is `NOTFINISHED`
            #[inline(always)]
            pub fn is_not_finished(&self) -> bool {
                **self == BTF_A::NOTFINISHED
            }
            ///Checks if the value of the field is `FINISHED`
            #[inline(always)]
            pub fn is_finished(&self) -> bool {
                **self == BTF_A::FINISHED
            }
        }
        impl core::ops::Deref for BTF_R {
            type Target = crate::FieldReader<bool, BTF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Address sent (master mode)/matched (slave mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADDR_A {
            ///0: Adress mismatched or not received
            NOTMATCH = 0,
            ///1: Received slave address matched with one of the enabled slave addresses
            MATCH = 1,
        }
        impl From<ADDR_A> for bool {
            #[inline(always)]
            fn from(variant: ADDR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ADDR` reader - Address sent (master mode)/matched (slave mode)
        pub struct ADDR_R(crate::FieldReader<bool, ADDR_A>);
        impl ADDR_R {
            pub(crate) fn new(bits: bool) -> Self {
                ADDR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADDR_A {
                match self.bits {
                    false => ADDR_A::NOTMATCH,
                    true => ADDR_A::MATCH,
                }
            }
            ///Checks if the value of the field is `NOTMATCH`
            #[inline(always)]
            pub fn is_not_match(&self) -> bool {
                **self == ADDR_A::NOTMATCH
            }
            ///Checks if the value of the field is `MATCH`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                **self == ADDR_A::MATCH
            }
        }
        impl core::ops::Deref for ADDR_R {
            type Target = crate::FieldReader<bool, ADDR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Start bit (Master mode)
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SB_A {
            ///0: No Start condition
            NOSTART = 0,
            ///1: Start condition generated
            START = 1,
        }
        impl From<SB_A> for bool {
            #[inline(always)]
            fn from(variant: SB_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SB` reader - Start bit (Master mode)
        pub struct SB_R(crate::FieldReader<bool, SB_A>);
        impl SB_R {
            pub(crate) fn new(bits: bool) -> Self {
                SB_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SB_A {
                match self.bits {
                    false => SB_A::NOSTART,
                    true => SB_A::START,
                }
            }
            ///Checks if the value of the field is `NOSTART`
            #[inline(always)]
            pub fn is_no_start(&self) -> bool {
                **self == SB_A::NOSTART
            }
            ///Checks if the value of the field is `START`
            #[inline(always)]
            pub fn is_start(&self) -> bool {
                **self == SB_A::START
            }
        }
        impl core::ops::Deref for SB_R {
            type Target = crate::FieldReader<bool, SB_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 15 - SMBus alert
            #[inline(always)]
            pub fn smbalert(&self) -> SMBALERT_R {
                SMBALERT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            pub fn timeout(&self) -> TIMEOUT_R {
                TIMEOUT_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            pub fn pecerr(&self) -> PECERR_R {
                PECERR_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            pub fn af(&self) -> AF_R {
                AF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            pub fn arlo(&self) -> ARLO_R {
                ARLO_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Bus error
            #[inline(always)]
            pub fn berr(&self) -> BERR_R {
                BERR_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Data register empty (transmitters)
            #[inline(always)]
            pub fn tx_e(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Data register not empty (receivers)
            #[inline(always)]
            pub fn rx_ne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 4 - Stop detection (slave mode)
            #[inline(always)]
            pub fn stopf(&self) -> STOPF_R {
                STOPF_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - 10-bit header sent (Master mode)
            #[inline(always)]
            pub fn add10(&self) -> ADD10_R {
                ADD10_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Byte transfer finished
            #[inline(always)]
            pub fn btf(&self) -> BTF_R {
                BTF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Address sent (master mode)/matched (slave mode)
            #[inline(always)]
            pub fn addr(&self) -> ADDR_R {
                ADDR_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Start bit (Master mode)
            #[inline(always)]
            pub fn sb(&self) -> SB_R {
                SB_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 15 - SMBus alert
            #[inline(always)]
            pub fn smbalert(&mut self) -> SMBALERT_W {
                SMBALERT_W { w: self }
            }
            ///Bit 14 - Timeout or Tlow error
            #[inline(always)]
            pub fn timeout(&mut self) -> TIMEOUT_W {
                TIMEOUT_W { w: self }
            }
            ///Bit 12 - PEC Error in reception
            #[inline(always)]
            pub fn pecerr(&mut self) -> PECERR_W {
                PECERR_W { w: self }
            }
            ///Bit 11 - Overrun/Underrun
            #[inline(always)]
            pub fn ovr(&mut self) -> OVR_W {
                OVR_W { w: self }
            }
            ///Bit 10 - Acknowledge failure
            #[inline(always)]
            pub fn af(&mut self) -> AF_W {
                AF_W { w: self }
            }
            ///Bit 9 - Arbitration lost (master mode)
            #[inline(always)]
            pub fn arlo(&mut self) -> ARLO_W {
                ARLO_W { w: self }
            }
            ///Bit 8 - Bus error
            #[inline(always)]
            pub fn berr(&mut self) -> BERR_W {
                BERR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr1](index.html) module
        pub struct SR1_SPEC;
        impl crate::RegisterSpec for SR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr1::R](R) reader structure
        impl crate::Readable for SR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr1::W](W) writer structure
        impl crate::Writable for SR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR1 to value 0
        impl crate::Resettable for SR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR2 register accessor: an alias for `Reg<SR2_SPEC>`
    pub type SR2 = crate::Reg<sr2::SR2_SPEC>;
    ///Status register 2
    pub mod sr2 {
        ///Register `SR2` reader
        pub struct R(crate::R<SR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR2_SPEC>> for R {
            fn from(reader: crate::R<SR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `PEC` reader - acket error checking register
        pub struct PEC_R(crate::FieldReader<u8, u8>);
        impl PEC_R {
            pub(crate) fn new(bits: u8) -> Self {
                PEC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PEC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DUALF` reader - Dual flag (Slave mode)
        pub struct DUALF_R(crate::FieldReader<bool, bool>);
        impl DUALF_R {
            pub(crate) fn new(bits: bool) -> Self {
                DUALF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DUALF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMBHOST` reader - SMBus host header (Slave mode)
        pub struct SMBHOST_R(crate::FieldReader<bool, bool>);
        impl SMBHOST_R {
            pub(crate) fn new(bits: bool) -> Self {
                SMBHOST_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SMBHOST_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMBDEFAULT` reader - SMBus device default address (Slave mode)
        pub struct SMBDEFAULT_R(crate::FieldReader<bool, bool>);
        impl SMBDEFAULT_R {
            pub(crate) fn new(bits: bool) -> Self {
                SMBDEFAULT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SMBDEFAULT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `GENCALL` reader - General call address (Slave mode)
        pub struct GENCALL_R(crate::FieldReader<bool, bool>);
        impl GENCALL_R {
            pub(crate) fn new(bits: bool) -> Self {
                GENCALL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for GENCALL_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TRA` reader - Transmitter/receiver
        pub struct TRA_R(crate::FieldReader<bool, bool>);
        impl TRA_R {
            pub(crate) fn new(bits: bool) -> Self {
                TRA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TRA_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BUSY` reader - Bus busy
        pub struct BUSY_R(crate::FieldReader<bool, bool>);
        impl BUSY_R {
            pub(crate) fn new(bits: bool) -> Self {
                BUSY_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BUSY_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSL` reader - Master/slave
        pub struct MSL_R(crate::FieldReader<bool, bool>);
        impl MSL_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MSL_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 8:15 - acket error checking register
            #[inline(always)]
            pub fn pec(&self) -> PEC_R {
                PEC_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bit 7 - Dual flag (Slave mode)
            #[inline(always)]
            pub fn dualf(&self) -> DUALF_R {
                DUALF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - SMBus host header (Slave mode)
            #[inline(always)]
            pub fn smbhost(&self) -> SMBHOST_R {
                SMBHOST_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - SMBus device default address (Slave mode)
            #[inline(always)]
            pub fn smbdefault(&self) -> SMBDEFAULT_R {
                SMBDEFAULT_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - General call address (Slave mode)
            #[inline(always)]
            pub fn gencall(&self) -> GENCALL_R {
                GENCALL_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 2 - Transmitter/receiver
            #[inline(always)]
            pub fn tra(&self) -> TRA_R {
                TRA_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Bus busy
            #[inline(always)]
            pub fn busy(&self) -> BUSY_R {
                BUSY_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Master/slave
            #[inline(always)]
            pub fn msl(&self) -> MSL_R {
                MSL_R::new((self.bits & 0x01) != 0)
            }
        }
        ///Status register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr2](index.html) module
        pub struct SR2_SPEC;
        impl crate::RegisterSpec for SR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr2::R](R) reader structure
        impl crate::Readable for SR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets SR2 to value 0
        impl crate::Resettable for SR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR register accessor: an alias for `Reg<CCR_SPEC>`
    pub type CCR = crate::Reg<ccr::CCR_SPEC>;
    ///Clock control register
    pub mod ccr {
        ///Register `CCR` reader
        pub struct R(crate::R<CCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR_SPEC>> for R {
            fn from(reader: crate::R<CCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR` writer
        pub struct W(crate::W<CCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR_SPEC>> for W {
            fn from(writer: crate::W<CCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///I2C master mode selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum F_S_A {
            ///0: Standard mode I2C
            STANDARD = 0,
            ///1: Fast mode I2C
            FAST = 1,
        }
        impl From<F_S_A> for bool {
            #[inline(always)]
            fn from(variant: F_S_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `F_S` reader - I2C master mode selection
        pub struct F_S_R(crate::FieldReader<bool, F_S_A>);
        impl F_S_R {
            pub(crate) fn new(bits: bool) -> Self {
                F_S_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> F_S_A {
                match self.bits {
                    false => F_S_A::STANDARD,
                    true => F_S_A::FAST,
                }
            }
            ///Checks if the value of the field is `STANDARD`
            #[inline(always)]
            pub fn is_standard(&self) -> bool {
                **self == F_S_A::STANDARD
            }
            ///Checks if the value of the field is `FAST`
            #[inline(always)]
            pub fn is_fast(&self) -> bool {
                **self == F_S_A::FAST
            }
        }
        impl core::ops::Deref for F_S_R {
            type Target = crate::FieldReader<bool, F_S_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `F_S` writer - I2C master mode selection
        pub struct F_S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> F_S_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: F_S_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Standard mode I2C
            #[inline(always)]
            pub fn standard(self) -> &'a mut W {
                self.variant(F_S_A::STANDARD)
            }
            ///Fast mode I2C
            #[inline(always)]
            pub fn fast(self) -> &'a mut W {
                self.variant(F_S_A::FAST)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Fast mode duty cycle
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DUTY_A {
            ///0: Duty cycle t_low/t_high = 2/1
            DUTY2_1 = 0,
            ///1: Duty cycle t_low/t_high = 16/9
            DUTY16_9 = 1,
        }
        impl From<DUTY_A> for bool {
            #[inline(always)]
            fn from(variant: DUTY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DUTY` reader - Fast mode duty cycle
        pub struct DUTY_R(crate::FieldReader<bool, DUTY_A>);
        impl DUTY_R {
            pub(crate) fn new(bits: bool) -> Self {
                DUTY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DUTY_A {
                match self.bits {
                    false => DUTY_A::DUTY2_1,
                    true => DUTY_A::DUTY16_9,
                }
            }
            ///Checks if the value of the field is `DUTY2_1`
            #[inline(always)]
            pub fn is_duty2_1(&self) -> bool {
                **self == DUTY_A::DUTY2_1
            }
            ///Checks if the value of the field is `DUTY16_9`
            #[inline(always)]
            pub fn is_duty16_9(&self) -> bool {
                **self == DUTY_A::DUTY16_9
            }
        }
        impl core::ops::Deref for DUTY_R {
            type Target = crate::FieldReader<bool, DUTY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DUTY` writer - Fast mode duty cycle
        pub struct DUTY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DUTY_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DUTY_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Duty cycle t_low/t_high = 2/1
            #[inline(always)]
            pub fn duty2_1(self) -> &'a mut W {
                self.variant(DUTY_A::DUTY2_1)
            }
            ///Duty cycle t_low/t_high = 16/9
            #[inline(always)]
            pub fn duty16_9(self) -> &'a mut W {
                self.variant(DUTY_A::DUTY16_9)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `CCR` reader - Clock control register in Fast/Standard mode (Master mode)
        pub struct CCR_R(crate::FieldReader<u16, u16>);
        impl CCR_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR` writer - Clock control register in Fast/Standard mode (Master mode)
        pub struct CCR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            pub fn f_s(&self) -> F_S_R {
                F_S_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            pub fn duty(&self) -> DUTY_R {
                DUTY_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn ccr(&self) -> CCR_R {
                CCR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bit 15 - I2C master mode selection
            #[inline(always)]
            pub fn f_s(&mut self) -> F_S_W {
                F_S_W { w: self }
            }
            ///Bit 14 - Fast mode duty cycle
            #[inline(always)]
            pub fn duty(&mut self) -> DUTY_W {
                DUTY_W { w: self }
            }
            ///Bits 0:11 - Clock control register in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn ccr(&mut self) -> CCR_W {
                CCR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Clock control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr](index.html) module
        pub struct CCR_SPEC;
        impl crate::RegisterSpec for CCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr::R](R) reader structure
        impl crate::Readable for CCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr::W](W) writer structure
        impl crate::Writable for CCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR to value 0
        impl crate::Resettable for CCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///TRISE register accessor: an alias for `Reg<TRISE_SPEC>`
    pub type TRISE = crate::Reg<trise::TRISE_SPEC>;
    ///TRISE register
    pub mod trise {
        ///Register `TRISE` reader
        pub struct R(crate::R<TRISE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TRISE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<TRISE_SPEC>> for R {
            fn from(reader: crate::R<TRISE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TRISE` writer
        pub struct W(crate::W<TRISE_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TRISE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<TRISE_SPEC>> for W {
            fn from(writer: crate::W<TRISE_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TRISE` reader - Maximum rise time in Fast/Standard mode (Master mode)
        pub struct TRISE_R(crate::FieldReader<u8, u8>);
        impl TRISE_R {
            pub(crate) fn new(bits: u8) -> Self {
                TRISE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TRISE_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TRISE` writer - Maximum rise time in Fast/Standard mode (Master mode)
        pub struct TRISE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRISE_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3f) | (value as u32 & 0x3f);
                self.w
            }
        }
        impl R {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn trise(&self) -> TRISE_R {
                TRISE_R::new((self.bits & 0x3f) as u8)
            }
        }
        impl W {
            ///Bits 0:5 - Maximum rise time in Fast/Standard mode (Master mode)
            #[inline(always)]
            pub fn trise(&mut self) -> TRISE_W {
                TRISE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///TRISE register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [trise](index.html) module
        pub struct TRISE_SPEC;
        impl crate::RegisterSpec for TRISE_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [trise::R](R) reader structure
        impl crate::Readable for TRISE_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [trise::W](W) writer structure
        impl crate::Writable for TRISE_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets TRISE to value 0x02
        impl crate::Resettable for TRISE_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x02
            }
        }
    }
}
///Inter integrated circuit
pub struct I2C2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2C2 {}
impl I2C2 {
    ///Pointer to the register block
    pub const PTR: *const i2c1::RegisterBlock = 0x4000_5800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const i2c1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for I2C2 {
    type Target = i2c1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2C2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2C2").finish()
    }
}
///Serial peripheral interface
pub struct SPI1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI1 {}
impl SPI1 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4001_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI1 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI1").finish()
    }
}
///Serial peripheral interface
pub mod spi1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x0c - data register
        pub dr: crate::Reg<dr::DR_SPEC>,
        ///0x10 - CRC polynomial register
        pub crcpr: crate::Reg<crcpr::CRCPR_SPEC>,
        ///0x14 - RX CRC register
        pub rxcrcr: crate::Reg<rxcrcr::RXCRCR_SPEC>,
        ///0x18 - TX CRC register
        pub txcrcr: crate::Reg<txcrcr::TXCRCR_SPEC>,
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Bidirectional data mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIMODE_A {
            ///0: 2-line unidirectional data mode selected
            UNIDIRECTIONAL = 0,
            ///1: 1-line bidirectional data mode selected
            BIDIRECTIONAL = 1,
        }
        impl From<BIDIMODE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIMODE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BIDIMODE` reader - Bidirectional data mode enable
        pub struct BIDIMODE_R(crate::FieldReader<bool, BIDIMODE_A>);
        impl BIDIMODE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIDIMODE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BIDIMODE_A {
                match self.bits {
                    false => BIDIMODE_A::UNIDIRECTIONAL,
                    true => BIDIMODE_A::BIDIRECTIONAL,
                }
            }
            ///Checks if the value of the field is `UNIDIRECTIONAL`
            #[inline(always)]
            pub fn is_unidirectional(&self) -> bool {
                **self == BIDIMODE_A::UNIDIRECTIONAL
            }
            ///Checks if the value of the field is `BIDIRECTIONAL`
            #[inline(always)]
            pub fn is_bidirectional(&self) -> bool {
                **self == BIDIMODE_A::BIDIRECTIONAL
            }
        }
        impl core::ops::Deref for BIDIMODE_R {
            type Target = crate::FieldReader<bool, BIDIMODE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIDIMODE` writer - Bidirectional data mode enable
        pub struct BIDIMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIMODE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BIDIMODE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///2-line unidirectional data mode selected
            #[inline(always)]
            pub fn unidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::UNIDIRECTIONAL)
            }
            ///1-line bidirectional data mode selected
            #[inline(always)]
            pub fn bidirectional(self) -> &'a mut W {
                self.variant(BIDIMODE_A::BIDIRECTIONAL)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Output enable in bidirectional mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIDIOE_A {
            ///0: Output disabled (receive-only mode)
            OUTPUTDISABLED = 0,
            ///1: Output enabled (transmit-only mode)
            OUTPUTENABLED = 1,
        }
        impl From<BIDIOE_A> for bool {
            #[inline(always)]
            fn from(variant: BIDIOE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BIDIOE` reader - Output enable in bidirectional mode
        pub struct BIDIOE_R(crate::FieldReader<bool, BIDIOE_A>);
        impl BIDIOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIDIOE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BIDIOE_A {
                match self.bits {
                    false => BIDIOE_A::OUTPUTDISABLED,
                    true => BIDIOE_A::OUTPUTENABLED,
                }
            }
            ///Checks if the value of the field is `OUTPUTDISABLED`
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                **self == BIDIOE_A::OUTPUTDISABLED
            }
            ///Checks if the value of the field is `OUTPUTENABLED`
            #[inline(always)]
            pub fn is_output_enabled(&self) -> bool {
                **self == BIDIOE_A::OUTPUTENABLED
            }
        }
        impl core::ops::Deref for BIDIOE_R {
            type Target = crate::FieldReader<bool, BIDIOE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIDIOE` writer - Output enable in bidirectional mode
        pub struct BIDIOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIDIOE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BIDIOE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Output disabled (receive-only mode)
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTDISABLED)
            }
            ///Output enabled (transmit-only mode)
            #[inline(always)]
            pub fn output_enabled(self) -> &'a mut W {
                self.variant(BIDIOE_A::OUTPUTENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Hardware CRC calculation enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCEN_A {
            ///0: CRC calculation disabled
            DISABLED = 0,
            ///1: CRC calculation enabled
            ENABLED = 1,
        }
        impl From<CRCEN_A> for bool {
            #[inline(always)]
            fn from(variant: CRCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CRCEN` reader - Hardware CRC calculation enable
        pub struct CRCEN_R(crate::FieldReader<bool, CRCEN_A>);
        impl CRCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CRCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCEN_A {
                match self.bits {
                    false => CRCEN_A::DISABLED,
                    true => CRCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CRCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CRCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CRCEN_R {
            type Target = crate::FieldReader<bool, CRCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CRCEN` writer - Hardware CRC calculation enable
        pub struct CRCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CRCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CRC calculation disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CRCEN_A::DISABLED)
            }
            ///CRC calculation enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CRCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///CRC transfer next
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCNEXT_A {
            ///0: Next transmit value is from Tx buffer
            TXBUFFER = 0,
            ///1: Next transmit value is from Tx CRC register
            CRC = 1,
        }
        impl From<CRCNEXT_A> for bool {
            #[inline(always)]
            fn from(variant: CRCNEXT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CRCNEXT` reader - CRC transfer next
        pub struct CRCNEXT_R(crate::FieldReader<bool, CRCNEXT_A>);
        impl CRCNEXT_R {
            pub(crate) fn new(bits: bool) -> Self {
                CRCNEXT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCNEXT_A {
                match self.bits {
                    false => CRCNEXT_A::TXBUFFER,
                    true => CRCNEXT_A::CRC,
                }
            }
            ///Checks if the value of the field is `TXBUFFER`
            #[inline(always)]
            pub fn is_tx_buffer(&self) -> bool {
                **self == CRCNEXT_A::TXBUFFER
            }
            ///Checks if the value of the field is `CRC`
            #[inline(always)]
            pub fn is_crc(&self) -> bool {
                **self == CRCNEXT_A::CRC
            }
        }
        impl core::ops::Deref for CRCNEXT_R {
            type Target = crate::FieldReader<bool, CRCNEXT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CRCNEXT` writer - CRC transfer next
        pub struct CRCNEXT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCNEXT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CRCNEXT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Next transmit value is from Tx buffer
            #[inline(always)]
            pub fn tx_buffer(self) -> &'a mut W {
                self.variant(CRCNEXT_A::TXBUFFER)
            }
            ///Next transmit value is from Tx CRC register
            #[inline(always)]
            pub fn crc(self) -> &'a mut W {
                self.variant(CRCNEXT_A::CRC)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Data frame format
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DFF_A {
            ///0: 8-bit data frame format is selected for transmission/reception
            EIGHTBIT = 0,
            ///1: 16-bit data frame format is selected for transmission/reception
            SIXTEENBIT = 1,
        }
        impl From<DFF_A> for bool {
            #[inline(always)]
            fn from(variant: DFF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DFF` reader - Data frame format
        pub struct DFF_R(crate::FieldReader<bool, DFF_A>);
        impl DFF_R {
            pub(crate) fn new(bits: bool) -> Self {
                DFF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DFF_A {
                match self.bits {
                    false => DFF_A::EIGHTBIT,
                    true => DFF_A::SIXTEENBIT,
                }
            }
            ///Checks if the value of the field is `EIGHTBIT`
            #[inline(always)]
            pub fn is_eight_bit(&self) -> bool {
                **self == DFF_A::EIGHTBIT
            }
            ///Checks if the value of the field is `SIXTEENBIT`
            #[inline(always)]
            pub fn is_sixteen_bit(&self) -> bool {
                **self == DFF_A::SIXTEENBIT
            }
        }
        impl core::ops::Deref for DFF_R {
            type Target = crate::FieldReader<bool, DFF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DFF` writer - Data frame format
        pub struct DFF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DFF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DFF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///8-bit data frame format is selected for transmission/reception
            #[inline(always)]
            pub fn eight_bit(self) -> &'a mut W {
                self.variant(DFF_A::EIGHTBIT)
            }
            ///16-bit data frame format is selected for transmission/reception
            #[inline(always)]
            pub fn sixteen_bit(self) -> &'a mut W {
                self.variant(DFF_A::SIXTEENBIT)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Receive only
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXONLY_A {
            ///0: Full duplex (Transmit and receive)
            FULLDUPLEX = 0,
            ///1: Output disabled (Receive-only mode)
            OUTPUTDISABLED = 1,
        }
        impl From<RXONLY_A> for bool {
            #[inline(always)]
            fn from(variant: RXONLY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXONLY` reader - Receive only
        pub struct RXONLY_R(crate::FieldReader<bool, RXONLY_A>);
        impl RXONLY_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXONLY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXONLY_A {
                match self.bits {
                    false => RXONLY_A::FULLDUPLEX,
                    true => RXONLY_A::OUTPUTDISABLED,
                }
            }
            ///Checks if the value of the field is `FULLDUPLEX`
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                **self == RXONLY_A::FULLDUPLEX
            }
            ///Checks if the value of the field is `OUTPUTDISABLED`
            #[inline(always)]
            pub fn is_output_disabled(&self) -> bool {
                **self == RXONLY_A::OUTPUTDISABLED
            }
        }
        impl core::ops::Deref for RXONLY_R {
            type Target = crate::FieldReader<bool, RXONLY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXONLY` writer - Receive only
        pub struct RXONLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXONLY_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RXONLY_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Full duplex (Transmit and receive)
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(RXONLY_A::FULLDUPLEX)
            }
            ///Output disabled (Receive-only mode)
            #[inline(always)]
            pub fn output_disabled(self) -> &'a mut W {
                self.variant(RXONLY_A::OUTPUTDISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Software slave management
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSM_A {
            ///0: Software slave management disabled
            DISABLED = 0,
            ///1: Software slave management enabled
            ENABLED = 1,
        }
        impl From<SSM_A> for bool {
            #[inline(always)]
            fn from(variant: SSM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SSM` reader - Software slave management
        pub struct SSM_R(crate::FieldReader<bool, SSM_A>);
        impl SSM_R {
            pub(crate) fn new(bits: bool) -> Self {
                SSM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSM_A {
                match self.bits {
                    false => SSM_A::DISABLED,
                    true => SSM_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SSM_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == SSM_A::ENABLED
            }
        }
        impl core::ops::Deref for SSM_R {
            type Target = crate::FieldReader<bool, SSM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SSM` writer - Software slave management
        pub struct SSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SSM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Software slave management disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSM_A::DISABLED)
            }
            ///Software slave management enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSM_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Internal slave select
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSI_A {
            ///0: 0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            SLAVESELECTED = 0,
            ///1: 1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            SLAVENOTSELECTED = 1,
        }
        impl From<SSI_A> for bool {
            #[inline(always)]
            fn from(variant: SSI_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SSI` reader - Internal slave select
        pub struct SSI_R(crate::FieldReader<bool, SSI_A>);
        impl SSI_R {
            pub(crate) fn new(bits: bool) -> Self {
                SSI_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSI_A {
                match self.bits {
                    false => SSI_A::SLAVESELECTED,
                    true => SSI_A::SLAVENOTSELECTED,
                }
            }
            ///Checks if the value of the field is `SLAVESELECTED`
            #[inline(always)]
            pub fn is_slave_selected(&self) -> bool {
                **self == SSI_A::SLAVESELECTED
            }
            ///Checks if the value of the field is `SLAVENOTSELECTED`
            #[inline(always)]
            pub fn is_slave_not_selected(&self) -> bool {
                **self == SSI_A::SLAVENOTSELECTED
            }
        }
        impl core::ops::Deref for SSI_R {
            type Target = crate::FieldReader<bool, SSI_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SSI` writer - Internal slave select
        pub struct SSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSI_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SSI_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///0 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            #[inline(always)]
            pub fn slave_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVESELECTED)
            }
            ///1 is forced onto the NSS pin and the I/O value of the NSS pin is ignored
            #[inline(always)]
            pub fn slave_not_selected(self) -> &'a mut W {
                self.variant(SSI_A::SLAVENOTSELECTED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Frame format
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LSBFIRST_A {
            ///0: Data is transmitted/received with the MSB first
            MSBFIRST = 0,
            ///1: Data is transmitted/received with the LSB first
            LSBFIRST = 1,
        }
        impl From<LSBFIRST_A> for bool {
            #[inline(always)]
            fn from(variant: LSBFIRST_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LSBFIRST` reader - Frame format
        pub struct LSBFIRST_R(crate::FieldReader<bool, LSBFIRST_A>);
        impl LSBFIRST_R {
            pub(crate) fn new(bits: bool) -> Self {
                LSBFIRST_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LSBFIRST_A {
                match self.bits {
                    false => LSBFIRST_A::MSBFIRST,
                    true => LSBFIRST_A::LSBFIRST,
                }
            }
            ///Checks if the value of the field is `MSBFIRST`
            #[inline(always)]
            pub fn is_msbfirst(&self) -> bool {
                **self == LSBFIRST_A::MSBFIRST
            }
            ///Checks if the value of the field is `LSBFIRST`
            #[inline(always)]
            pub fn is_lsbfirst(&self) -> bool {
                **self == LSBFIRST_A::LSBFIRST
            }
        }
        impl core::ops::Deref for LSBFIRST_R {
            type Target = crate::FieldReader<bool, LSBFIRST_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LSBFIRST` writer - Frame format
        pub struct LSBFIRST_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LSBFIRST_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LSBFIRST_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Data is transmitted/received with the MSB first
            #[inline(always)]
            pub fn msbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::MSBFIRST)
            }
            ///Data is transmitted/received with the LSB first
            #[inline(always)]
            pub fn lsbfirst(self) -> &'a mut W {
                self.variant(LSBFIRST_A::LSBFIRST)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///SPI enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SPE_A {
            ///0: Peripheral disabled
            DISABLED = 0,
            ///1: Peripheral enabled
            ENABLED = 1,
        }
        impl From<SPE_A> for bool {
            #[inline(always)]
            fn from(variant: SPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SPE` reader - SPI enable
        pub struct SPE_R(crate::FieldReader<bool, SPE_A>);
        impl SPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                SPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SPE_A {
                match self.bits {
                    false => SPE_A::DISABLED,
                    true => SPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == SPE_A::ENABLED
            }
        }
        impl core::ops::Deref for SPE_R {
            type Target = crate::FieldReader<bool, SPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SPE` writer - SPI enable
        pub struct SPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Peripheral disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SPE_A::DISABLED)
            }
            ///Peripheral enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Baud rate control
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum BR_A {
            ///0: f_PCLK / 2
            DIV2 = 0,
            ///1: f_PCLK / 4
            DIV4 = 1,
            ///2: f_PCLK / 8
            DIV8 = 2,
            ///3: f_PCLK / 16
            DIV16 = 3,
            ///4: f_PCLK / 32
            DIV32 = 4,
            ///5: f_PCLK / 64
            DIV64 = 5,
            ///6: f_PCLK / 128
            DIV128 = 6,
            ///7: f_PCLK / 256
            DIV256 = 7,
        }
        impl From<BR_A> for u8 {
            #[inline(always)]
            fn from(variant: BR_A) -> Self {
                variant as _
            }
        }
        ///Field `BR` reader - Baud rate control
        pub struct BR_R(crate::FieldReader<u8, BR_A>);
        impl BR_R {
            pub(crate) fn new(bits: u8) -> Self {
                BR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BR_A {
                match self.bits {
                    0 => BR_A::DIV2,
                    1 => BR_A::DIV4,
                    2 => BR_A::DIV8,
                    3 => BR_A::DIV16,
                    4 => BR_A::DIV32,
                    5 => BR_A::DIV64,
                    6 => BR_A::DIV128,
                    7 => BR_A::DIV256,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == BR_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == BR_A::DIV4
            }
            ///Checks if the value of the field is `DIV8`
            #[inline(always)]
            pub fn is_div8(&self) -> bool {
                **self == BR_A::DIV8
            }
            ///Checks if the value of the field is `DIV16`
            #[inline(always)]
            pub fn is_div16(&self) -> bool {
                **self == BR_A::DIV16
            }
            ///Checks if the value of the field is `DIV32`
            #[inline(always)]
            pub fn is_div32(&self) -> bool {
                **self == BR_A::DIV32
            }
            ///Checks if the value of the field is `DIV64`
            #[inline(always)]
            pub fn is_div64(&self) -> bool {
                **self == BR_A::DIV64
            }
            ///Checks if the value of the field is `DIV128`
            #[inline(always)]
            pub fn is_div128(&self) -> bool {
                **self == BR_A::DIV128
            }
            ///Checks if the value of the field is `DIV256`
            #[inline(always)]
            pub fn is_div256(&self) -> bool {
                **self == BR_A::DIV256
            }
        }
        impl core::ops::Deref for BR_R {
            type Target = crate::FieldReader<u8, BR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BR` writer - Baud rate control
        pub struct BR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BR_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///f_PCLK / 2
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(BR_A::DIV2)
            }
            ///f_PCLK / 4
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(BR_A::DIV4)
            }
            ///f_PCLK / 8
            #[inline(always)]
            pub fn div8(self) -> &'a mut W {
                self.variant(BR_A::DIV8)
            }
            ///f_PCLK / 16
            #[inline(always)]
            pub fn div16(self) -> &'a mut W {
                self.variant(BR_A::DIV16)
            }
            ///f_PCLK / 32
            #[inline(always)]
            pub fn div32(self) -> &'a mut W {
                self.variant(BR_A::DIV32)
            }
            ///f_PCLK / 64
            #[inline(always)]
            pub fn div64(self) -> &'a mut W {
                self.variant(BR_A::DIV64)
            }
            ///f_PCLK / 128
            #[inline(always)]
            pub fn div128(self) -> &'a mut W {
                self.variant(BR_A::DIV128)
            }
            ///f_PCLK / 256
            #[inline(always)]
            pub fn div256(self) -> &'a mut W {
                self.variant(BR_A::DIV256)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | ((value as u32 & 0x07) << 3);
                self.w
            }
        }
        ///Master selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MSTR_A {
            ///0: Slave configuration
            SLAVE = 0,
            ///1: Master configuration
            MASTER = 1,
        }
        impl From<MSTR_A> for bool {
            #[inline(always)]
            fn from(variant: MSTR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MSTR` reader - Master selection
        pub struct MSTR_R(crate::FieldReader<bool, MSTR_A>);
        impl MSTR_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSTR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MSTR_A {
                match self.bits {
                    false => MSTR_A::SLAVE,
                    true => MSTR_A::MASTER,
                }
            }
            ///Checks if the value of the field is `SLAVE`
            #[inline(always)]
            pub fn is_slave(&self) -> bool {
                **self == MSTR_A::SLAVE
            }
            ///Checks if the value of the field is `MASTER`
            #[inline(always)]
            pub fn is_master(&self) -> bool {
                **self == MSTR_A::MASTER
            }
        }
        impl core::ops::Deref for MSTR_R {
            type Target = crate::FieldReader<bool, MSTR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSTR` writer - Master selection
        pub struct MSTR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSTR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: MSTR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Slave configuration
            #[inline(always)]
            pub fn slave(self) -> &'a mut W {
                self.variant(MSTR_A::SLAVE)
            }
            ///Master configuration
            #[inline(always)]
            pub fn master(self) -> &'a mut W {
                self.variant(MSTR_A::MASTER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Clock polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            ///0: CK to 0 when idle
            IDLELOW = 0,
            ///1: CK to 1 when idle
            IDLEHIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CPOL` reader - Clock polarity
        pub struct CPOL_R(crate::FieldReader<bool, CPOL_A>);
        impl CPOL_R {
            pub(crate) fn new(bits: bool) -> Self {
                CPOL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::IDLELOW,
                    true => CPOL_A::IDLEHIGH,
                }
            }
            ///Checks if the value of the field is `IDLELOW`
            #[inline(always)]
            pub fn is_idle_low(&self) -> bool {
                **self == CPOL_A::IDLELOW
            }
            ///Checks if the value of the field is `IDLEHIGH`
            #[inline(always)]
            pub fn is_idle_high(&self) -> bool {
                **self == CPOL_A::IDLEHIGH
            }
        }
        impl core::ops::Deref for CPOL_R {
            type Target = crate::FieldReader<bool, CPOL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPOL` writer - Clock polarity
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CK to 0 when idle
            #[inline(always)]
            pub fn idle_low(self) -> &'a mut W {
                self.variant(CPOL_A::IDLELOW)
            }
            ///CK to 1 when idle
            #[inline(always)]
            pub fn idle_high(self) -> &'a mut W {
                self.variant(CPOL_A::IDLEHIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Clock phase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            ///0: The first clock transition is the first data capture edge
            FIRSTEDGE = 0,
            ///1: The second clock transition is the first data capture edge
            SECONDEDGE = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CPHA` reader - Clock phase
        pub struct CPHA_R(crate::FieldReader<bool, CPHA_A>);
        impl CPHA_R {
            pub(crate) fn new(bits: bool) -> Self {
                CPHA_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRSTEDGE,
                    true => CPHA_A::SECONDEDGE,
                }
            }
            ///Checks if the value of the field is `FIRSTEDGE`
            #[inline(always)]
            pub fn is_first_edge(&self) -> bool {
                **self == CPHA_A::FIRSTEDGE
            }
            ///Checks if the value of the field is `SECONDEDGE`
            #[inline(always)]
            pub fn is_second_edge(&self) -> bool {
                **self == CPHA_A::SECONDEDGE
            }
        }
        impl core::ops::Deref for CPHA_R {
            type Target = crate::FieldReader<bool, CPHA_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPHA` writer - Clock phase
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The first clock transition is the first data capture edge
            #[inline(always)]
            pub fn first_edge(self) -> &'a mut W {
                self.variant(CPHA_A::FIRSTEDGE)
            }
            ///The second clock transition is the first data capture edge
            #[inline(always)]
            pub fn second_edge(self) -> &'a mut W {
                self.variant(CPHA_A::SECONDEDGE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            pub fn bidimode(&self) -> BIDIMODE_R {
                BIDIMODE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            pub fn bidioe(&self) -> BIDIOE_R {
                BIDIOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            pub fn crcen(&self) -> CRCEN_R {
                CRCEN_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            pub fn crcnext(&self) -> CRCNEXT_R {
                CRCNEXT_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            pub fn dff(&self) -> DFF_R {
                DFF_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            pub fn rxonly(&self) -> RXONLY_R {
                RXONLY_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            pub fn ssm(&self) -> SSM_R {
                SSM_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            pub fn ssi(&self) -> SSI_R {
                SSI_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            pub fn lsbfirst(&self) -> LSBFIRST_R {
                LSBFIRST_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            pub fn spe(&self) -> SPE_R {
                SPE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            pub fn br(&self) -> BR_R {
                BR_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            pub fn mstr(&self) -> MSTR_R {
                MSTR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 15 - Bidirectional data mode enable
            #[inline(always)]
            pub fn bidimode(&mut self) -> BIDIMODE_W {
                BIDIMODE_W { w: self }
            }
            ///Bit 14 - Output enable in bidirectional mode
            #[inline(always)]
            pub fn bidioe(&mut self) -> BIDIOE_W {
                BIDIOE_W { w: self }
            }
            ///Bit 13 - Hardware CRC calculation enable
            #[inline(always)]
            pub fn crcen(&mut self) -> CRCEN_W {
                CRCEN_W { w: self }
            }
            ///Bit 12 - CRC transfer next
            #[inline(always)]
            pub fn crcnext(&mut self) -> CRCNEXT_W {
                CRCNEXT_W { w: self }
            }
            ///Bit 11 - Data frame format
            #[inline(always)]
            pub fn dff(&mut self) -> DFF_W {
                DFF_W { w: self }
            }
            ///Bit 10 - Receive only
            #[inline(always)]
            pub fn rxonly(&mut self) -> RXONLY_W {
                RXONLY_W { w: self }
            }
            ///Bit 9 - Software slave management
            #[inline(always)]
            pub fn ssm(&mut self) -> SSM_W {
                SSM_W { w: self }
            }
            ///Bit 8 - Internal slave select
            #[inline(always)]
            pub fn ssi(&mut self) -> SSI_W {
                SSI_W { w: self }
            }
            ///Bit 7 - Frame format
            #[inline(always)]
            pub fn lsbfirst(&mut self) -> LSBFIRST_W {
                LSBFIRST_W { w: self }
            }
            ///Bit 6 - SPI enable
            #[inline(always)]
            pub fn spe(&mut self) -> SPE_W {
                SPE_W { w: self }
            }
            ///Bits 3:5 - Baud rate control
            #[inline(always)]
            pub fn br(&mut self) -> BR_W {
                BR_W { w: self }
            }
            ///Bit 2 - Master selection
            #[inline(always)]
            pub fn mstr(&mut self) -> MSTR_W {
                MSTR_W { w: self }
            }
            ///Bit 1 - Clock polarity
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            ///Bit 0 - Clock phase
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Tx buffer empty interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            ///0: TXE interrupt masked
            MASKED = 0,
            ///1: TXE interrupt not masked
            NOTMASKED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TXEIE` reader - Tx buffer empty interrupt enable
        pub struct TXEIE_R(crate::FieldReader<bool, TXEIE_A>);
        impl TXEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::MASKED,
                    true => TXEIE_A::NOTMASKED,
                }
            }
            ///Checks if the value of the field is `MASKED`
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                **self == TXEIE_A::MASKED
            }
            ///Checks if the value of the field is `NOTMASKED`
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                **self == TXEIE_A::NOTMASKED
            }
        }
        impl core::ops::Deref for TXEIE_R {
            type Target = crate::FieldReader<bool, TXEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TXEIE` writer - Tx buffer empty interrupt enable
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TXE interrupt masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(TXEIE_A::MASKED)
            }
            ///TXE interrupt not masked
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(TXEIE_A::NOTMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///RX buffer not empty interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            ///0: RXE interrupt masked
            MASKED = 0,
            ///1: RXE interrupt not masked
            NOTMASKED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXNEIE` reader - RX buffer not empty interrupt enable
        pub struct RXNEIE_R(crate::FieldReader<bool, RXNEIE_A>);
        impl RXNEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::MASKED,
                    true => RXNEIE_A::NOTMASKED,
                }
            }
            ///Checks if the value of the field is `MASKED`
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                **self == RXNEIE_A::MASKED
            }
            ///Checks if the value of the field is `NOTMASKED`
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                **self == RXNEIE_A::NOTMASKED
            }
        }
        impl core::ops::Deref for RXNEIE_R {
            type Target = crate::FieldReader<bool, RXNEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNEIE` writer - RX buffer not empty interrupt enable
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RXE interrupt masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::MASKED)
            }
            ///RXE interrupt not masked
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(RXNEIE_A::NOTMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ERRIE_A {
            ///0: Error interrupt masked
            MASKED = 0,
            ///1: Error interrupt not masked
            NOTMASKED = 1,
        }
        impl From<ERRIE_A> for bool {
            #[inline(always)]
            fn from(variant: ERRIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ERRIE` reader - Error interrupt enable
        pub struct ERRIE_R(crate::FieldReader<bool, ERRIE_A>);
        impl ERRIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ERRIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ERRIE_A {
                match self.bits {
                    false => ERRIE_A::MASKED,
                    true => ERRIE_A::NOTMASKED,
                }
            }
            ///Checks if the value of the field is `MASKED`
            #[inline(always)]
            pub fn is_masked(&self) -> bool {
                **self == ERRIE_A::MASKED
            }
            ///Checks if the value of the field is `NOTMASKED`
            #[inline(always)]
            pub fn is_not_masked(&self) -> bool {
                **self == ERRIE_A::NOTMASKED
            }
        }
        impl core::ops::Deref for ERRIE_R {
            type Target = crate::FieldReader<bool, ERRIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ERRIE` writer - Error interrupt enable
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ERRIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Error interrupt masked
            #[inline(always)]
            pub fn masked(self) -> &'a mut W {
                self.variant(ERRIE_A::MASKED)
            }
            ///Error interrupt not masked
            #[inline(always)]
            pub fn not_masked(self) -> &'a mut W {
                self.variant(ERRIE_A::NOTMASKED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///SS output enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SSOE_A {
            ///0: SS output is disabled in master mode
            DISABLED = 0,
            ///1: SS output is enabled in master mode
            ENABLED = 1,
        }
        impl From<SSOE_A> for bool {
            #[inline(always)]
            fn from(variant: SSOE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SSOE` reader - SS output enable
        pub struct SSOE_R(crate::FieldReader<bool, SSOE_A>);
        impl SSOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                SSOE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SSOE_A {
                match self.bits {
                    false => SSOE_A::DISABLED,
                    true => SSOE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SSOE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == SSOE_A::ENABLED
            }
        }
        impl core::ops::Deref for SSOE_R {
            type Target = crate::FieldReader<bool, SSOE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SSOE` writer - SS output enable
        pub struct SSOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SSOE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SSOE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///SS output is disabled in master mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SSOE_A::DISABLED)
            }
            ///SS output is enabled in master mode
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SSOE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Tx buffer DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXDMAEN_A {
            ///0: Tx buffer DMA disabled
            DISABLED = 0,
            ///1: Tx buffer DMA enabled
            ENABLED = 1,
        }
        impl From<TXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: TXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TXDMAEN` reader - Tx buffer DMA enable
        pub struct TXDMAEN_R(crate::FieldReader<bool, TXDMAEN_A>);
        impl TXDMAEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXDMAEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXDMAEN_A {
                match self.bits {
                    false => TXDMAEN_A::DISABLED,
                    true => TXDMAEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TXDMAEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TXDMAEN_A::ENABLED
            }
        }
        impl core::ops::Deref for TXDMAEN_R {
            type Target = crate::FieldReader<bool, TXDMAEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TXDMAEN` writer - Tx buffer DMA enable
        pub struct TXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXDMAEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TXDMAEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Tx buffer DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::DISABLED)
            }
            ///Tx buffer DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXDMAEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Rx buffer DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXDMAEN_A {
            ///0: Rx buffer DMA disabled
            DISABLED = 0,
            ///1: Rx buffer DMA enabled
            ENABLED = 1,
        }
        impl From<RXDMAEN_A> for bool {
            #[inline(always)]
            fn from(variant: RXDMAEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXDMAEN` reader - Rx buffer DMA enable
        pub struct RXDMAEN_R(crate::FieldReader<bool, RXDMAEN_A>);
        impl RXDMAEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXDMAEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXDMAEN_A {
                match self.bits {
                    false => RXDMAEN_A::DISABLED,
                    true => RXDMAEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RXDMAEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RXDMAEN_A::ENABLED
            }
        }
        impl core::ops::Deref for RXDMAEN_R {
            type Target = crate::FieldReader<bool, RXDMAEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXDMAEN` writer - Rx buffer DMA enable
        pub struct RXDMAEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXDMAEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RXDMAEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Rx buffer DMA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::DISABLED)
            }
            ///Rx buffer DMA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXDMAEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            pub fn ssoe(&self) -> SSOE_R {
                SSOE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            pub fn txdmaen(&self) -> TXDMAEN_R {
                TXDMAEN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            pub fn rxdmaen(&self) -> RXDMAEN_R {
                RXDMAEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 7 - Tx buffer empty interrupt enable
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            ///Bit 6 - RX buffer not empty interrupt enable
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            ///Bit 5 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            ///Bit 2 - SS output enable
            #[inline(always)]
            pub fn ssoe(&mut self) -> SSOE_W {
                SSOE_W { w: self }
            }
            ///Bit 1 - Tx buffer DMA enable
            #[inline(always)]
            pub fn txdmaen(&mut self) -> TXDMAEN_W {
                TXDMAEN_W { w: self }
            }
            ///Bit 0 - Rx buffer DMA enable
            #[inline(always)]
            pub fn rxdmaen(&mut self) -> RXDMAEN_W {
                RXDMAEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Busy flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BSY_A {
            ///0: SPI not busy
            NOTBUSY = 0,
            ///1: SPI busy
            BUSY = 1,
        }
        impl From<BSY_A> for bool {
            #[inline(always)]
            fn from(variant: BSY_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BSY` reader - Busy flag
        pub struct BSY_R(crate::FieldReader<bool, BSY_A>);
        impl BSY_R {
            pub(crate) fn new(bits: bool) -> Self {
                BSY_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BSY_A {
                match self.bits {
                    false => BSY_A::NOTBUSY,
                    true => BSY_A::BUSY,
                }
            }
            ///Checks if the value of the field is `NOTBUSY`
            #[inline(always)]
            pub fn is_not_busy(&self) -> bool {
                **self == BSY_A::NOTBUSY
            }
            ///Checks if the value of the field is `BUSY`
            #[inline(always)]
            pub fn is_busy(&self) -> bool {
                **self == BSY_A::BUSY
            }
        }
        impl core::ops::Deref for BSY_R {
            type Target = crate::FieldReader<bool, BSY_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Overrun flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OVR_A {
            ///0: No overrun occurred
            NOOVERRUN = 0,
            ///1: Overrun occurred
            OVERRUN = 1,
        }
        impl From<OVR_A> for bool {
            #[inline(always)]
            fn from(variant: OVR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OVR` reader - Overrun flag
        pub struct OVR_R(crate::FieldReader<bool, OVR_A>);
        impl OVR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OVR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OVR_A {
                match self.bits {
                    false => OVR_A::NOOVERRUN,
                    true => OVR_A::OVERRUN,
                }
            }
            ///Checks if the value of the field is `NOOVERRUN`
            #[inline(always)]
            pub fn is_no_overrun(&self) -> bool {
                **self == OVR_A::NOOVERRUN
            }
            ///Checks if the value of the field is `OVERRUN`
            #[inline(always)]
            pub fn is_overrun(&self) -> bool {
                **self == OVR_A::OVERRUN
            }
        }
        impl core::ops::Deref for OVR_R {
            type Target = crate::FieldReader<bool, OVR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Mode fault
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum MODF_A {
            ///0: No mode fault occurred
            NOFAULT = 0,
            ///1: Mode fault occurred
            FAULT = 1,
        }
        impl From<MODF_A> for bool {
            #[inline(always)]
            fn from(variant: MODF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `MODF` reader - Mode fault
        pub struct MODF_R(crate::FieldReader<bool, MODF_A>);
        impl MODF_R {
            pub(crate) fn new(bits: bool) -> Self {
                MODF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> MODF_A {
                match self.bits {
                    false => MODF_A::NOFAULT,
                    true => MODF_A::FAULT,
                }
            }
            ///Checks if the value of the field is `NOFAULT`
            #[inline(always)]
            pub fn is_no_fault(&self) -> bool {
                **self == MODF_A::NOFAULT
            }
            ///Checks if the value of the field is `FAULT`
            #[inline(always)]
            pub fn is_fault(&self) -> bool {
                **self == MODF_A::FAULT
            }
        }
        impl core::ops::Deref for MODF_R {
            type Target = crate::FieldReader<bool, MODF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///CRC error flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CRCERR_A {
            ///0: CRC value received matches the SPIx_RXCRCR value
            MATCH = 0,
            ///1: CRC value received does not match the SPIx_RXCRCR value
            NOMATCH = 1,
        }
        impl From<CRCERR_A> for bool {
            #[inline(always)]
            fn from(variant: CRCERR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CRCERR` reader - CRC error flag
        pub struct CRCERR_R(crate::FieldReader<bool, CRCERR_A>);
        impl CRCERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                CRCERR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CRCERR_A {
                match self.bits {
                    false => CRCERR_A::MATCH,
                    true => CRCERR_A::NOMATCH,
                }
            }
            ///Checks if the value of the field is `MATCH`
            #[inline(always)]
            pub fn is_match(&self) -> bool {
                **self == CRCERR_A::MATCH
            }
            ///Checks if the value of the field is `NOMATCH`
            #[inline(always)]
            pub fn is_no_match(&self) -> bool {
                **self == CRCERR_A::NOMATCH
            }
        }
        impl core::ops::Deref for CRCERR_R {
            type Target = crate::FieldReader<bool, CRCERR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CRCERR` writer - CRC error flag
        pub struct CRCERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCERR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CRCERR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CRC value received matches the SPIx_RXCRCR value
            #[inline(always)]
            pub fn match_(self) -> &'a mut W {
                self.variant(CRCERR_A::MATCH)
            }
            ///CRC value received does not match the SPIx_RXCRCR value
            #[inline(always)]
            pub fn no_match(self) -> &'a mut W {
                self.variant(CRCERR_A::NOMATCH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Transmit buffer empty
        ///
        ///Value on reset: 1
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXE_A {
            ///0: Tx buffer not empty
            NOTEMPTY = 0,
            ///1: Tx buffer empty
            EMPTY = 1,
        }
        impl From<TXE_A> for bool {
            #[inline(always)]
            fn from(variant: TXE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TXE` reader - Transmit buffer empty
        pub struct TXE_R(crate::FieldReader<bool, TXE_A>);
        impl TXE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXE_A {
                match self.bits {
                    false => TXE_A::NOTEMPTY,
                    true => TXE_A::EMPTY,
                }
            }
            ///Checks if the value of the field is `NOTEMPTY`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                **self == TXE_A::NOTEMPTY
            }
            ///Checks if the value of the field is `EMPTY`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                **self == TXE_A::EMPTY
            }
        }
        impl core::ops::Deref for TXE_R {
            type Target = crate::FieldReader<bool, TXE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Receive buffer not empty
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNE_A {
            ///0: Rx buffer empty
            EMPTY = 0,
            ///1: Rx buffer not empty
            NOTEMPTY = 1,
        }
        impl From<RXNE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXNE` reader - Receive buffer not empty
        pub struct RXNE_R(crate::FieldReader<bool, RXNE_A>);
        impl RXNE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNE_A {
                match self.bits {
                    false => RXNE_A::EMPTY,
                    true => RXNE_A::NOTEMPTY,
                }
            }
            ///Checks if the value of the field is `EMPTY`
            #[inline(always)]
            pub fn is_empty(&self) -> bool {
                **self == RXNE_A::EMPTY
            }
            ///Checks if the value of the field is `NOTEMPTY`
            #[inline(always)]
            pub fn is_not_empty(&self) -> bool {
                **self == RXNE_A::NOTEMPTY
            }
        }
        impl core::ops::Deref for RXNE_R {
            type Target = crate::FieldReader<bool, RXNE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 7 - Busy flag
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Overrun flag
            #[inline(always)]
            pub fn ovr(&self) -> OVR_R {
                OVR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Mode fault
            #[inline(always)]
            pub fn modf(&self) -> MODF_R {
                MODF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - CRC error flag
            #[inline(always)]
            pub fn crcerr(&self) -> CRCERR_R {
                CRCERR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 1 - Transmit buffer empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Receive buffer not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 4 - CRC error flag
            #[inline(always)]
            pub fn crcerr(&mut self) -> CRCERR_W {
                CRCERR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0x02
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x02
            }
        }
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - Data register
        pub struct DR_R(crate::FieldReader<u16, u16>);
        impl DR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DR` writer - Data register
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Data register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Data register
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CRCPR register accessor: an alias for `Reg<CRCPR_SPEC>`
    pub type CRCPR = crate::Reg<crcpr::CRCPR_SPEC>;
    ///CRC polynomial register
    pub mod crcpr {
        ///Register `CRCPR` reader
        pub struct R(crate::R<CRCPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CRCPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CRCPR_SPEC>> for R {
            fn from(reader: crate::R<CRCPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CRCPR` writer
        pub struct W(crate::W<CRCPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CRCPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CRCPR_SPEC>> for W {
            fn from(writer: crate::W<CRCPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CRCPOLY` reader - CRC polynomial register
        pub struct CRCPOLY_R(crate::FieldReader<u16, u16>);
        impl CRCPOLY_R {
            pub(crate) fn new(bits: u16) -> Self {
                CRCPOLY_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CRCPOLY_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CRCPOLY` writer - CRC polynomial register
        pub struct CRCPOLY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CRCPOLY_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            pub fn crcpoly(&self) -> CRCPOLY_R {
                CRCPOLY_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - CRC polynomial register
            #[inline(always)]
            pub fn crcpoly(&mut self) -> CRCPOLY_W {
                CRCPOLY_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CRC polynomial register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [crcpr](index.html) module
        pub struct CRCPR_SPEC;
        impl crate::RegisterSpec for CRCPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [crcpr::R](R) reader structure
        impl crate::Readable for CRCPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [crcpr::W](W) writer structure
        impl crate::Writable for CRCPR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CRCPR to value 0x07
        impl crate::Resettable for CRCPR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x07
            }
        }
    }
    ///RXCRCR register accessor: an alias for `Reg<RXCRCR_SPEC>`
    pub type RXCRCR = crate::Reg<rxcrcr::RXCRCR_SPEC>;
    ///RX CRC register
    pub mod rxcrcr {
        ///Register `RXCRCR` reader
        pub struct R(crate::R<RXCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RXCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RXCRCR_SPEC>> for R {
            fn from(reader: crate::R<RXCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RxCRC` reader - Rx CRC register
        pub struct RXCRC_R(crate::FieldReader<u16, u16>);
        impl RXCRC_R {
            pub(crate) fn new(bits: u16) -> Self {
                RXCRC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RXCRC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Rx CRC register
            #[inline(always)]
            pub fn rx_crc(&self) -> RXCRC_R {
                RXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///RX CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rxcrcr](index.html) module
        pub struct RXCRCR_SPEC;
        impl crate::RegisterSpec for RXCRCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rxcrcr::R](R) reader structure
        impl crate::Readable for RXCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RXCRCR to value 0
        impl crate::Resettable for RXCRCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///TXCRCR register accessor: an alias for `Reg<TXCRCR_SPEC>`
    pub type TXCRCR = crate::Reg<txcrcr::TXCRCR_SPEC>;
    ///TX CRC register
    pub mod txcrcr {
        ///Register `TXCRCR` reader
        pub struct R(crate::R<TXCRCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TXCRCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<TXCRCR_SPEC>> for R {
            fn from(reader: crate::R<TXCRCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `TxCRC` reader - Tx CRC register
        pub struct TXCRC_R(crate::FieldReader<u16, u16>);
        impl TXCRC_R {
            pub(crate) fn new(bits: u16) -> Self {
                TXCRC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TXCRC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Tx CRC register
            #[inline(always)]
            pub fn tx_crc(&self) -> TXCRC_R {
                TXCRC_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///TX CRC register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [txcrcr](index.html) module
        pub struct TXCRCR_SPEC;
        impl crate::RegisterSpec for TXCRCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [txcrcr::R](R) reader structure
        impl crate::Readable for TXCRCR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets TXCRCR to value 0
        impl crate::Resettable for TXCRCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Serial peripheral interface
pub struct SPI2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI2 {}
impl SPI2 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI2 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI2").finish()
    }
}
///Serial peripheral interface
pub struct SPI3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SPI3 {}
impl SPI3 {
    ///Pointer to the register block
    pub const PTR: *const spi1::RegisterBlock = 0x4000_3c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const spi1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SPI3 {
    type Target = spi1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SPI3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SPI3").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART1 {}
impl USART1 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4001_3800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART1 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART1").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub mod usart1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x04 - Data register
        pub dr: crate::Reg<dr::DR_SPEC>,
        ///0x08 - Baud rate register
        pub brr: crate::Reg<brr::BRR_SPEC>,
        ///0x0c - Control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x10 - Control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x14 - Control register 3
        pub cr3: crate::Reg<cr3::CR3_SPEC>,
        ///0x18 - Guard time and prescaler register
        pub gtpr: crate::Reg<gtpr::GTPR_SPEC>,
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///Status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CTS` reader - CTS flag
        pub struct CTS_R(crate::FieldReader<bool, bool>);
        impl CTS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CTS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CTS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CTS` writer - CTS flag
        pub struct CTS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `LBD` reader - LIN break detection flag
        pub struct LBD_R(crate::FieldReader<bool, bool>);
        impl LBD_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LBD_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBD` writer - LIN break detection flag
        pub struct LBD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBD_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `TXE` reader - Transmit data register empty
        pub struct TXE_R(crate::FieldReader<bool, bool>);
        impl TXE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TXE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TC` reader - Transmission complete
        pub struct TC_R(crate::FieldReader<bool, bool>);
        impl TC_R {
            pub(crate) fn new(bits: bool) -> Self {
                TC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TC_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TC` writer - Transmission complete
        pub struct TC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TC_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `RXNE` reader - Read data register not empty
        pub struct RXNE_R(crate::FieldReader<bool, bool>);
        impl RXNE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RXNE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNE` writer - Read data register not empty
        pub struct RXNE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `IDLE` reader - IDLE line detected
        pub struct IDLE_R(crate::FieldReader<bool, bool>);
        impl IDLE_R {
            pub(crate) fn new(bits: bool) -> Self {
                IDLE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IDLE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ORE` reader - Overrun error
        pub struct ORE_R(crate::FieldReader<bool, bool>);
        impl ORE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ORE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ORE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `NE` reader - Noise error flag
        pub struct NE_R(crate::FieldReader<bool, bool>);
        impl NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FE` reader - Framing error
        pub struct FE_R(crate::FieldReader<bool, bool>);
        impl FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PE` reader - Parity error
        pub struct PE_R(crate::FieldReader<bool, bool>);
        impl PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 9 - CTS flag
            #[inline(always)]
            pub fn cts(&self) -> CTS_R {
                CTS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Transmit data register empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - IDLE line detected
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Overrun error
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Noise error flag
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Framing error
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Parity error
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 9 - CTS flag
            #[inline(always)]
            pub fn cts(&mut self) -> CTS_W {
                CTS_W { w: self }
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&mut self) -> LBD_W {
                LBD_W { w: self }
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&mut self) -> TC_W {
                TC_W { w: self }
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&mut self) -> RXNE_W {
                RXNE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0xc0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xc0
            }
        }
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///Data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - Data value
        pub struct DR_R(crate::FieldReader<u16, u16>);
        impl DR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DR` writer - Data value
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | (value as u32 & 0x01ff);
                self.w
            }
        }
        impl R {
            ///Bits 0:8 - Data value
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - Data value
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BRR register accessor: an alias for `Reg<BRR_SPEC>`
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Baud rate register
    pub mod brr {
        ///Register `BRR` reader
        pub struct R(crate::R<BRR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BRR_SPEC>> for R {
            fn from(reader: crate::R<BRR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BRR` writer
        pub struct W(crate::W<BRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BRR_SPEC>> for W {
            fn from(writer: crate::W<BRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV_Mantissa` reader - mantissa of USARTDIV
        pub struct DIV_MANTISSA_R(crate::FieldReader<u16, u16>);
        impl DIV_MANTISSA_R {
            pub(crate) fn new(bits: u16) -> Self {
                DIV_MANTISSA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIV_MANTISSA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIV_Mantissa` writer - mantissa of USARTDIV
        pub struct DIV_MANTISSA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_MANTISSA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | ((value as u32 & 0x0fff) << 4);
                self.w
            }
        }
        ///Field `DIV_Fraction` reader - fraction of USARTDIV
        pub struct DIV_FRACTION_R(crate::FieldReader<u8, u8>);
        impl DIV_FRACTION_R {
            pub(crate) fn new(bits: u8) -> Self {
                DIV_FRACTION_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIV_FRACTION_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIV_Fraction` writer - fraction of USARTDIV
        pub struct DIV_FRACTION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_FRACTION_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl R {
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 4:15 - mantissa of USARTDIV
            #[inline(always)]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W {
                DIV_MANTISSA_W { w: self }
            }
            ///Bits 0:3 - fraction of USARTDIV
            #[inline(always)]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W {
                DIV_FRACTION_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Baud rate register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [brr](index.html) module
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [brr::R](R) reader structure
        impl crate::Readable for BRR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [brr::W](W) writer structure
        impl crate::Writable for BRR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///Control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///USART enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            ///0: USART prescaler and outputs disabled
            DISABLED = 0,
            ///1: USART enabled
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UE` reader - USART enable
        pub struct UE_R(crate::FieldReader<bool, UE_A>);
        impl UE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UE_A::ENABLED
            }
        }
        impl core::ops::Deref for UE_R {
            type Target = crate::FieldReader<bool, UE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UE` writer - USART enable
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///USART prescaler and outputs disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            ///USART enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Word length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M_A {
            ///0: 8 data bits
            M8 = 0,
            ///1: 9 data bits
            M9 = 1,
        }
        impl From<M_A> for bool {
            #[inline(always)]
            fn from(variant: M_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `M` reader - Word length
        pub struct M_R(crate::FieldReader<bool, M_A>);
        impl M_R {
            pub(crate) fn new(bits: bool) -> Self {
                M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> M_A {
                match self.bits {
                    false => M_A::M8,
                    true => M_A::M9,
                }
            }
            ///Checks if the value of the field is `M8`
            #[inline(always)]
            pub fn is_m8(&self) -> bool {
                **self == M_A::M8
            }
            ///Checks if the value of the field is `M9`
            #[inline(always)]
            pub fn is_m9(&self) -> bool {
                **self == M_A::M9
            }
        }
        impl core::ops::Deref for M_R {
            type Target = crate::FieldReader<bool, M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `M` writer - Word length
        pub struct M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: M_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///8 data bits
            #[inline(always)]
            pub fn m8(self) -> &'a mut W {
                self.variant(M_A::M8)
            }
            ///9 data bits
            #[inline(always)]
            pub fn m9(self) -> &'a mut W {
                self.variant(M_A::M9)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Wakeup method
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            ///0: USART wakeup on idle line
            IDLELINE = 0,
            ///1: USART wakeup on address mark
            ADDRESSMARK = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAKE` reader - Wakeup method
        pub struct WAKE_R(crate::FieldReader<bool, WAKE_A>);
        impl WAKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAKE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLELINE,
                    true => WAKE_A::ADDRESSMARK,
                }
            }
            ///Checks if the value of the field is `IDLELINE`
            #[inline(always)]
            pub fn is_idle_line(&self) -> bool {
                **self == WAKE_A::IDLELINE
            }
            ///Checks if the value of the field is `ADDRESSMARK`
            #[inline(always)]
            pub fn is_address_mark(&self) -> bool {
                **self == WAKE_A::ADDRESSMARK
            }
        }
        impl core::ops::Deref for WAKE_R {
            type Target = crate::FieldReader<bool, WAKE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAKE` writer - Wakeup method
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///USART wakeup on idle line
            #[inline(always)]
            pub fn idle_line(self) -> &'a mut W {
                self.variant(WAKE_A::IDLELINE)
            }
            ///USART wakeup on address mark
            #[inline(always)]
            pub fn address_mark(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESSMARK)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Parity control enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            ///0: Parity control disabled
            DISABLED = 0,
            ///1: Parity control enabled
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PCE` reader - Parity control enable
        pub struct PCE_R(crate::FieldReader<bool, PCE_A>);
        impl PCE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PCE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PCE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PCE_A::ENABLED
            }
        }
        impl core::ops::Deref for PCE_R {
            type Target = crate::FieldReader<bool, PCE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PCE` writer - Parity control enable
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Parity control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            ///Parity control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Parity selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            ///0: Even parity
            EVEN = 0,
            ///1: Odd parity
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PS` reader - Parity selection
        pub struct PS_R(crate::FieldReader<bool, PS_A>);
        impl PS_R {
            pub(crate) fn new(bits: bool) -> Self {
                PS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            ///Checks if the value of the field is `EVEN`
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                **self == PS_A::EVEN
            }
            ///Checks if the value of the field is `ODD`
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                **self == PS_A::ODD
            }
        }
        impl core::ops::Deref for PS_R {
            type Target = crate::FieldReader<bool, PS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PS` writer - Parity selection
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Even parity
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            ///Odd parity
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///PE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            ///0: PE interrupt disabled
            DISABLED = 0,
            ///1: PE interrupt enabled
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PEIE` reader - PE interrupt enable
        pub struct PEIE_R(crate::FieldReader<bool, PEIE_A>);
        impl PEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for PEIE_R {
            type Target = crate::FieldReader<bool, PEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PEIE` writer - PE interrupt enable
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///PE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            ///PE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///TXE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            ///0: TXE interrupt disabled
            DISABLED = 0,
            ///1: TXE interrupt enabled
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TXEIE` reader - TXE interrupt enable
        pub struct TXEIE_R(crate::FieldReader<bool, TXEIE_A>);
        impl TXEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TXEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TXEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TXEIE_R {
            type Target = crate::FieldReader<bool, TXEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TXEIE` writer - TXE interrupt enable
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TXE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            ///TXE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Transmission complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            ///0: TC interrupt disabled
            DISABLED = 0,
            ///1: TC interrupt enabled
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TCIE` reader - Transmission complete interrupt enable
        pub struct TCIE_R(crate::FieldReader<bool, TCIE_A>);
        impl TCIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TCIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TCIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TCIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TCIE_R {
            type Target = crate::FieldReader<bool, TCIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TCIE` writer - Transmission complete interrupt enable
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TC interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            ///TC interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///RXNE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            ///0: RXNE interrupt disabled
            DISABLED = 0,
            ///1: RXNE interrupt enabled
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXNEIE` reader - RXNE interrupt enable
        pub struct RXNEIE_R(crate::FieldReader<bool, RXNEIE_A>);
        impl RXNEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RXNEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RXNEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for RXNEIE_R {
            type Target = crate::FieldReader<bool, RXNEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNEIE` writer - RXNE interrupt enable
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RXNE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            ///RXNE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///IDLE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            ///0: IDLE interrupt disabled
            DISABLED = 0,
            ///1: IDLE interrupt enabled
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IDLEIE` reader - IDLE interrupt enable
        pub struct IDLEIE_R(crate::FieldReader<bool, IDLEIE_A>);
        impl IDLEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                IDLEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == IDLEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == IDLEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for IDLEIE_R {
            type Target = crate::FieldReader<bool, IDLEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IDLEIE` writer - IDLE interrupt enable
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///IDLE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            ///IDLE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Transmitter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            ///0: Transmitter disabled
            DISABLED = 0,
            ///1: Transmitter enabled
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TE` reader - Transmitter enable
        pub struct TE_R(crate::FieldReader<bool, TE_A>);
        impl TE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TE_A::ENABLED
            }
        }
        impl core::ops::Deref for TE_R {
            type Target = crate::FieldReader<bool, TE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TE` writer - Transmitter enable
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Transmitter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            ///Transmitter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Receiver enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            ///0: Receiver disabled
            DISABLED = 0,
            ///1: Receiver enabled
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RE` reader - Receiver enable
        pub struct RE_R(crate::FieldReader<bool, RE_A>);
        impl RE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RE_A::ENABLED
            }
        }
        impl core::ops::Deref for RE_R {
            type Target = crate::FieldReader<bool, RE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RE` writer - Receiver enable
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Receiver disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            ///Receiver enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Receiver wakeup
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWU_A {
            ///0: Receiver in active mode
            ACTIVE = 0,
            ///1: Receiver in mute mode
            MUTE = 1,
        }
        impl From<RWU_A> for bool {
            #[inline(always)]
            fn from(variant: RWU_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RWU` reader - Receiver wakeup
        pub struct RWU_R(crate::FieldReader<bool, RWU_A>);
        impl RWU_R {
            pub(crate) fn new(bits: bool) -> Self {
                RWU_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RWU_A {
                match self.bits {
                    false => RWU_A::ACTIVE,
                    true => RWU_A::MUTE,
                }
            }
            ///Checks if the value of the field is `ACTIVE`
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                **self == RWU_A::ACTIVE
            }
            ///Checks if the value of the field is `MUTE`
            #[inline(always)]
            pub fn is_mute(&self) -> bool {
                **self == RWU_A::MUTE
            }
        }
        impl core::ops::Deref for RWU_R {
            type Target = crate::FieldReader<bool, RWU_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RWU` writer - Receiver wakeup
        pub struct RWU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RWU_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RWU_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Receiver in active mode
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(RWU_A::ACTIVE)
            }
            ///Receiver in mute mode
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(RWU_A::MUTE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Send break
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBK_A {
            ///0: No break character is transmitted
            NOBREAK = 0,
            ///1: Break character transmitted
            BREAK = 1,
        }
        impl From<SBK_A> for bool {
            #[inline(always)]
            fn from(variant: SBK_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SBK` reader - Send break
        pub struct SBK_R(crate::FieldReader<bool, SBK_A>);
        impl SBK_R {
            pub(crate) fn new(bits: bool) -> Self {
                SBK_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SBK_A {
                match self.bits {
                    false => SBK_A::NOBREAK,
                    true => SBK_A::BREAK,
                }
            }
            ///Checks if the value of the field is `NOBREAK`
            #[inline(always)]
            pub fn is_no_break(&self) -> bool {
                **self == SBK_A::NOBREAK
            }
            ///Checks if the value of the field is `BREAK`
            #[inline(always)]
            pub fn is_break(&self) -> bool {
                **self == SBK_A::BREAK
            }
        }
        impl core::ops::Deref for SBK_R {
            type Target = crate::FieldReader<bool, SBK_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SBK` writer - Send break
        pub struct SBK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBK_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SBK_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No break character is transmitted
            #[inline(always)]
            pub fn no_break(self) -> &'a mut W {
                self.variant(SBK_A::NOBREAK)
            }
            ///Break character transmitted
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBK_A::BREAK)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&mut self) -> M_W {
                M_W { w: self }
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&mut self) -> RWU_W {
                RWU_W { w: self }
            }
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&mut self) -> SBK_W {
                SBK_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///Control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///LIN mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LINEN_A {
            ///0: LIN mode disabled
            DISABLED = 0,
            ///1: LIN mode enabled
            ENABLED = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LINEN` reader - LIN mode enable
        pub struct LINEN_R(crate::FieldReader<bool, LINEN_A>);
        impl LINEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                LINEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::DISABLED,
                    true => LINEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == LINEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == LINEN_A::ENABLED
            }
        }
        impl core::ops::Deref for LINEN_R {
            type Target = crate::FieldReader<bool, LINEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LINEN` writer - LIN mode enable
        pub struct LINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LINEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LIN mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::DISABLED)
            }
            ///LIN mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///STOP bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            ///0: 1 stop bit
            STOP1 = 0,
            ///1: 0.5 stop bits
            STOP0P5 = 1,
            ///2: 2 stop bits
            STOP2 = 2,
            ///3: 1.5 stop bits
            STOP1P5 = 3,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        ///Field `STOP` reader - STOP bits
        pub struct STOP_R(crate::FieldReader<u8, STOP_A>);
        impl STOP_R {
            pub(crate) fn new(bits: u8) -> Self {
                STOP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STOP_A {
                match self.bits {
                    0 => STOP_A::STOP1,
                    1 => STOP_A::STOP0P5,
                    2 => STOP_A::STOP2,
                    3 => STOP_A::STOP1P5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `STOP1`
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                **self == STOP_A::STOP1
            }
            ///Checks if the value of the field is `STOP0P5`
            #[inline(always)]
            pub fn is_stop0p5(&self) -> bool {
                **self == STOP_A::STOP0P5
            }
            ///Checks if the value of the field is `STOP2`
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                **self == STOP_A::STOP2
            }
            ///Checks if the value of the field is `STOP1P5`
            #[inline(always)]
            pub fn is_stop1p5(&self) -> bool {
                **self == STOP_A::STOP1P5
            }
        }
        impl core::ops::Deref for STOP_R {
            type Target = crate::FieldReader<u8, STOP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `STOP` writer - STOP bits
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1 stop bit
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            ///0.5 stop bits
            #[inline(always)]
            pub fn stop0p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP0P5)
            }
            ///2 stop bits
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            ///1.5 stop bits
            #[inline(always)]
            pub fn stop1p5(self) -> &'a mut W {
                self.variant(STOP_A::STOP1P5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///Clock enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CLKEN_A {
            ///0: CK pin disabled
            DISABLED = 0,
            ///1: CK pin enabled
            ENABLED = 1,
        }
        impl From<CLKEN_A> for bool {
            #[inline(always)]
            fn from(variant: CLKEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CLKEN` reader - Clock enable
        pub struct CLKEN_R(crate::FieldReader<bool, CLKEN_A>);
        impl CLKEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CLKEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CLKEN_A {
                match self.bits {
                    false => CLKEN_A::DISABLED,
                    true => CLKEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CLKEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CLKEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CLKEN_R {
            type Target = crate::FieldReader<bool, CLKEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CLKEN` writer - Clock enable
        pub struct CLKEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CLKEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CK pin disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CLKEN_A::DISABLED)
            }
            ///CK pin enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CLKEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Clock polarity
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPOL_A {
            ///0: Steady low value on CK pin outside transmission window
            LOW = 0,
            ///1: Steady high value on CK pin outside transmission window
            HIGH = 1,
        }
        impl From<CPOL_A> for bool {
            #[inline(always)]
            fn from(variant: CPOL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CPOL` reader - Clock polarity
        pub struct CPOL_R(crate::FieldReader<bool, CPOL_A>);
        impl CPOL_R {
            pub(crate) fn new(bits: bool) -> Self {
                CPOL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPOL_A {
                match self.bits {
                    false => CPOL_A::LOW,
                    true => CPOL_A::HIGH,
                }
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == CPOL_A::LOW
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == CPOL_A::HIGH
            }
        }
        impl core::ops::Deref for CPOL_R {
            type Target = crate::FieldReader<bool, CPOL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPOL` writer - Clock polarity
        pub struct CPOL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPOL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPOL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Steady low value on CK pin outside transmission window
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(CPOL_A::LOW)
            }
            ///Steady high value on CK pin outside transmission window
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(CPOL_A::HIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Clock phase
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CPHA_A {
            ///0: The first clock transition is the first data capture edge
            FIRST = 0,
            ///1: The second clock transition is the first data capture edge
            SECOND = 1,
        }
        impl From<CPHA_A> for bool {
            #[inline(always)]
            fn from(variant: CPHA_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CPHA` reader - Clock phase
        pub struct CPHA_R(crate::FieldReader<bool, CPHA_A>);
        impl CPHA_R {
            pub(crate) fn new(bits: bool) -> Self {
                CPHA_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CPHA_A {
                match self.bits {
                    false => CPHA_A::FIRST,
                    true => CPHA_A::SECOND,
                }
            }
            ///Checks if the value of the field is `FIRST`
            #[inline(always)]
            pub fn is_first(&self) -> bool {
                **self == CPHA_A::FIRST
            }
            ///Checks if the value of the field is `SECOND`
            #[inline(always)]
            pub fn is_second(&self) -> bool {
                **self == CPHA_A::SECOND
            }
        }
        impl core::ops::Deref for CPHA_R {
            type Target = crate::FieldReader<bool, CPHA_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CPHA` writer - Clock phase
        pub struct CPHA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CPHA_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CPHA_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///The first clock transition is the first data capture edge
            #[inline(always)]
            pub fn first(self) -> &'a mut W {
                self.variant(CPHA_A::FIRST)
            }
            ///The second clock transition is the first data capture edge
            #[inline(always)]
            pub fn second(self) -> &'a mut W {
                self.variant(CPHA_A::SECOND)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `LBCL` reader - Last bit clock pulse
        pub struct LBCL_R(crate::FieldReader<bool, bool>);
        impl LBCL_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBCL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LBCL_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBCL` writer - Last bit clock pulse
        pub struct LBCL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBCL_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///LIN break detection interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDIE_A {
            ///0: LIN break detection interrupt disabled
            DISABLED = 0,
            ///1: LIN break detection interrupt enabled
            ENABLED = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LBDIE` reader - LIN break detection interrupt enable
        pub struct LBDIE_R(crate::FieldReader<bool, LBDIE_A>);
        impl LBDIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBDIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::DISABLED,
                    true => LBDIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == LBDIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == LBDIE_A::ENABLED
            }
        }
        impl core::ops::Deref for LBDIE_R {
            type Target = crate::FieldReader<bool, LBDIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBDIE` writer - LIN break detection interrupt enable
        pub struct LBDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LBDIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LIN break detection interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::DISABLED)
            }
            ///LIN break detection interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///lin break detection length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDL_A {
            ///0: 10-bit break detection
            LBDL10 = 0,
            ///1: 11-bit break detection
            LBDL11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LBDL` reader - lin break detection length
        pub struct LBDL_R(crate::FieldReader<bool, LBDL_A>);
        impl LBDL_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBDL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::LBDL10,
                    true => LBDL_A::LBDL11,
                }
            }
            ///Checks if the value of the field is `LBDL10`
            #[inline(always)]
            pub fn is_lbdl10(&self) -> bool {
                **self == LBDL_A::LBDL10
            }
            ///Checks if the value of the field is `LBDL11`
            #[inline(always)]
            pub fn is_lbdl11(&self) -> bool {
                **self == LBDL_A::LBDL11
            }
        }
        impl core::ops::Deref for LBDL_R {
            type Target = crate::FieldReader<bool, LBDL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBDL` writer - lin break detection length
        pub struct LBDL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LBDL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///10-bit break detection
            #[inline(always)]
            pub fn lbdl10(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL10)
            }
            ///11-bit break detection
            #[inline(always)]
            pub fn lbdl11(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL11)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `ADD` reader - Address of the USART node
        pub struct ADD_R(crate::FieldReader<u8, u8>);
        impl ADD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADD` writer - Address of the USART node
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl R {
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            pub fn clken(&self) -> CLKEN_R {
                CLKEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            pub fn cpol(&self) -> CPOL_R {
                CPOL_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            pub fn cpha(&self) -> CPHA_R {
                CPHA_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            pub fn lbcl(&self) -> LBCL_R {
                LBCL_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&mut self) -> LINEN_W {
                LINEN_W { w: self }
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            ///Bit 11 - Clock enable
            #[inline(always)]
            pub fn clken(&mut self) -> CLKEN_W {
                CLKEN_W { w: self }
            }
            ///Bit 10 - Clock polarity
            #[inline(always)]
            pub fn cpol(&mut self) -> CPOL_W {
                CPOL_W { w: self }
            }
            ///Bit 9 - Clock phase
            #[inline(always)]
            pub fn cpha(&mut self) -> CPHA_W {
                CPHA_W { w: self }
            }
            ///Bit 8 - Last bit clock pulse
            #[inline(always)]
            pub fn lbcl(&mut self) -> LBCL_W {
                LBCL_W { w: self }
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&mut self) -> LBDIE_W {
                LBDIE_W { w: self }
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&mut self) -> LBDL_W {
                LBDL_W { w: self }
            }
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR3 register accessor: an alias for `Reg<CR3_SPEC>`
    pub type CR3 = crate::Reg<cr3::CR3_SPEC>;
    ///Control register 3
    pub mod cr3 {
        ///Register `CR3` reader
        pub struct R(crate::R<CR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR3_SPEC>> for R {
            fn from(reader: crate::R<CR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR3` writer
        pub struct W(crate::W<CR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR3_SPEC>> for W {
            fn from(writer: crate::W<CR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///CTS interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSIE_A {
            ///0: CTS interrupt disabled
            DISABLED = 0,
            ///1: CTS interrupt enabled
            ENABLED = 1,
        }
        impl From<CTSIE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTSIE` reader - CTS interrupt enable
        pub struct CTSIE_R(crate::FieldReader<bool, CTSIE_A>);
        impl CTSIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CTSIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTSIE_A {
                match self.bits {
                    false => CTSIE_A::DISABLED,
                    true => CTSIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CTSIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CTSIE_A::ENABLED
            }
        }
        impl core::ops::Deref for CTSIE_R {
            type Target = crate::FieldReader<bool, CTSIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CTSIE` writer - CTS interrupt enable
        pub struct CTSIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTSIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CTS interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSIE_A::DISABLED)
            }
            ///CTS interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///CTS enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CTSE_A {
            ///0: CTS hardware flow control disabled
            DISABLED = 0,
            ///1: CTS hardware flow control enabled
            ENABLED = 1,
        }
        impl From<CTSE_A> for bool {
            #[inline(always)]
            fn from(variant: CTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CTSE` reader - CTS enable
        pub struct CTSE_R(crate::FieldReader<bool, CTSE_A>);
        impl CTSE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CTSE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CTSE_A {
                match self.bits {
                    false => CTSE_A::DISABLED,
                    true => CTSE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CTSE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CTSE_A::ENABLED
            }
        }
        impl core::ops::Deref for CTSE_R {
            type Target = crate::FieldReader<bool, CTSE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CTSE` writer - CTS enable
        pub struct CTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CTSE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CTSE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CTS hardware flow control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CTSE_A::DISABLED)
            }
            ///CTS hardware flow control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CTSE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///RTS enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RTSE_A {
            ///0: RTS hardware flow control disabled
            DISABLED = 0,
            ///1: RTS hardware flow control enabled
            ENABLED = 1,
        }
        impl From<RTSE_A> for bool {
            #[inline(always)]
            fn from(variant: RTSE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RTSE` reader - RTS enable
        pub struct RTSE_R(crate::FieldReader<bool, RTSE_A>);
        impl RTSE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RTSE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RTSE_A {
                match self.bits {
                    false => RTSE_A::DISABLED,
                    true => RTSE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RTSE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RTSE_A::ENABLED
            }
        }
        impl core::ops::Deref for RTSE_R {
            type Target = crate::FieldReader<bool, RTSE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RTSE` writer - RTS enable
        pub struct RTSE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RTSE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RTSE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RTS hardware flow control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RTSE_A::DISABLED)
            }
            ///RTS hardware flow control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RTSE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///DMA enable transmitter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            ///0: DMA mode is disabled for transmission
            DISABLED = 0,
            ///1: DMA mode is enabled for transmission
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAT` reader - DMA enable transmitter
        pub struct DMAT_R(crate::FieldReader<bool, DMAT_A>);
        impl DMAT_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAT_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAT_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAT_R {
            type Target = crate::FieldReader<bool, DMAT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAT` writer - DMA enable transmitter
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA mode is disabled for transmission
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            ///DMA mode is enabled for transmission
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///DMA enable receiver
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            ///0: DMA mode is disabled for reception
            DISABLED = 0,
            ///1: DMA mode is enabled for reception
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAR` reader - DMA enable receiver
        pub struct DMAR_R(crate::FieldReader<bool, DMAR_A>);
        impl DMAR_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAR_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAR_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAR_R {
            type Target = crate::FieldReader<bool, DMAR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAR` writer - DMA enable receiver
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA mode is disabled for reception
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            ///DMA mode is enabled for reception
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Smartcard mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCEN_A {
            ///0: Smartcard mode disabled
            DISABLED = 0,
            ///1: Smartcard mode enabled
            ENABLED = 1,
        }
        impl From<SCEN_A> for bool {
            #[inline(always)]
            fn from(variant: SCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SCEN` reader - Smartcard mode enable
        pub struct SCEN_R(crate::FieldReader<bool, SCEN_A>);
        impl SCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                SCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SCEN_A {
                match self.bits {
                    false => SCEN_A::DISABLED,
                    true => SCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == SCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for SCEN_R {
            type Target = crate::FieldReader<bool, SCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SCEN` writer - Smartcard mode enable
        pub struct SCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Smartcard mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCEN_A::DISABLED)
            }
            ///Smartcard mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Smartcard NACK enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum NACK_A {
            ///0: NACK transmission in case of parity error is disabled
            DISABLED = 0,
            ///1: NACK transmission during parity error is enabled
            ENABLED = 1,
        }
        impl From<NACK_A> for bool {
            #[inline(always)]
            fn from(variant: NACK_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `NACK` reader - Smartcard NACK enable
        pub struct NACK_R(crate::FieldReader<bool, NACK_A>);
        impl NACK_R {
            pub(crate) fn new(bits: bool) -> Self {
                NACK_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> NACK_A {
                match self.bits {
                    false => NACK_A::DISABLED,
                    true => NACK_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == NACK_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == NACK_A::ENABLED
            }
        }
        impl core::ops::Deref for NACK_R {
            type Target = crate::FieldReader<bool, NACK_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `NACK` writer - Smartcard NACK enable
        pub struct NACK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> NACK_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: NACK_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///NACK transmission in case of parity error is disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(NACK_A::DISABLED)
            }
            ///NACK transmission during parity error is enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(NACK_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Half-duplex selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            ///0: Half duplex mode is not selected
            FULLDUPLEX = 0,
            ///1: Half duplex mode is selected
            HALFDUPLEX = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HDSEL` reader - Half-duplex selection
        pub struct HDSEL_R(crate::FieldReader<bool, HDSEL_A>);
        impl HDSEL_R {
            pub(crate) fn new(bits: bool) -> Self {
                HDSEL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::FULLDUPLEX,
                    true => HDSEL_A::HALFDUPLEX,
                }
            }
            ///Checks if the value of the field is `FULLDUPLEX`
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                **self == HDSEL_A::FULLDUPLEX
            }
            ///Checks if the value of the field is `HALFDUPLEX`
            #[inline(always)]
            pub fn is_half_duplex(&self) -> bool {
                **self == HDSEL_A::HALFDUPLEX
            }
        }
        impl core::ops::Deref for HDSEL_R {
            type Target = crate::FieldReader<bool, HDSEL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HDSEL` writer - Half-duplex selection
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Half duplex mode is not selected
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::FULLDUPLEX)
            }
            ///Half duplex mode is selected
            #[inline(always)]
            pub fn half_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::HALFDUPLEX)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///IrDA low-power
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRLP_A {
            ///0: Normal mode
            NORMAL = 0,
            ///1: Low-power mode
            LOWPOWER = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IRLP` reader - IrDA low-power
        pub struct IRLP_R(crate::FieldReader<bool, IRLP_A>);
        impl IRLP_R {
            pub(crate) fn new(bits: bool) -> Self {
                IRLP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::NORMAL,
                    true => IRLP_A::LOWPOWER,
                }
            }
            ///Checks if the value of the field is `NORMAL`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                **self == IRLP_A::NORMAL
            }
            ///Checks if the value of the field is `LOWPOWER`
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                **self == IRLP_A::LOWPOWER
            }
        }
        impl core::ops::Deref for IRLP_R {
            type Target = crate::FieldReader<bool, IRLP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IRLP` writer - IrDA low-power
        pub struct IRLP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IRLP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IRLP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Normal mode
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::NORMAL)
            }
            ///Low-power mode
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LOWPOWER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///IrDA mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IREN_A {
            ///0: IrDA disabled
            DISABLED = 0,
            ///1: IrDA enabled
            ENABLED = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IREN` reader - IrDA mode enable
        pub struct IREN_R(crate::FieldReader<bool, IREN_A>);
        impl IREN_R {
            pub(crate) fn new(bits: bool) -> Self {
                IREN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::DISABLED,
                    true => IREN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == IREN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == IREN_A::ENABLED
            }
        }
        impl core::ops::Deref for IREN_R {
            type Target = crate::FieldReader<bool, IREN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IREN` writer - IrDA mode enable
        pub struct IREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///IrDA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::DISABLED)
            }
            ///IrDA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            ///0: Error interrupt disabled
            DISABLED = 0,
            ///1: Error interrupt enabled
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EIE` reader - Error interrupt enable
        pub struct EIE_R(crate::FieldReader<bool, EIE_A>);
        impl EIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                EIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EIE_A::ENABLED
            }
        }
        impl core::ops::Deref for EIE_R {
            type Target = crate::FieldReader<bool, EIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EIE` writer - Error interrupt enable
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Error interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            ///Error interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            pub fn ctsie(&self) -> CTSIE_R {
                CTSIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            pub fn ctse(&self) -> CTSE_R {
                CTSE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            pub fn rtse(&self) -> RTSE_R {
                RTSE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            pub fn scen(&self) -> SCEN_R {
                SCEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            pub fn nack(&self) -> NACK_R {
                NACK_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 10 - CTS interrupt enable
            #[inline(always)]
            pub fn ctsie(&mut self) -> CTSIE_W {
                CTSIE_W { w: self }
            }
            ///Bit 9 - CTS enable
            #[inline(always)]
            pub fn ctse(&mut self) -> CTSE_W {
                CTSE_W { w: self }
            }
            ///Bit 8 - RTS enable
            #[inline(always)]
            pub fn rtse(&mut self) -> RTSE_W {
                RTSE_W { w: self }
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            ///Bit 5 - Smartcard mode enable
            #[inline(always)]
            pub fn scen(&mut self) -> SCEN_W {
                SCEN_W { w: self }
            }
            ///Bit 4 - Smartcard NACK enable
            #[inline(always)]
            pub fn nack(&mut self) -> NACK_W {
                NACK_W { w: self }
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&mut self) -> IRLP_W {
                IRLP_W { w: self }
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&mut self) -> IREN_W {
                IREN_W { w: self }
            }
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr3](index.html) module
        pub struct CR3_SPEC;
        impl crate::RegisterSpec for CR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr3::R](R) reader structure
        impl crate::Readable for CR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr3::W](W) writer structure
        impl crate::Writable for CR3_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR3 to value 0
        impl crate::Resettable for CR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///GTPR register accessor: an alias for `Reg<GTPR_SPEC>`
    pub type GTPR = crate::Reg<gtpr::GTPR_SPEC>;
    ///Guard time and prescaler register
    pub mod gtpr {
        ///Register `GTPR` reader
        pub struct R(crate::R<GTPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<GTPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<GTPR_SPEC>> for R {
            fn from(reader: crate::R<GTPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `GTPR` writer
        pub struct W(crate::W<GTPR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<GTPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<GTPR_SPEC>> for W {
            fn from(writer: crate::W<GTPR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `GT` reader - Guard time value
        pub struct GT_R(crate::FieldReader<u8, u8>);
        impl GT_R {
            pub(crate) fn new(bits: u8) -> Self {
                GT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for GT_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `GT` writer - Guard time value
        pub struct GT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> GT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | ((value as u32 & 0xff) << 8);
                self.w
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u8, u8>);
        impl PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            pub fn gt(&self) -> GT_R {
                GT_R::new(((self.bits >> 8) & 0xff) as u8)
            }
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 8:15 - Guard time value
            #[inline(always)]
            pub fn gt(&mut self) -> GT_W {
                GT_W { w: self }
            }
            ///Bits 0:7 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Guard time and prescaler register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [gtpr](index.html) module
        pub struct GTPR_SPEC;
        impl crate::RegisterSpec for GTPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [gtpr::R](R) reader structure
        impl crate::Readable for GTPR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [gtpr::W](W) writer structure
        impl crate::Writable for GTPR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets GTPR to value 0
        impl crate::Resettable for GTPR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART2 {}
impl USART2 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART2 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART2").finish()
    }
}
///Universal synchronous asynchronous receiver transmitter
pub struct USART3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for USART3 {}
impl USART3 {
    ///Pointer to the register block
    pub const PTR: *const usart1::RegisterBlock = 0x4000_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const usart1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for USART3 {
    type Target = usart1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for USART3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("USART3").finish()
    }
}
///Analog to digital converter
pub struct ADC1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for ADC1 {}
impl ADC1 {
    ///Pointer to the register block
    pub const PTR: *const adc1::RegisterBlock = 0x4001_2400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const adc1::RegisterBlock {
        Self::PTR
    }
}
impl Deref for ADC1 {
    type Target = adc1::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for ADC1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("ADC1").finish()
    }
}
///Analog to digital converter
pub mod adc1 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x04 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x08 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x0c - sample time register 1
        pub smpr1: crate::Reg<smpr1::SMPR1_SPEC>,
        ///0x10 - sample time register 2
        pub smpr2: crate::Reg<smpr2::SMPR2_SPEC>,
        ///0x14 - injected channel data offset register x
        pub jofr1: crate::Reg<jofr1::JOFR1_SPEC>,
        ///0x18 - injected channel data offset register x
        pub jofr2: crate::Reg<jofr2::JOFR2_SPEC>,
        ///0x1c - injected channel data offset register x
        pub jofr3: crate::Reg<jofr3::JOFR3_SPEC>,
        ///0x20 - injected channel data offset register x
        pub jofr4: crate::Reg<jofr4::JOFR4_SPEC>,
        ///0x24 - watchdog higher threshold register
        pub htr: crate::Reg<htr::HTR_SPEC>,
        ///0x28 - watchdog lower threshold register
        pub ltr: crate::Reg<ltr::LTR_SPEC>,
        ///0x2c - regular sequence register 1
        pub sqr1: crate::Reg<sqr1::SQR1_SPEC>,
        ///0x30 - regular sequence register 2
        pub sqr2: crate::Reg<sqr2::SQR2_SPEC>,
        ///0x34 - regular sequence register 3
        pub sqr3: crate::Reg<sqr3::SQR3_SPEC>,
        ///0x38 - injected sequence register
        pub jsqr: crate::Reg<jsqr::JSQR_SPEC>,
        ///0x3c - injected data register x
        pub jdr1: crate::Reg<jdr1::JDR1_SPEC>,
        ///0x40 - injected data register x
        pub jdr2: crate::Reg<jdr2::JDR2_SPEC>,
        ///0x44 - injected data register x
        pub jdr3: crate::Reg<jdr3::JDR3_SPEC>,
        ///0x48 - injected data register x
        pub jdr4: crate::Reg<jdr4::JDR4_SPEC>,
        ///0x4c - regular data register
        pub dr: crate::Reg<dr::DR_SPEC>,
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Regular channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STRT_A {
            ///0: No regular channel conversion started
            NOTSTARTED = 0,
            ///1: Regular channel conversion has started
            STARTED = 1,
        }
        impl From<STRT_A> for bool {
            #[inline(always)]
            fn from(variant: STRT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `STRT` reader - Regular channel start flag
        pub struct STRT_R(crate::FieldReader<bool, STRT_A>);
        impl STRT_R {
            pub(crate) fn new(bits: bool) -> Self {
                STRT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> STRT_A {
                match self.bits {
                    false => STRT_A::NOTSTARTED,
                    true => STRT_A::STARTED,
                }
            }
            ///Checks if the value of the field is `NOTSTARTED`
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                **self == STRT_A::NOTSTARTED
            }
            ///Checks if the value of the field is `STARTED`
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                **self == STRT_A::STARTED
            }
        }
        impl core::ops::Deref for STRT_R {
            type Target = crate::FieldReader<bool, STRT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Regular channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum STRT_AW {
            ///0: Clear the Regular channel Start flag
            CLEAR = 0,
        }
        impl From<STRT_AW> for bool {
            #[inline(always)]
            fn from(variant: STRT_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `STRT` writer - Regular channel start flag
        pub struct STRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STRT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: STRT_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear the Regular channel Start flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(STRT_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Injected channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSTRT_A {
            ///0: No injected group conversion started
            NOTSTARTED = 0,
            ///1: Injected group conversion has started
            STARTED = 1,
        }
        impl From<JSTRT_A> for bool {
            #[inline(always)]
            fn from(variant: JSTRT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JSTRT` reader - Injected channel start flag
        pub struct JSTRT_R(crate::FieldReader<bool, JSTRT_A>);
        impl JSTRT_R {
            pub(crate) fn new(bits: bool) -> Self {
                JSTRT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JSTRT_A {
                match self.bits {
                    false => JSTRT_A::NOTSTARTED,
                    true => JSTRT_A::STARTED,
                }
            }
            ///Checks if the value of the field is `NOTSTARTED`
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                **self == JSTRT_A::NOTSTARTED
            }
            ///Checks if the value of the field is `STARTED`
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                **self == JSTRT_A::STARTED
            }
        }
        impl core::ops::Deref for JSTRT_R {
            type Target = crate::FieldReader<bool, JSTRT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Injected channel start flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSTRT_AW {
            ///0: Clear Injected channel Start flag
            CLEAR = 0,
        }
        impl From<JSTRT_AW> for bool {
            #[inline(always)]
            fn from(variant: JSTRT_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JSTRT` writer - Injected channel start flag
        pub struct JSTRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSTRT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JSTRT_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear Injected channel Start flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(JSTRT_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Injected channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOC_A {
            ///0: Conversion is not complete
            NOTCOMPLETE = 0,
            ///1: Conversion complete
            COMPLETE = 1,
        }
        impl From<JEOC_A> for bool {
            #[inline(always)]
            fn from(variant: JEOC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JEOC` reader - Injected channel end of conversion
        pub struct JEOC_R(crate::FieldReader<bool, JEOC_A>);
        impl JEOC_R {
            pub(crate) fn new(bits: bool) -> Self {
                JEOC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JEOC_A {
                match self.bits {
                    false => JEOC_A::NOTCOMPLETE,
                    true => JEOC_A::COMPLETE,
                }
            }
            ///Checks if the value of the field is `NOTCOMPLETE`
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                **self == JEOC_A::NOTCOMPLETE
            }
            ///Checks if the value of the field is `COMPLETE`
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                **self == JEOC_A::COMPLETE
            }
        }
        impl core::ops::Deref for JEOC_R {
            type Target = crate::FieldReader<bool, JEOC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Injected channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOC_AW {
            ///0: Clear Injected channel end of conversion flag
            CLEAR = 0,
        }
        impl From<JEOC_AW> for bool {
            #[inline(always)]
            fn from(variant: JEOC_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JEOC` writer - Injected channel end of conversion
        pub struct JEOC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEOC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JEOC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear Injected channel end of conversion flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(JEOC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Regular channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_A {
            ///0: Conversion is not complete
            NOTCOMPLETE = 0,
            ///1: Conversion complete
            COMPLETE = 1,
        }
        impl From<EOC_A> for bool {
            #[inline(always)]
            fn from(variant: EOC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EOC` reader - Regular channel end of conversion
        pub struct EOC_R(crate::FieldReader<bool, EOC_A>);
        impl EOC_R {
            pub(crate) fn new(bits: bool) -> Self {
                EOC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EOC_A {
                match self.bits {
                    false => EOC_A::NOTCOMPLETE,
                    true => EOC_A::COMPLETE,
                }
            }
            ///Checks if the value of the field is `NOTCOMPLETE`
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                **self == EOC_A::NOTCOMPLETE
            }
            ///Checks if the value of the field is `COMPLETE`
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                **self == EOC_A::COMPLETE
            }
        }
        impl core::ops::Deref for EOC_R {
            type Target = crate::FieldReader<bool, EOC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Regular channel end of conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOC_AW {
            ///0: Clear End of conversion flag
            CLEAR = 0,
        }
        impl From<EOC_AW> for bool {
            #[inline(always)]
            fn from(variant: EOC_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EOC` writer - Regular channel end of conversion
        pub struct EOC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EOC_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear End of conversion flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(EOC_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Analog watchdog flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_A {
            ///0: No analog watchdog event occurred
            NOEVENT = 0,
            ///1: Analog watchdog event occurred
            EVENT = 1,
        }
        impl From<AWD_A> for bool {
            #[inline(always)]
            fn from(variant: AWD_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWD` reader - Analog watchdog flag
        pub struct AWD_R(crate::FieldReader<bool, AWD_A>);
        impl AWD_R {
            pub(crate) fn new(bits: bool) -> Self {
                AWD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWD_A {
                match self.bits {
                    false => AWD_A::NOEVENT,
                    true => AWD_A::EVENT,
                }
            }
            ///Checks if the value of the field is `NOEVENT`
            #[inline(always)]
            pub fn is_no_event(&self) -> bool {
                **self == AWD_A::NOEVENT
            }
            ///Checks if the value of the field is `EVENT`
            #[inline(always)]
            pub fn is_event(&self) -> bool {
                **self == AWD_A::EVENT
            }
        }
        impl core::ops::Deref for AWD_R {
            type Target = crate::FieldReader<bool, AWD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Analog watchdog flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWD_AW {
            ///0: Clear the analog watchdog event flag
            CLEAR = 0,
        }
        impl From<AWD_AW> for bool {
            #[inline(always)]
            fn from(variant: AWD_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWD` writer - Analog watchdog flag
        pub struct AWD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AWD_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Clear the analog watchdog event flag
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(AWD_AW::CLEAR)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            pub fn jstrt(&self) -> JSTRT_R {
                JSTRT_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            pub fn jeoc(&self) -> JEOC_R {
                JEOC_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            pub fn eoc(&self) -> EOC_R {
                EOC_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            pub fn awd(&self) -> AWD_R {
                AWD_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 4 - Regular channel start flag
            #[inline(always)]
            pub fn strt(&mut self) -> STRT_W {
                STRT_W { w: self }
            }
            ///Bit 3 - Injected channel start flag
            #[inline(always)]
            pub fn jstrt(&mut self) -> JSTRT_W {
                JSTRT_W { w: self }
            }
            ///Bit 2 - Injected channel end of conversion
            #[inline(always)]
            pub fn jeoc(&mut self) -> JEOC_W {
                JEOC_W { w: self }
            }
            ///Bit 1 - Regular channel end of conversion
            #[inline(always)]
            pub fn eoc(&mut self) -> EOC_W {
                EOC_W { w: self }
            }
            ///Bit 0 - Analog watchdog flag
            #[inline(always)]
            pub fn awd(&mut self) -> AWD_W {
                AWD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Analog watchdog enable on regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDEN_A {
            ///0: Analog watchdog disabled on regular channels
            DISABLED = 0,
            ///1: Analog watchdog enabled on regular channels
            ENABLED = 1,
        }
        impl From<AWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: AWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWDEN` reader - Analog watchdog enable on regular channels
        pub struct AWDEN_R(crate::FieldReader<bool, AWDEN_A>);
        impl AWDEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                AWDEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWDEN_A {
                match self.bits {
                    false => AWDEN_A::DISABLED,
                    true => AWDEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == AWDEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == AWDEN_A::ENABLED
            }
        }
        impl core::ops::Deref for AWDEN_R {
            type Target = crate::FieldReader<bool, AWDEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AWDEN` writer - Analog watchdog enable on regular channels
        pub struct AWDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AWDEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Analog watchdog disabled on regular channels
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDEN_A::DISABLED)
            }
            ///Analog watchdog enabled on regular channels
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        ///Analog watchdog enable on injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JAWDEN_A {
            ///0: Analog watchdog disabled on injected channels
            DISABLED = 0,
            ///1: Analog watchdog enabled on injected channels
            ENABLED = 1,
        }
        impl From<JAWDEN_A> for bool {
            #[inline(always)]
            fn from(variant: JAWDEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JAWDEN` reader - Analog watchdog enable on injected channels
        pub struct JAWDEN_R(crate::FieldReader<bool, JAWDEN_A>);
        impl JAWDEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                JAWDEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JAWDEN_A {
                match self.bits {
                    false => JAWDEN_A::DISABLED,
                    true => JAWDEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == JAWDEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == JAWDEN_A::ENABLED
            }
        }
        impl core::ops::Deref for JAWDEN_R {
            type Target = crate::FieldReader<bool, JAWDEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JAWDEN` writer - Analog watchdog enable on injected channels
        pub struct JAWDEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JAWDEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JAWDEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Analog watchdog disabled on injected channels
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JAWDEN_A::DISABLED)
            }
            ///Analog watchdog enabled on injected channels
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JAWDEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Field `DISCNUM` reader - Discontinuous mode channel count
        pub struct DISCNUM_R(crate::FieldReader<u8, u8>);
        impl DISCNUM_R {
            pub(crate) fn new(bits: u8) -> Self {
                DISCNUM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DISCNUM_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DISCNUM` writer - Discontinuous mode channel count
        pub struct DISCNUM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISCNUM_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 13)) | ((value as u32 & 0x07) << 13);
                self.w
            }
        }
        ///Discontinuous mode on injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JDISCEN_A {
            ///0: Discontinuous mode on injected channels disabled
            DISABLED = 0,
            ///1: Discontinuous mode on injected channels enabled
            ENABLED = 1,
        }
        impl From<JDISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: JDISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JDISCEN` reader - Discontinuous mode on injected channels
        pub struct JDISCEN_R(crate::FieldReader<bool, JDISCEN_A>);
        impl JDISCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                JDISCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JDISCEN_A {
                match self.bits {
                    false => JDISCEN_A::DISABLED,
                    true => JDISCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == JDISCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == JDISCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for JDISCEN_R {
            type Target = crate::FieldReader<bool, JDISCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JDISCEN` writer - Discontinuous mode on injected channels
        pub struct JDISCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JDISCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JDISCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Discontinuous mode on injected channels disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JDISCEN_A::DISABLED)
            }
            ///Discontinuous mode on injected channels enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JDISCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Discontinuous mode on regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DISCEN_A {
            ///0: Discontinuous mode on regular channels disabled
            DISABLED = 0,
            ///1: Discontinuous mode on regular channels enabled
            ENABLED = 1,
        }
        impl From<DISCEN_A> for bool {
            #[inline(always)]
            fn from(variant: DISCEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DISCEN` reader - Discontinuous mode on regular channels
        pub struct DISCEN_R(crate::FieldReader<bool, DISCEN_A>);
        impl DISCEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                DISCEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DISCEN_A {
                match self.bits {
                    false => DISCEN_A::DISABLED,
                    true => DISCEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DISCEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DISCEN_A::ENABLED
            }
        }
        impl core::ops::Deref for DISCEN_R {
            type Target = crate::FieldReader<bool, DISCEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DISCEN` writer - Discontinuous mode on regular channels
        pub struct DISCEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISCEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DISCEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Discontinuous mode on regular channels disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DISCEN_A::DISABLED)
            }
            ///Discontinuous mode on regular channels enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DISCEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Automatic injected group conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JAUTO_A {
            ///0: Automatic injected group conversion disabled
            DISABLED = 0,
            ///1: Automatic injected group conversion enabled
            ENABLED = 1,
        }
        impl From<JAUTO_A> for bool {
            #[inline(always)]
            fn from(variant: JAUTO_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JAUTO` reader - Automatic injected group conversion
        pub struct JAUTO_R(crate::FieldReader<bool, JAUTO_A>);
        impl JAUTO_R {
            pub(crate) fn new(bits: bool) -> Self {
                JAUTO_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JAUTO_A {
                match self.bits {
                    false => JAUTO_A::DISABLED,
                    true => JAUTO_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == JAUTO_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == JAUTO_A::ENABLED
            }
        }
        impl core::ops::Deref for JAUTO_R {
            type Target = crate::FieldReader<bool, JAUTO_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JAUTO` writer - Automatic injected group conversion
        pub struct JAUTO_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JAUTO_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JAUTO_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Automatic injected group conversion disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JAUTO_A::DISABLED)
            }
            ///Automatic injected group conversion enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JAUTO_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Enable the watchdog on a single channel in scan mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDSGL_A {
            ///0: Analog watchdog enabled on all channels
            ALL = 0,
            ///1: Analog watchdog enabled on a single channel
            SINGLE = 1,
        }
        impl From<AWDSGL_A> for bool {
            #[inline(always)]
            fn from(variant: AWDSGL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWDSGL` reader - Enable the watchdog on a single channel in scan mode
        pub struct AWDSGL_R(crate::FieldReader<bool, AWDSGL_A>);
        impl AWDSGL_R {
            pub(crate) fn new(bits: bool) -> Self {
                AWDSGL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWDSGL_A {
                match self.bits {
                    false => AWDSGL_A::ALL,
                    true => AWDSGL_A::SINGLE,
                }
            }
            ///Checks if the value of the field is `ALL`
            #[inline(always)]
            pub fn is_all(&self) -> bool {
                **self == AWDSGL_A::ALL
            }
            ///Checks if the value of the field is `SINGLE`
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                **self == AWDSGL_A::SINGLE
            }
        }
        impl core::ops::Deref for AWDSGL_R {
            type Target = crate::FieldReader<bool, AWDSGL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AWDSGL` writer - Enable the watchdog on a single channel in scan mode
        pub struct AWDSGL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDSGL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AWDSGL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Analog watchdog enabled on all channels
            #[inline(always)]
            pub fn all(self) -> &'a mut W {
                self.variant(AWDSGL_A::ALL)
            }
            ///Analog watchdog enabled on a single channel
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(AWDSGL_A::SINGLE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Scan mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SCAN_A {
            ///0: Scan mode disabled
            DISABLED = 0,
            ///1: Scan mode enabled
            ENABLED = 1,
        }
        impl From<SCAN_A> for bool {
            #[inline(always)]
            fn from(variant: SCAN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SCAN` reader - Scan mode
        pub struct SCAN_R(crate::FieldReader<bool, SCAN_A>);
        impl SCAN_R {
            pub(crate) fn new(bits: bool) -> Self {
                SCAN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SCAN_A {
                match self.bits {
                    false => SCAN_A::DISABLED,
                    true => SCAN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == SCAN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == SCAN_A::ENABLED
            }
        }
        impl core::ops::Deref for SCAN_R {
            type Target = crate::FieldReader<bool, SCAN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SCAN` writer - Scan mode
        pub struct SCAN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SCAN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SCAN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Scan mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SCAN_A::DISABLED)
            }
            ///Scan mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SCAN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Interrupt enable for injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEOCIE_A {
            ///0: JEOC interrupt disabled
            DISABLED = 0,
            ///1: JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set
            ENABLED = 1,
        }
        impl From<JEOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: JEOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JEOCIE` reader - Interrupt enable for injected channels
        pub struct JEOCIE_R(crate::FieldReader<bool, JEOCIE_A>);
        impl JEOCIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                JEOCIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JEOCIE_A {
                match self.bits {
                    false => JEOCIE_A::DISABLED,
                    true => JEOCIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == JEOCIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == JEOCIE_A::ENABLED
            }
        }
        impl core::ops::Deref for JEOCIE_R {
            type Target = crate::FieldReader<bool, JEOCIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JEOCIE` writer - Interrupt enable for injected channels
        pub struct JEOCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEOCIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JEOCIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///JEOC interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JEOCIE_A::DISABLED)
            }
            ///JEOC interrupt enabled. An interrupt is generated when the JEOC bit is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JEOCIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Analog watchdog interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum AWDIE_A {
            ///0: Analog watchdog interrupt disabled
            DISABLED = 0,
            ///1: Analog watchdog interrupt enabled
            ENABLED = 1,
        }
        impl From<AWDIE_A> for bool {
            #[inline(always)]
            fn from(variant: AWDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `AWDIE` reader - Analog watchdog interrupt enable
        pub struct AWDIE_R(crate::FieldReader<bool, AWDIE_A>);
        impl AWDIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                AWDIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> AWDIE_A {
                match self.bits {
                    false => AWDIE_A::DISABLED,
                    true => AWDIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == AWDIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == AWDIE_A::ENABLED
            }
        }
        impl core::ops::Deref for AWDIE_R {
            type Target = crate::FieldReader<bool, AWDIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AWDIE` writer - Analog watchdog interrupt enable
        pub struct AWDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: AWDIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Analog watchdog interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(AWDIE_A::DISABLED)
            }
            ///Analog watchdog interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(AWDIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Interrupt enable for EOC
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EOCIE_A {
            ///0: EOC interrupt disabled
            DISABLED = 0,
            ///1: EOC interrupt enabled. An interrupt is generated when the EOC bit is set
            ENABLED = 1,
        }
        impl From<EOCIE_A> for bool {
            #[inline(always)]
            fn from(variant: EOCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EOCIE` reader - Interrupt enable for EOC
        pub struct EOCIE_R(crate::FieldReader<bool, EOCIE_A>);
        impl EOCIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                EOCIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EOCIE_A {
                match self.bits {
                    false => EOCIE_A::DISABLED,
                    true => EOCIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EOCIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EOCIE_A::ENABLED
            }
        }
        impl core::ops::Deref for EOCIE_R {
            type Target = crate::FieldReader<bool, EOCIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EOCIE` writer - Interrupt enable for EOC
        pub struct EOCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOCIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EOCIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///EOC interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EOCIE_A::DISABLED)
            }
            ///EOC interrupt enabled. An interrupt is generated when the EOC bit is set
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EOCIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `AWDCH` reader - Analog watchdog channel select bits
        pub struct AWDCH_R(crate::FieldReader<u8, u8>);
        impl AWDCH_R {
            pub(crate) fn new(bits: u8) -> Self {
                AWDCH_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for AWDCH_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AWDCH` writer - Analog watchdog channel select bits
        pub struct AWDCH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AWDCH_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            pub fn awden(&self) -> AWDEN_R {
                AWDEN_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            pub fn jawden(&self) -> JAWDEN_R {
                JAWDEN_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            pub fn discnum(&self) -> DISCNUM_R {
                DISCNUM_R::new(((self.bits >> 13) & 0x07) as u8)
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            pub fn jdiscen(&self) -> JDISCEN_R {
                JDISCEN_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            pub fn discen(&self) -> DISCEN_R {
                DISCEN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            pub fn jauto(&self) -> JAUTO_R {
                JAUTO_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            pub fn awdsgl(&self) -> AWDSGL_R {
                AWDSGL_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Scan mode
            #[inline(always)]
            pub fn scan(&self) -> SCAN_R {
                SCAN_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            pub fn jeocie(&self) -> JEOCIE_R {
                JEOCIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            pub fn awdie(&self) -> AWDIE_R {
                AWDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            pub fn eocie(&self) -> EOCIE_R {
                EOCIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            pub fn awdch(&self) -> AWDCH_R {
                AWDCH_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bit 23 - Analog watchdog enable on regular channels
            #[inline(always)]
            pub fn awden(&mut self) -> AWDEN_W {
                AWDEN_W { w: self }
            }
            ///Bit 22 - Analog watchdog enable on injected channels
            #[inline(always)]
            pub fn jawden(&mut self) -> JAWDEN_W {
                JAWDEN_W { w: self }
            }
            ///Bits 13:15 - Discontinuous mode channel count
            #[inline(always)]
            pub fn discnum(&mut self) -> DISCNUM_W {
                DISCNUM_W { w: self }
            }
            ///Bit 12 - Discontinuous mode on injected channels
            #[inline(always)]
            pub fn jdiscen(&mut self) -> JDISCEN_W {
                JDISCEN_W { w: self }
            }
            ///Bit 11 - Discontinuous mode on regular channels
            #[inline(always)]
            pub fn discen(&mut self) -> DISCEN_W {
                DISCEN_W { w: self }
            }
            ///Bit 10 - Automatic injected group conversion
            #[inline(always)]
            pub fn jauto(&mut self) -> JAUTO_W {
                JAUTO_W { w: self }
            }
            ///Bit 9 - Enable the watchdog on a single channel in scan mode
            #[inline(always)]
            pub fn awdsgl(&mut self) -> AWDSGL_W {
                AWDSGL_W { w: self }
            }
            ///Bit 8 - Scan mode
            #[inline(always)]
            pub fn scan(&mut self) -> SCAN_W {
                SCAN_W { w: self }
            }
            ///Bit 7 - Interrupt enable for injected channels
            #[inline(always)]
            pub fn jeocie(&mut self) -> JEOCIE_W {
                JEOCIE_W { w: self }
            }
            ///Bit 6 - Analog watchdog interrupt enable
            #[inline(always)]
            pub fn awdie(&mut self) -> AWDIE_W {
                AWDIE_W { w: self }
            }
            ///Bit 5 - Interrupt enable for EOC
            #[inline(always)]
            pub fn eocie(&mut self) -> EOCIE_W {
                EOCIE_W { w: self }
            }
            ///Bits 0:4 - Analog watchdog channel select bits
            #[inline(always)]
            pub fn awdch(&mut self) -> AWDCH_W {
                AWDCH_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Temperature sensor and VREFINT enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TSVREFE_A {
            ///0: Temperature sensor and V_REFINT channel disabled
            DISABLED = 0,
            ///1: Temperature sensor and V_REFINT channel enabled
            ENABLED = 1,
        }
        impl From<TSVREFE_A> for bool {
            #[inline(always)]
            fn from(variant: TSVREFE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TSVREFE` reader - Temperature sensor and VREFINT enable
        pub struct TSVREFE_R(crate::FieldReader<bool, TSVREFE_A>);
        impl TSVREFE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TSVREFE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TSVREFE_A {
                match self.bits {
                    false => TSVREFE_A::DISABLED,
                    true => TSVREFE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TSVREFE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TSVREFE_A::ENABLED
            }
        }
        impl core::ops::Deref for TSVREFE_R {
            type Target = crate::FieldReader<bool, TSVREFE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TSVREFE` writer - Temperature sensor and VREFINT enable
        pub struct TSVREFE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSVREFE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TSVREFE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Temperature sensor and V_REFINT channel disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::DISABLED)
            }
            ///Temperature sensor and V_REFINT channel enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TSVREFE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        ///Start conversion of regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWSTART_A {
            ///0: Reset state
            STARTED = 0,
            ///1: Starting conversion of regular channels
            NOTSTARTED = 1,
        }
        impl From<SWSTART_A> for bool {
            #[inline(always)]
            fn from(variant: SWSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SWSTART` reader - Start conversion of regular channels
        pub struct SWSTART_R(crate::FieldReader<bool, SWSTART_A>);
        impl SWSTART_R {
            pub(crate) fn new(bits: bool) -> Self {
                SWSTART_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SWSTART_A {
                match self.bits {
                    false => SWSTART_A::STARTED,
                    true => SWSTART_A::NOTSTARTED,
                }
            }
            ///Checks if the value of the field is `STARTED`
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                **self == SWSTART_A::STARTED
            }
            ///Checks if the value of the field is `NOTSTARTED`
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                **self == SWSTART_A::NOTSTARTED
            }
        }
        impl core::ops::Deref for SWSTART_R {
            type Target = crate::FieldReader<bool, SWSTART_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Start conversion of regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWSTART_AW {
            ///1: Start conversion of regular channels
            START = 1,
        }
        impl From<SWSTART_AW> for bool {
            #[inline(always)]
            fn from(variant: SWSTART_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SWSTART` writer - Start conversion of regular channels
        pub struct SWSTART_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWSTART_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWSTART_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Start conversion of regular channels
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(SWSTART_AW::START)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Start conversion of injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSWSTART_A {
            ///0: Reset state
            STARTED = 0,
            ///1: Starting conversion of injected channels
            NOTSTARTED = 1,
        }
        impl From<JSWSTART_A> for bool {
            #[inline(always)]
            fn from(variant: JSWSTART_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JSWSTART` reader - Start conversion of injected channels
        pub struct JSWSTART_R(crate::FieldReader<bool, JSWSTART_A>);
        impl JSWSTART_R {
            pub(crate) fn new(bits: bool) -> Self {
                JSWSTART_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JSWSTART_A {
                match self.bits {
                    false => JSWSTART_A::STARTED,
                    true => JSWSTART_A::NOTSTARTED,
                }
            }
            ///Checks if the value of the field is `STARTED`
            #[inline(always)]
            pub fn is_started(&self) -> bool {
                **self == JSWSTART_A::STARTED
            }
            ///Checks if the value of the field is `NOTSTARTED`
            #[inline(always)]
            pub fn is_not_started(&self) -> bool {
                **self == JSWSTART_A::NOTSTARTED
            }
        }
        impl core::ops::Deref for JSWSTART_R {
            type Target = crate::FieldReader<bool, JSWSTART_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Start conversion of injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JSWSTART_AW {
            ///1: Start conversion of injected channels
            START = 1,
        }
        impl From<JSWSTART_AW> for bool {
            #[inline(always)]
            fn from(variant: JSWSTART_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JSWSTART` writer - Start conversion of injected channels
        pub struct JSWSTART_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSWSTART_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JSWSTART_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Start conversion of injected channels
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(JSWSTART_AW::START)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 21)) | ((value as u32 & 0x01) << 21);
                self.w
            }
        }
        ///External trigger conversion mode for regular channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EXTTRIG_A {
            ///0: Conversion on external event disabled
            DISABLED = 0,
            ///1: Conversion on external event enabled
            ENABLED = 1,
        }
        impl From<EXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: EXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EXTTRIG` reader - External trigger conversion mode for regular channels
        pub struct EXTTRIG_R(crate::FieldReader<bool, EXTTRIG_A>);
        impl EXTTRIG_R {
            pub(crate) fn new(bits: bool) -> Self {
                EXTTRIG_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EXTTRIG_A {
                match self.bits {
                    false => EXTTRIG_A::DISABLED,
                    true => EXTTRIG_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EXTTRIG_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EXTTRIG_A::ENABLED
            }
        }
        impl core::ops::Deref for EXTTRIG_R {
            type Target = crate::FieldReader<bool, EXTTRIG_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTTRIG` writer - External trigger conversion mode for regular channels
        pub struct EXTTRIG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTTRIG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EXTTRIG_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Conversion on external event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EXTTRIG_A::DISABLED)
            }
            ///Conversion on external event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EXTTRIG_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///External event select for regular group
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum EXTSEL_A {
            ///0: Timer 1 CC1 event
            TIM1CC1 = 0,
            ///1: Timer 1 CC2 event
            TIM1CC2 = 1,
            ///2: Timer 1 CC3 event
            TIM1CC3 = 2,
            ///3: Timer 2 CC2 event
            TIM2CC2 = 3,
            ///4: Timer 3 TRGO event
            TIM3TRGO = 4,
            ///5: Timer 4 CC4 event
            TIM4CC4 = 5,
            ///6: EXTI line 11/TIM8_TRGO event (TIM8_TRGO is available only in high-density and XL-density devices)
            EXTI11 = 6,
            ///7: SWSTART
            SWSTART = 7,
        }
        impl From<EXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: EXTSEL_A) -> Self {
                variant as _
            }
        }
        ///Field `EXTSEL` reader - External event select for regular group
        pub struct EXTSEL_R(crate::FieldReader<u8, EXTSEL_A>);
        impl EXTSEL_R {
            pub(crate) fn new(bits: u8) -> Self {
                EXTSEL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EXTSEL_A {
                match self.bits {
                    0 => EXTSEL_A::TIM1CC1,
                    1 => EXTSEL_A::TIM1CC2,
                    2 => EXTSEL_A::TIM1CC3,
                    3 => EXTSEL_A::TIM2CC2,
                    4 => EXTSEL_A::TIM3TRGO,
                    5 => EXTSEL_A::TIM4CC4,
                    6 => EXTSEL_A::EXTI11,
                    7 => EXTSEL_A::SWSTART,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `TIM1CC1`
            #[inline(always)]
            pub fn is_tim1cc1(&self) -> bool {
                **self == EXTSEL_A::TIM1CC1
            }
            ///Checks if the value of the field is `TIM1CC2`
            #[inline(always)]
            pub fn is_tim1cc2(&self) -> bool {
                **self == EXTSEL_A::TIM1CC2
            }
            ///Checks if the value of the field is `TIM1CC3`
            #[inline(always)]
            pub fn is_tim1cc3(&self) -> bool {
                **self == EXTSEL_A::TIM1CC3
            }
            ///Checks if the value of the field is `TIM2CC2`
            #[inline(always)]
            pub fn is_tim2cc2(&self) -> bool {
                **self == EXTSEL_A::TIM2CC2
            }
            ///Checks if the value of the field is `TIM3TRGO`
            #[inline(always)]
            pub fn is_tim3trgo(&self) -> bool {
                **self == EXTSEL_A::TIM3TRGO
            }
            ///Checks if the value of the field is `TIM4CC4`
            #[inline(always)]
            pub fn is_tim4cc4(&self) -> bool {
                **self == EXTSEL_A::TIM4CC4
            }
            ///Checks if the value of the field is `EXTI11`
            #[inline(always)]
            pub fn is_exti11(&self) -> bool {
                **self == EXTSEL_A::EXTI11
            }
            ///Checks if the value of the field is `SWSTART`
            #[inline(always)]
            pub fn is_swstart(&self) -> bool {
                **self == EXTSEL_A::SWSTART
            }
        }
        impl core::ops::Deref for EXTSEL_R {
            type Target = crate::FieldReader<u8, EXTSEL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EXTSEL` writer - External event select for regular group
        pub struct EXTSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EXTSEL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EXTSEL_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Timer 1 CC1 event
            #[inline(always)]
            pub fn tim1cc1(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC1)
            }
            ///Timer 1 CC2 event
            #[inline(always)]
            pub fn tim1cc2(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC2)
            }
            ///Timer 1 CC3 event
            #[inline(always)]
            pub fn tim1cc3(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM1CC3)
            }
            ///Timer 2 CC2 event
            #[inline(always)]
            pub fn tim2cc2(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM2CC2)
            }
            ///Timer 3 TRGO event
            #[inline(always)]
            pub fn tim3trgo(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM3TRGO)
            }
            ///Timer 4 CC4 event
            #[inline(always)]
            pub fn tim4cc4(self) -> &'a mut W {
                self.variant(EXTSEL_A::TIM4CC4)
            }
            ///EXTI line 11/TIM8_TRGO event (TIM8_TRGO is available only in high-density and XL-density devices)
            #[inline(always)]
            pub fn exti11(self) -> &'a mut W {
                self.variant(EXTSEL_A::EXTI11)
            }
            ///SWSTART
            #[inline(always)]
            pub fn swstart(self) -> &'a mut W {
                self.variant(EXTSEL_A::SWSTART)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 17)) | ((value as u32 & 0x07) << 17);
                self.w
            }
        }
        ///External trigger conversion mode for injected channels
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum JEXTTRIG_A {
            ///0: Conversion on external event disabled
            DISABLED = 0,
            ///1: Conversion on external event enabled
            ENABLED = 1,
        }
        impl From<JEXTTRIG_A> for bool {
            #[inline(always)]
            fn from(variant: JEXTTRIG_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `JEXTTRIG` reader - External trigger conversion mode for injected channels
        pub struct JEXTTRIG_R(crate::FieldReader<bool, JEXTTRIG_A>);
        impl JEXTTRIG_R {
            pub(crate) fn new(bits: bool) -> Self {
                JEXTTRIG_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JEXTTRIG_A {
                match self.bits {
                    false => JEXTTRIG_A::DISABLED,
                    true => JEXTTRIG_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == JEXTTRIG_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == JEXTTRIG_A::ENABLED
            }
        }
        impl core::ops::Deref for JEXTTRIG_R {
            type Target = crate::FieldReader<bool, JEXTTRIG_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JEXTTRIG` writer - External trigger conversion mode for injected channels
        pub struct JEXTTRIG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEXTTRIG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JEXTTRIG_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Conversion on external event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(JEXTTRIG_A::DISABLED)
            }
            ///Conversion on external event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(JEXTTRIG_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///External event select for injected group
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum JEXTSEL_A {
            ///0: Timer 1 TRGO event
            TIM1TRGO = 0,
            ///1: Timer 1 CC4 event
            TIM1CC4 = 1,
            ///2: Timer 2 TRGO event
            TIM2TRGO = 2,
            ///3: Timer 2 CC1 event
            TIM2CC1 = 3,
            ///4: Timer 3 CC4 event
            TIM3CC4 = 4,
            ///5: Timer 4 TRGO event
            TIM4TRGO = 5,
            ///6: EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in high-density and XL-density devices)
            EXTI15 = 6,
            ///7: JSWSTART
            JSWSTART = 7,
        }
        impl From<JEXTSEL_A> for u8 {
            #[inline(always)]
            fn from(variant: JEXTSEL_A) -> Self {
                variant as _
            }
        }
        ///Field `JEXTSEL` reader - External event select for injected group
        pub struct JEXTSEL_R(crate::FieldReader<u8, JEXTSEL_A>);
        impl JEXTSEL_R {
            pub(crate) fn new(bits: u8) -> Self {
                JEXTSEL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> JEXTSEL_A {
                match self.bits {
                    0 => JEXTSEL_A::TIM1TRGO,
                    1 => JEXTSEL_A::TIM1CC4,
                    2 => JEXTSEL_A::TIM2TRGO,
                    3 => JEXTSEL_A::TIM2CC1,
                    4 => JEXTSEL_A::TIM3CC4,
                    5 => JEXTSEL_A::TIM4TRGO,
                    6 => JEXTSEL_A::EXTI15,
                    7 => JEXTSEL_A::JSWSTART,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `TIM1TRGO`
            #[inline(always)]
            pub fn is_tim1trgo(&self) -> bool {
                **self == JEXTSEL_A::TIM1TRGO
            }
            ///Checks if the value of the field is `TIM1CC4`
            #[inline(always)]
            pub fn is_tim1cc4(&self) -> bool {
                **self == JEXTSEL_A::TIM1CC4
            }
            ///Checks if the value of the field is `TIM2TRGO`
            #[inline(always)]
            pub fn is_tim2trgo(&self) -> bool {
                **self == JEXTSEL_A::TIM2TRGO
            }
            ///Checks if the value of the field is `TIM2CC1`
            #[inline(always)]
            pub fn is_tim2cc1(&self) -> bool {
                **self == JEXTSEL_A::TIM2CC1
            }
            ///Checks if the value of the field is `TIM3CC4`
            #[inline(always)]
            pub fn is_tim3cc4(&self) -> bool {
                **self == JEXTSEL_A::TIM3CC4
            }
            ///Checks if the value of the field is `TIM4TRGO`
            #[inline(always)]
            pub fn is_tim4trgo(&self) -> bool {
                **self == JEXTSEL_A::TIM4TRGO
            }
            ///Checks if the value of the field is `EXTI15`
            #[inline(always)]
            pub fn is_exti15(&self) -> bool {
                **self == JEXTSEL_A::EXTI15
            }
            ///Checks if the value of the field is `JSWSTART`
            #[inline(always)]
            pub fn is_jswstart(&self) -> bool {
                **self == JEXTSEL_A::JSWSTART
            }
        }
        impl core::ops::Deref for JEXTSEL_R {
            type Target = crate::FieldReader<u8, JEXTSEL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JEXTSEL` writer - External event select for injected group
        pub struct JEXTSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JEXTSEL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: JEXTSEL_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Timer 1 TRGO event
            #[inline(always)]
            pub fn tim1trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM1TRGO)
            }
            ///Timer 1 CC4 event
            #[inline(always)]
            pub fn tim1cc4(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM1CC4)
            }
            ///Timer 2 TRGO event
            #[inline(always)]
            pub fn tim2trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM2TRGO)
            }
            ///Timer 2 CC1 event
            #[inline(always)]
            pub fn tim2cc1(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM2CC1)
            }
            ///Timer 3 CC4 event
            #[inline(always)]
            pub fn tim3cc4(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM3CC4)
            }
            ///Timer 4 TRGO event
            #[inline(always)]
            pub fn tim4trgo(self) -> &'a mut W {
                self.variant(JEXTSEL_A::TIM4TRGO)
            }
            ///EXTI line15/TIM8_CC4 event (TIM8_CC4 is available only in high-density and XL-density devices)
            #[inline(always)]
            pub fn exti15(self) -> &'a mut W {
                self.variant(JEXTSEL_A::EXTI15)
            }
            ///JSWSTART
            #[inline(always)]
            pub fn jswstart(self) -> &'a mut W {
                self.variant(JEXTSEL_A::JSWSTART)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Data alignment
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ALIGN_A {
            ///0: Right Alignment
            RIGHT = 0,
            ///1: Left Alignment
            LEFT = 1,
        }
        impl From<ALIGN_A> for bool {
            #[inline(always)]
            fn from(variant: ALIGN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ALIGN` reader - Data alignment
        pub struct ALIGN_R(crate::FieldReader<bool, ALIGN_A>);
        impl ALIGN_R {
            pub(crate) fn new(bits: bool) -> Self {
                ALIGN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ALIGN_A {
                match self.bits {
                    false => ALIGN_A::RIGHT,
                    true => ALIGN_A::LEFT,
                }
            }
            ///Checks if the value of the field is `RIGHT`
            #[inline(always)]
            pub fn is_right(&self) -> bool {
                **self == ALIGN_A::RIGHT
            }
            ///Checks if the value of the field is `LEFT`
            #[inline(always)]
            pub fn is_left(&self) -> bool {
                **self == ALIGN_A::LEFT
            }
        }
        impl core::ops::Deref for ALIGN_R {
            type Target = crate::FieldReader<bool, ALIGN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ALIGN` writer - Data alignment
        pub struct ALIGN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ALIGN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ALIGN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Right Alignment
            #[inline(always)]
            pub fn right(self) -> &'a mut W {
                self.variant(ALIGN_A::RIGHT)
            }
            ///Left Alignment
            #[inline(always)]
            pub fn left(self) -> &'a mut W {
                self.variant(ALIGN_A::LEFT)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Direct memory access mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMA_A {
            ///0: DMA mode disabled
            DISABLED = 0,
            ///1: DMA mode enabled
            ENABLED = 1,
        }
        impl From<DMA_A> for bool {
            #[inline(always)]
            fn from(variant: DMA_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMA` reader - Direct memory access mode
        pub struct DMA_R(crate::FieldReader<bool, DMA_A>);
        impl DMA_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMA_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMA_A {
                match self.bits {
                    false => DMA_A::DISABLED,
                    true => DMA_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMA_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMA_A::ENABLED
            }
        }
        impl core::ops::Deref for DMA_R {
            type Target = crate::FieldReader<bool, DMA_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMA` writer - Direct memory access mode
        pub struct DMA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMA_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMA_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMA_A::DISABLED)
            }
            ///DMA mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMA_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Reset calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSTCAL_A {
            ///0: Calibration register initialized
            INITIALIZED = 0,
            ///1: Initializing calibration register
            NOTINITIALIZED = 1,
        }
        impl From<RSTCAL_A> for bool {
            #[inline(always)]
            fn from(variant: RSTCAL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RSTCAL` reader - Reset calibration
        pub struct RSTCAL_R(crate::FieldReader<bool, RSTCAL_A>);
        impl RSTCAL_R {
            pub(crate) fn new(bits: bool) -> Self {
                RSTCAL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RSTCAL_A {
                match self.bits {
                    false => RSTCAL_A::INITIALIZED,
                    true => RSTCAL_A::NOTINITIALIZED,
                }
            }
            ///Checks if the value of the field is `INITIALIZED`
            #[inline(always)]
            pub fn is_initialized(&self) -> bool {
                **self == RSTCAL_A::INITIALIZED
            }
            ///Checks if the value of the field is `NOTINITIALIZED`
            #[inline(always)]
            pub fn is_not_initialized(&self) -> bool {
                **self == RSTCAL_A::NOTINITIALIZED
            }
        }
        impl core::ops::Deref for RSTCAL_R {
            type Target = crate::FieldReader<bool, RSTCAL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Reset calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RSTCAL_AW {
            ///1: Initialize calibration register
            INITIALIZE = 1,
        }
        impl From<RSTCAL_AW> for bool {
            #[inline(always)]
            fn from(variant: RSTCAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RSTCAL` writer - Reset calibration
        pub struct RSTCAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSTCAL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RSTCAL_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Initialize calibration register
            #[inline(always)]
            pub fn initialize(self) -> &'a mut W {
                self.variant(RSTCAL_AW::INITIALIZE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///A/D calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAL_A {
            ///0: Calibration completed
            COMPLETE = 0,
            ///1: Calibrating
            NOTCOMPLETE = 1,
        }
        impl From<CAL_A> for bool {
            #[inline(always)]
            fn from(variant: CAL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CAL` reader - A/D calibration
        pub struct CAL_R(crate::FieldReader<bool, CAL_A>);
        impl CAL_R {
            pub(crate) fn new(bits: bool) -> Self {
                CAL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CAL_A {
                match self.bits {
                    false => CAL_A::COMPLETE,
                    true => CAL_A::NOTCOMPLETE,
                }
            }
            ///Checks if the value of the field is `COMPLETE`
            #[inline(always)]
            pub fn is_complete(&self) -> bool {
                **self == CAL_A::COMPLETE
            }
            ///Checks if the value of the field is `NOTCOMPLETE`
            #[inline(always)]
            pub fn is_not_complete(&self) -> bool {
                **self == CAL_A::NOTCOMPLETE
            }
        }
        impl core::ops::Deref for CAL_R {
            type Target = crate::FieldReader<bool, CAL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///A/D calibration
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CAL_AW {
            ///1: Enable calibration
            START = 1,
        }
        impl From<CAL_AW> for bool {
            #[inline(always)]
            fn from(variant: CAL_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CAL` writer - A/D calibration
        pub struct CAL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CAL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CAL_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Enable calibration
            #[inline(always)]
            pub fn start(self) -> &'a mut W {
                self.variant(CAL_AW::START)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Continuous conversion
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CONT_A {
            ///0: Single conversion mode
            SINGLE = 0,
            ///1: Continuous conversion mode
            CONTINUOUS = 1,
        }
        impl From<CONT_A> for bool {
            #[inline(always)]
            fn from(variant: CONT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CONT` reader - Continuous conversion
        pub struct CONT_R(crate::FieldReader<bool, CONT_A>);
        impl CONT_R {
            pub(crate) fn new(bits: bool) -> Self {
                CONT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CONT_A {
                match self.bits {
                    false => CONT_A::SINGLE,
                    true => CONT_A::CONTINUOUS,
                }
            }
            ///Checks if the value of the field is `SINGLE`
            #[inline(always)]
            pub fn is_single(&self) -> bool {
                **self == CONT_A::SINGLE
            }
            ///Checks if the value of the field is `CONTINUOUS`
            #[inline(always)]
            pub fn is_continuous(&self) -> bool {
                **self == CONT_A::CONTINUOUS
            }
        }
        impl core::ops::Deref for CONT_R {
            type Target = crate::FieldReader<bool, CONT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CONT` writer - Continuous conversion
        pub struct CONT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CONT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CONT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Single conversion mode
            #[inline(always)]
            pub fn single(self) -> &'a mut W {
                self.variant(CONT_A::SINGLE)
            }
            ///Continuous conversion mode
            #[inline(always)]
            pub fn continuous(self) -> &'a mut W {
                self.variant(CONT_A::CONTINUOUS)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///A/D converter ON / OFF
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ADON_A {
            ///0: Disable ADC conversion/calibration and go to power down mode
            DISABLED = 0,
            ///1: Enable ADC and to start conversion
            ENABLED = 1,
        }
        impl From<ADON_A> for bool {
            #[inline(always)]
            fn from(variant: ADON_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ADON` reader - A/D converter ON / OFF
        pub struct ADON_R(crate::FieldReader<bool, ADON_A>);
        impl ADON_R {
            pub(crate) fn new(bits: bool) -> Self {
                ADON_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ADON_A {
                match self.bits {
                    false => ADON_A::DISABLED,
                    true => ADON_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ADON_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ADON_A::ENABLED
            }
        }
        impl core::ops::Deref for ADON_R {
            type Target = crate::FieldReader<bool, ADON_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADON` writer - A/D converter ON / OFF
        pub struct ADON_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADON_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ADON_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Disable ADC conversion/calibration and go to power down mode
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ADON_A::DISABLED)
            }
            ///Enable ADC and to start conversion
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ADON_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            pub fn tsvrefe(&self) -> TSVREFE_R {
                TSVREFE_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            pub fn swstart(&self) -> SWSTART_R {
                SWSTART_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            pub fn jswstart(&self) -> JSWSTART_R {
                JSWSTART_R::new(((self.bits >> 21) & 0x01) != 0)
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            pub fn exttrig(&self) -> EXTTRIG_R {
                EXTTRIG_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            pub fn extsel(&self) -> EXTSEL_R {
                EXTSEL_R::new(((self.bits >> 17) & 0x07) as u8)
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            pub fn jexttrig(&self) -> JEXTTRIG_R {
                JEXTTRIG_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            pub fn jextsel(&self) -> JEXTSEL_R {
                JEXTSEL_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            pub fn align(&self) -> ALIGN_R {
                ALIGN_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            pub fn dma(&self) -> DMA_R {
                DMA_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            pub fn rstcal(&self) -> RSTCAL_R {
                RSTCAL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            pub fn cal(&self) -> CAL_R {
                CAL_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            pub fn cont(&self) -> CONT_R {
                CONT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            pub fn adon(&self) -> ADON_R {
                ADON_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 23 - Temperature sensor and VREFINT enable
            #[inline(always)]
            pub fn tsvrefe(&mut self) -> TSVREFE_W {
                TSVREFE_W { w: self }
            }
            ///Bit 22 - Start conversion of regular channels
            #[inline(always)]
            pub fn swstart(&mut self) -> SWSTART_W {
                SWSTART_W { w: self }
            }
            ///Bit 21 - Start conversion of injected channels
            #[inline(always)]
            pub fn jswstart(&mut self) -> JSWSTART_W {
                JSWSTART_W { w: self }
            }
            ///Bit 20 - External trigger conversion mode for regular channels
            #[inline(always)]
            pub fn exttrig(&mut self) -> EXTTRIG_W {
                EXTTRIG_W { w: self }
            }
            ///Bits 17:19 - External event select for regular group
            #[inline(always)]
            pub fn extsel(&mut self) -> EXTSEL_W {
                EXTSEL_W { w: self }
            }
            ///Bit 15 - External trigger conversion mode for injected channels
            #[inline(always)]
            pub fn jexttrig(&mut self) -> JEXTTRIG_W {
                JEXTTRIG_W { w: self }
            }
            ///Bits 12:14 - External event select for injected group
            #[inline(always)]
            pub fn jextsel(&mut self) -> JEXTSEL_W {
                JEXTSEL_W { w: self }
            }
            ///Bit 11 - Data alignment
            #[inline(always)]
            pub fn align(&mut self) -> ALIGN_W {
                ALIGN_W { w: self }
            }
            ///Bit 8 - Direct memory access mode
            #[inline(always)]
            pub fn dma(&mut self) -> DMA_W {
                DMA_W { w: self }
            }
            ///Bit 3 - Reset calibration
            #[inline(always)]
            pub fn rstcal(&mut self) -> RSTCAL_W {
                RSTCAL_W { w: self }
            }
            ///Bit 2 - A/D calibration
            #[inline(always)]
            pub fn cal(&mut self) -> CAL_W {
                CAL_W { w: self }
            }
            ///Bit 1 - Continuous conversion
            #[inline(always)]
            pub fn cont(&mut self) -> CONT_W {
                CONT_W { w: self }
            }
            ///Bit 0 - A/D converter ON / OFF
            #[inline(always)]
            pub fn adon(&mut self) -> ADON_W {
                ADON_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMPR1 register accessor: an alias for `Reg<SMPR1_SPEC>`
    pub type SMPR1 = crate::Reg<smpr1::SMPR1_SPEC>;
    ///sample time register 1
    pub mod smpr1 {
        ///Register `SMPR1` reader
        pub struct R(crate::R<SMPR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMPR1_SPEC>> for R {
            fn from(reader: crate::R<SMPR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMPR1` writer
        pub struct W(crate::W<SMPR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMPR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMPR1_SPEC>> for W {
            fn from(writer: crate::W<SMPR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Channel 10 sample time selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMP10_A {
            ///0: 1.5 ADC clock cycles
            CYCLES1_5 = 0,
            ///1: 7.5 ADC clock cycles
            CYCLES7_5 = 1,
            ///2: 13.5 ADC clock cycles
            CYCLES13_5 = 2,
            ///3: 28.5 ADC clock cycles
            CYCLES28_5 = 3,
            ///4: 41.5 ADC clock cycles
            CYCLES41_5 = 4,
            ///5: 55.5 ADC clock cycles
            CYCLES55_5 = 5,
            ///6: 71.5 ADC clock cycles
            CYCLES71_5 = 6,
            ///7: 239.5 ADC clock cycles
            CYCLES239_5 = 7,
        }
        impl From<SMP10_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP10_A) -> Self {
                variant as _
            }
        }
        ///Field `SMP10` reader - Channel 10 sample time selection
        pub struct SMP10_R(crate::FieldReader<u8, SMP10_A>);
        impl SMP10_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMP10_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMP10_A {
                match self.bits {
                    0 => SMP10_A::CYCLES1_5,
                    1 => SMP10_A::CYCLES7_5,
                    2 => SMP10_A::CYCLES13_5,
                    3 => SMP10_A::CYCLES28_5,
                    4 => SMP10_A::CYCLES41_5,
                    5 => SMP10_A::CYCLES55_5,
                    6 => SMP10_A::CYCLES71_5,
                    7 => SMP10_A::CYCLES239_5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `CYCLES1_5`
            #[inline(always)]
            pub fn is_cycles1_5(&self) -> bool {
                **self == SMP10_A::CYCLES1_5
            }
            ///Checks if the value of the field is `CYCLES7_5`
            #[inline(always)]
            pub fn is_cycles7_5(&self) -> bool {
                **self == SMP10_A::CYCLES7_5
            }
            ///Checks if the value of the field is `CYCLES13_5`
            #[inline(always)]
            pub fn is_cycles13_5(&self) -> bool {
                **self == SMP10_A::CYCLES13_5
            }
            ///Checks if the value of the field is `CYCLES28_5`
            #[inline(always)]
            pub fn is_cycles28_5(&self) -> bool {
                **self == SMP10_A::CYCLES28_5
            }
            ///Checks if the value of the field is `CYCLES41_5`
            #[inline(always)]
            pub fn is_cycles41_5(&self) -> bool {
                **self == SMP10_A::CYCLES41_5
            }
            ///Checks if the value of the field is `CYCLES55_5`
            #[inline(always)]
            pub fn is_cycles55_5(&self) -> bool {
                **self == SMP10_A::CYCLES55_5
            }
            ///Checks if the value of the field is `CYCLES71_5`
            #[inline(always)]
            pub fn is_cycles71_5(&self) -> bool {
                **self == SMP10_A::CYCLES71_5
            }
            ///Checks if the value of the field is `CYCLES239_5`
            #[inline(always)]
            pub fn is_cycles239_5(&self) -> bool {
                **self == SMP10_A::CYCLES239_5
            }
        }
        impl core::ops::Deref for SMP10_R {
            type Target = crate::FieldReader<u8, SMP10_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMP10` writer - Channel 10 sample time selection
        pub struct SMP10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP10_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP10_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP10_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        ///Channel 11 sample time selection
        pub type SMP11_A = SMP10_A;
        ///Field `SMP11` reader - Channel 11 sample time selection
        pub type SMP11_R = SMP10_R;
        ///Field `SMP11` writer - Channel 11 sample time selection
        pub struct SMP11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP11_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP11_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP11_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | ((value as u32 & 0x07) << 3);
                self.w
            }
        }
        ///Channel 12 sample time selection
        pub type SMP12_A = SMP10_A;
        ///Field `SMP12` reader - Channel 12 sample time selection
        pub type SMP12_R = SMP10_R;
        ///Field `SMP12` writer - Channel 12 sample time selection
        pub struct SMP12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP12_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP12_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP12_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | ((value as u32 & 0x07) << 6);
                self.w
            }
        }
        ///Channel 13 sample time selection
        pub type SMP13_A = SMP10_A;
        ///Field `SMP13` reader - Channel 13 sample time selection
        pub type SMP13_R = SMP10_R;
        ///Field `SMP13` writer - Channel 13 sample time selection
        pub struct SMP13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP13_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP13_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP13_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | ((value as u32 & 0x07) << 9);
                self.w
            }
        }
        ///Channel 14 sample time selection
        pub type SMP14_A = SMP10_A;
        ///Field `SMP14` reader - Channel 14 sample time selection
        pub type SMP14_R = SMP10_R;
        ///Field `SMP14` writer - Channel 14 sample time selection
        pub struct SMP14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP14_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP14_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP14_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Channel 15 sample time selection
        pub type SMP15_A = SMP10_A;
        ///Field `SMP15` reader - Channel 15 sample time selection
        pub type SMP15_R = SMP10_R;
        ///Field `SMP15` writer - Channel 15 sample time selection
        pub struct SMP15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP15_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP15_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP15_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 15)) | ((value as u32 & 0x07) << 15);
                self.w
            }
        }
        ///Channel 16 sample time selection
        pub type SMP16_A = SMP10_A;
        ///Field `SMP16` reader - Channel 16 sample time selection
        pub type SMP16_R = SMP10_R;
        ///Field `SMP16` writer - Channel 16 sample time selection
        pub struct SMP16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP16_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP16_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP16_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 18)) | ((value as u32 & 0x07) << 18);
                self.w
            }
        }
        ///Channel 17 sample time selection
        pub type SMP17_A = SMP10_A;
        ///Field `SMP17` reader - Channel 17 sample time selection
        pub type SMP17_R = SMP10_R;
        ///Field `SMP17` writer - Channel 17 sample time selection
        pub struct SMP17_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP17_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP17_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP17_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 21)) | ((value as u32 & 0x07) << 21);
                self.w
            }
        }
        impl R {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            pub fn smp10(&self) -> SMP10_R {
                SMP10_R::new((self.bits & 0x07) as u8)
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            pub fn smp11(&self) -> SMP11_R {
                SMP11_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            pub fn smp12(&self) -> SMP12_R {
                SMP12_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            pub fn smp13(&self) -> SMP13_R {
                SMP13_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            pub fn smp14(&self) -> SMP14_R {
                SMP14_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            pub fn smp15(&self) -> SMP15_R {
                SMP15_R::new(((self.bits >> 15) & 0x07) as u8)
            }
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            pub fn smp16(&self) -> SMP16_R {
                SMP16_R::new(((self.bits >> 18) & 0x07) as u8)
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            pub fn smp17(&self) -> SMP17_R {
                SMP17_R::new(((self.bits >> 21) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 10 sample time selection
            #[inline(always)]
            pub fn smp10(&mut self) -> SMP10_W {
                SMP10_W { w: self }
            }
            ///Bits 3:5 - Channel 11 sample time selection
            #[inline(always)]
            pub fn smp11(&mut self) -> SMP11_W {
                SMP11_W { w: self }
            }
            ///Bits 6:8 - Channel 12 sample time selection
            #[inline(always)]
            pub fn smp12(&mut self) -> SMP12_W {
                SMP12_W { w: self }
            }
            ///Bits 9:11 - Channel 13 sample time selection
            #[inline(always)]
            pub fn smp13(&mut self) -> SMP13_W {
                SMP13_W { w: self }
            }
            ///Bits 12:14 - Channel 14 sample time selection
            #[inline(always)]
            pub fn smp14(&mut self) -> SMP14_W {
                SMP14_W { w: self }
            }
            ///Bits 15:17 - Channel 15 sample time selection
            #[inline(always)]
            pub fn smp15(&mut self) -> SMP15_W {
                SMP15_W { w: self }
            }
            ///Bits 18:20 - Channel 16 sample time selection
            #[inline(always)]
            pub fn smp16(&mut self) -> SMP16_W {
                SMP16_W { w: self }
            }
            ///Bits 21:23 - Channel 17 sample time selection
            #[inline(always)]
            pub fn smp17(&mut self) -> SMP17_W {
                SMP17_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smpr1](index.html) module
        pub struct SMPR1_SPEC;
        impl crate::RegisterSpec for SMPR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smpr1::R](R) reader structure
        impl crate::Readable for SMPR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smpr1::W](W) writer structure
        impl crate::Writable for SMPR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMPR1 to value 0
        impl crate::Resettable for SMPR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMPR2 register accessor: an alias for `Reg<SMPR2_SPEC>`
    pub type SMPR2 = crate::Reg<smpr2::SMPR2_SPEC>;
    ///sample time register 2
    pub mod smpr2 {
        ///Register `SMPR2` reader
        pub struct R(crate::R<SMPR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMPR2_SPEC>> for R {
            fn from(reader: crate::R<SMPR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMPR2` writer
        pub struct W(crate::W<SMPR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMPR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMPR2_SPEC>> for W {
            fn from(writer: crate::W<SMPR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Channel 0 sample time selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum SMP0_A {
            ///0: 1.5 ADC clock cycles
            CYCLES1_5 = 0,
            ///1: 7.5 ADC clock cycles
            CYCLES7_5 = 1,
            ///2: 13.5 ADC clock cycles
            CYCLES13_5 = 2,
            ///3: 28.5 ADC clock cycles
            CYCLES28_5 = 3,
            ///4: 41.5 ADC clock cycles
            CYCLES41_5 = 4,
            ///5: 55.5 ADC clock cycles
            CYCLES55_5 = 5,
            ///6: 71.5 ADC clock cycles
            CYCLES71_5 = 6,
            ///7: 239.5 ADC clock cycles
            CYCLES239_5 = 7,
        }
        impl From<SMP0_A> for u8 {
            #[inline(always)]
            fn from(variant: SMP0_A) -> Self {
                variant as _
            }
        }
        ///Field `SMP0` reader - Channel 0 sample time selection
        pub struct SMP0_R(crate::FieldReader<u8, SMP0_A>);
        impl SMP0_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMP0_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SMP0_A {
                match self.bits {
                    0 => SMP0_A::CYCLES1_5,
                    1 => SMP0_A::CYCLES7_5,
                    2 => SMP0_A::CYCLES13_5,
                    3 => SMP0_A::CYCLES28_5,
                    4 => SMP0_A::CYCLES41_5,
                    5 => SMP0_A::CYCLES55_5,
                    6 => SMP0_A::CYCLES71_5,
                    7 => SMP0_A::CYCLES239_5,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `CYCLES1_5`
            #[inline(always)]
            pub fn is_cycles1_5(&self) -> bool {
                **self == SMP0_A::CYCLES1_5
            }
            ///Checks if the value of the field is `CYCLES7_5`
            #[inline(always)]
            pub fn is_cycles7_5(&self) -> bool {
                **self == SMP0_A::CYCLES7_5
            }
            ///Checks if the value of the field is `CYCLES13_5`
            #[inline(always)]
            pub fn is_cycles13_5(&self) -> bool {
                **self == SMP0_A::CYCLES13_5
            }
            ///Checks if the value of the field is `CYCLES28_5`
            #[inline(always)]
            pub fn is_cycles28_5(&self) -> bool {
                **self == SMP0_A::CYCLES28_5
            }
            ///Checks if the value of the field is `CYCLES41_5`
            #[inline(always)]
            pub fn is_cycles41_5(&self) -> bool {
                **self == SMP0_A::CYCLES41_5
            }
            ///Checks if the value of the field is `CYCLES55_5`
            #[inline(always)]
            pub fn is_cycles55_5(&self) -> bool {
                **self == SMP0_A::CYCLES55_5
            }
            ///Checks if the value of the field is `CYCLES71_5`
            #[inline(always)]
            pub fn is_cycles71_5(&self) -> bool {
                **self == SMP0_A::CYCLES71_5
            }
            ///Checks if the value of the field is `CYCLES239_5`
            #[inline(always)]
            pub fn is_cycles239_5(&self) -> bool {
                **self == SMP0_A::CYCLES239_5
            }
        }
        impl core::ops::Deref for SMP0_R {
            type Target = crate::FieldReader<u8, SMP0_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMP0` writer - Channel 0 sample time selection
        pub struct SMP0_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP0_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP0_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP0_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        ///Channel 1 sample time selection
        pub type SMP1_A = SMP0_A;
        ///Field `SMP1` reader - Channel 1 sample time selection
        pub type SMP1_R = SMP0_R;
        ///Field `SMP1` writer - Channel 1 sample time selection
        pub struct SMP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP1_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP1_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | ((value as u32 & 0x07) << 3);
                self.w
            }
        }
        ///Channel 2 sample time selection
        pub type SMP2_A = SMP0_A;
        ///Field `SMP2` reader - Channel 2 sample time selection
        pub type SMP2_R = SMP0_R;
        ///Field `SMP2` writer - Channel 2 sample time selection
        pub struct SMP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP2_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP2_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 6)) | ((value as u32 & 0x07) << 6);
                self.w
            }
        }
        ///Channel 3 sample time selection
        pub type SMP3_A = SMP0_A;
        ///Field `SMP3` reader - Channel 3 sample time selection
        pub type SMP3_R = SMP0_R;
        ///Field `SMP3` writer - Channel 3 sample time selection
        pub struct SMP3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP3_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP3_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP3_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 9)) | ((value as u32 & 0x07) << 9);
                self.w
            }
        }
        ///Channel 4 sample time selection
        pub type SMP4_A = SMP0_A;
        ///Field `SMP4` reader - Channel 4 sample time selection
        pub type SMP4_R = SMP0_R;
        ///Field `SMP4` writer - Channel 4 sample time selection
        pub struct SMP4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP4_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP4_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP4_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Channel 5 sample time selection
        pub type SMP5_A = SMP0_A;
        ///Field `SMP5` reader - Channel 5 sample time selection
        pub type SMP5_R = SMP0_R;
        ///Field `SMP5` writer - Channel 5 sample time selection
        pub struct SMP5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP5_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP5_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP5_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 15)) | ((value as u32 & 0x07) << 15);
                self.w
            }
        }
        ///Channel 6 sample time selection
        pub type SMP6_A = SMP0_A;
        ///Field `SMP6` reader - Channel 6 sample time selection
        pub type SMP6_R = SMP0_R;
        ///Field `SMP6` writer - Channel 6 sample time selection
        pub struct SMP6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP6_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP6_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP6_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 18)) | ((value as u32 & 0x07) << 18);
                self.w
            }
        }
        ///Channel 7 sample time selection
        pub type SMP7_A = SMP0_A;
        ///Field `SMP7` reader - Channel 7 sample time selection
        pub type SMP7_R = SMP0_R;
        ///Field `SMP7` writer - Channel 7 sample time selection
        pub struct SMP7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP7_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP7_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP7_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 21)) | ((value as u32 & 0x07) << 21);
                self.w
            }
        }
        ///Channel 8 sample time selection
        pub type SMP8_A = SMP0_A;
        ///Field `SMP8` reader - Channel 8 sample time selection
        pub type SMP8_R = SMP0_R;
        ///Field `SMP8` writer - Channel 8 sample time selection
        pub struct SMP8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP8_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP8_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP8_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 24)) | ((value as u32 & 0x07) << 24);
                self.w
            }
        }
        ///Channel 9 sample time selection
        pub type SMP9_A = SMP0_A;
        ///Field `SMP9` reader - Channel 9 sample time selection
        pub type SMP9_R = SMP0_R;
        ///Field `SMP9` writer - Channel 9 sample time selection
        pub struct SMP9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMP9_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SMP9_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///1.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles1_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES1_5)
            }
            ///7.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles7_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES7_5)
            }
            ///13.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles13_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES13_5)
            }
            ///28.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles28_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES28_5)
            }
            ///41.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles41_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES41_5)
            }
            ///55.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles55_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES55_5)
            }
            ///71.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles71_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES71_5)
            }
            ///239.5 ADC clock cycles
            #[inline(always)]
            pub fn cycles239_5(self) -> &'a mut W {
                self.variant(SMP9_A::CYCLES239_5)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 27)) | ((value as u32 & 0x07) << 27);
                self.w
            }
        }
        impl R {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            pub fn smp0(&self) -> SMP0_R {
                SMP0_R::new((self.bits & 0x07) as u8)
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            pub fn smp1(&self) -> SMP1_R {
                SMP1_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            pub fn smp2(&self) -> SMP2_R {
                SMP2_R::new(((self.bits >> 6) & 0x07) as u8)
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            pub fn smp3(&self) -> SMP3_R {
                SMP3_R::new(((self.bits >> 9) & 0x07) as u8)
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            pub fn smp4(&self) -> SMP4_R {
                SMP4_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            pub fn smp5(&self) -> SMP5_R {
                SMP5_R::new(((self.bits >> 15) & 0x07) as u8)
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            pub fn smp6(&self) -> SMP6_R {
                SMP6_R::new(((self.bits >> 18) & 0x07) as u8)
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            pub fn smp7(&self) -> SMP7_R {
                SMP7_R::new(((self.bits >> 21) & 0x07) as u8)
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            pub fn smp8(&self) -> SMP8_R {
                SMP8_R::new(((self.bits >> 24) & 0x07) as u8)
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            pub fn smp9(&self) -> SMP9_R {
                SMP9_R::new(((self.bits >> 27) & 0x07) as u8)
            }
        }
        impl W {
            ///Bits 0:2 - Channel 0 sample time selection
            #[inline(always)]
            pub fn smp0(&mut self) -> SMP0_W {
                SMP0_W { w: self }
            }
            ///Bits 3:5 - Channel 1 sample time selection
            #[inline(always)]
            pub fn smp1(&mut self) -> SMP1_W {
                SMP1_W { w: self }
            }
            ///Bits 6:8 - Channel 2 sample time selection
            #[inline(always)]
            pub fn smp2(&mut self) -> SMP2_W {
                SMP2_W { w: self }
            }
            ///Bits 9:11 - Channel 3 sample time selection
            #[inline(always)]
            pub fn smp3(&mut self) -> SMP3_W {
                SMP3_W { w: self }
            }
            ///Bits 12:14 - Channel 4 sample time selection
            #[inline(always)]
            pub fn smp4(&mut self) -> SMP4_W {
                SMP4_W { w: self }
            }
            ///Bits 15:17 - Channel 5 sample time selection
            #[inline(always)]
            pub fn smp5(&mut self) -> SMP5_W {
                SMP5_W { w: self }
            }
            ///Bits 18:20 - Channel 6 sample time selection
            #[inline(always)]
            pub fn smp6(&mut self) -> SMP6_W {
                SMP6_W { w: self }
            }
            ///Bits 21:23 - Channel 7 sample time selection
            #[inline(always)]
            pub fn smp7(&mut self) -> SMP7_W {
                SMP7_W { w: self }
            }
            ///Bits 24:26 - Channel 8 sample time selection
            #[inline(always)]
            pub fn smp8(&mut self) -> SMP8_W {
                SMP8_W { w: self }
            }
            ///Bits 27:29 - Channel 9 sample time selection
            #[inline(always)]
            pub fn smp9(&mut self) -> SMP9_W {
                SMP9_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///sample time register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smpr2](index.html) module
        pub struct SMPR2_SPEC;
        impl crate::RegisterSpec for SMPR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smpr2::R](R) reader structure
        impl crate::Readable for SMPR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smpr2::W](W) writer structure
        impl crate::Writable for SMPR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMPR2 to value 0
        impl crate::Resettable for SMPR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JOFR1 register accessor: an alias for `Reg<JOFR1_SPEC>`
    pub type JOFR1 = crate::Reg<jofr1::JOFR1_SPEC>;
    ///injected channel data offset register x
    pub mod jofr1 {
        ///Register `JOFR1` reader
        pub struct R(crate::R<JOFR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JOFR1_SPEC>> for R {
            fn from(reader: crate::R<JOFR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `JOFR1` writer
        pub struct W(crate::W<JOFR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<JOFR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<JOFR1_SPEC>> for W {
            fn from(writer: crate::W<JOFR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET1` reader - Data offset for injected channel 1
        pub struct JOFFSET1_R(crate::FieldReader<u16, u16>);
        impl JOFFSET1_R {
            pub(crate) fn new(bits: u16) -> Self {
                JOFFSET1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JOFFSET1_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JOFFSET1` writer - Data offset for injected channel 1
        pub struct JOFFSET1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Data offset for injected channel 1
            #[inline(always)]
            pub fn joffset1(&self) -> JOFFSET1_R {
                JOFFSET1_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel 1
            #[inline(always)]
            pub fn joffset1(&mut self) -> JOFFSET1_W {
                JOFFSET1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jofr1](index.html) module
        pub struct JOFR1_SPEC;
        impl crate::RegisterSpec for JOFR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jofr1::R](R) reader structure
        impl crate::Readable for JOFR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [jofr1::W](W) writer structure
        impl crate::Writable for JOFR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets JOFR1 to value 0
        impl crate::Resettable for JOFR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JOFR2 register accessor: an alias for `Reg<JOFR2_SPEC>`
    pub type JOFR2 = crate::Reg<jofr2::JOFR2_SPEC>;
    ///injected channel data offset register x
    pub mod jofr2 {
        ///Register `JOFR2` reader
        pub struct R(crate::R<JOFR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JOFR2_SPEC>> for R {
            fn from(reader: crate::R<JOFR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `JOFR2` writer
        pub struct W(crate::W<JOFR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<JOFR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<JOFR2_SPEC>> for W {
            fn from(writer: crate::W<JOFR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET2` reader - Data offset for injected channel 2
        pub struct JOFFSET2_R(crate::FieldReader<u16, u16>);
        impl JOFFSET2_R {
            pub(crate) fn new(bits: u16) -> Self {
                JOFFSET2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JOFFSET2_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JOFFSET2` writer - Data offset for injected channel 2
        pub struct JOFFSET2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Data offset for injected channel 2
            #[inline(always)]
            pub fn joffset2(&self) -> JOFFSET2_R {
                JOFFSET2_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel 2
            #[inline(always)]
            pub fn joffset2(&mut self) -> JOFFSET2_W {
                JOFFSET2_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jofr2](index.html) module
        pub struct JOFR2_SPEC;
        impl crate::RegisterSpec for JOFR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jofr2::R](R) reader structure
        impl crate::Readable for JOFR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [jofr2::W](W) writer structure
        impl crate::Writable for JOFR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets JOFR2 to value 0
        impl crate::Resettable for JOFR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JOFR3 register accessor: an alias for `Reg<JOFR3_SPEC>`
    pub type JOFR3 = crate::Reg<jofr3::JOFR3_SPEC>;
    ///injected channel data offset register x
    pub mod jofr3 {
        ///Register `JOFR3` reader
        pub struct R(crate::R<JOFR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JOFR3_SPEC>> for R {
            fn from(reader: crate::R<JOFR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `JOFR3` writer
        pub struct W(crate::W<JOFR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<JOFR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<JOFR3_SPEC>> for W {
            fn from(writer: crate::W<JOFR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET3` reader - Data offset for injected channel 3
        pub struct JOFFSET3_R(crate::FieldReader<u16, u16>);
        impl JOFFSET3_R {
            pub(crate) fn new(bits: u16) -> Self {
                JOFFSET3_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JOFFSET3_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JOFFSET3` writer - Data offset for injected channel 3
        pub struct JOFFSET3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET3_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Data offset for injected channel 3
            #[inline(always)]
            pub fn joffset3(&self) -> JOFFSET3_R {
                JOFFSET3_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel 3
            #[inline(always)]
            pub fn joffset3(&mut self) -> JOFFSET3_W {
                JOFFSET3_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jofr3](index.html) module
        pub struct JOFR3_SPEC;
        impl crate::RegisterSpec for JOFR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jofr3::R](R) reader structure
        impl crate::Readable for JOFR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [jofr3::W](W) writer structure
        impl crate::Writable for JOFR3_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets JOFR3 to value 0
        impl crate::Resettable for JOFR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JOFR4 register accessor: an alias for `Reg<JOFR4_SPEC>`
    pub type JOFR4 = crate::Reg<jofr4::JOFR4_SPEC>;
    ///injected channel data offset register x
    pub mod jofr4 {
        ///Register `JOFR4` reader
        pub struct R(crate::R<JOFR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JOFR4_SPEC>> for R {
            fn from(reader: crate::R<JOFR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `JOFR4` writer
        pub struct W(crate::W<JOFR4_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<JOFR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<JOFR4_SPEC>> for W {
            fn from(writer: crate::W<JOFR4_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JOFFSET4` reader - Data offset for injected channel 4
        pub struct JOFFSET4_R(crate::FieldReader<u16, u16>);
        impl JOFFSET4_R {
            pub(crate) fn new(bits: u16) -> Self {
                JOFFSET4_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JOFFSET4_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JOFFSET4` writer - Data offset for injected channel 4
        pub struct JOFFSET4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JOFFSET4_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Data offset for injected channel 4
            #[inline(always)]
            pub fn joffset4(&self) -> JOFFSET4_R {
                JOFFSET4_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Data offset for injected channel 4
            #[inline(always)]
            pub fn joffset4(&mut self) -> JOFFSET4_W {
                JOFFSET4_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected channel data offset register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jofr4](index.html) module
        pub struct JOFR4_SPEC;
        impl crate::RegisterSpec for JOFR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jofr4::R](R) reader structure
        impl crate::Readable for JOFR4_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [jofr4::W](W) writer structure
        impl crate::Writable for JOFR4_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets JOFR4 to value 0
        impl crate::Resettable for JOFR4_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///HTR register accessor: an alias for `Reg<HTR_SPEC>`
    pub type HTR = crate::Reg<htr::HTR_SPEC>;
    ///watchdog higher threshold register
    pub mod htr {
        ///Register `HTR` reader
        pub struct R(crate::R<HTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<HTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<HTR_SPEC>> for R {
            fn from(reader: crate::R<HTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `HTR` writer
        pub struct W(crate::W<HTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<HTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<HTR_SPEC>> for W {
            fn from(writer: crate::W<HTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HT` reader - Analog watchdog higher threshold
        pub struct HT_R(crate::FieldReader<u16, u16>);
        impl HT_R {
            pub(crate) fn new(bits: u16) -> Self {
                HT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for HT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HT` writer - Analog watchdog higher threshold
        pub struct HT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            pub fn ht(&self) -> HT_R {
                HT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog higher threshold
            #[inline(always)]
            pub fn ht(&mut self) -> HT_W {
                HT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog higher threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [htr](index.html) module
        pub struct HTR_SPEC;
        impl crate::RegisterSpec for HTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [htr::R](R) reader structure
        impl crate::Readable for HTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [htr::W](W) writer structure
        impl crate::Writable for HTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets HTR to value 0x0fff
        impl crate::Resettable for HTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x0fff
            }
        }
    }
    ///LTR register accessor: an alias for `Reg<LTR_SPEC>`
    pub type LTR = crate::Reg<ltr::LTR_SPEC>;
    ///watchdog lower threshold register
    pub mod ltr {
        ///Register `LTR` reader
        pub struct R(crate::R<LTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<LTR_SPEC>> for R {
            fn from(reader: crate::R<LTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LTR` writer
        pub struct W(crate::W<LTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<LTR_SPEC>> for W {
            fn from(writer: crate::W<LTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `LT` reader - Analog watchdog lower threshold
        pub struct LT_R(crate::FieldReader<u16, u16>);
        impl LT_R {
            pub(crate) fn new(bits: u16) -> Self {
                LT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LT` writer - Analog watchdog lower threshold
        pub struct LT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            pub fn lt(&self) -> LT_R {
                LT_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - Analog watchdog lower threshold
            #[inline(always)]
            pub fn lt(&mut self) -> LT_W {
                LT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///watchdog lower threshold register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ltr](index.html) module
        pub struct LTR_SPEC;
        impl crate::RegisterSpec for LTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ltr::R](R) reader structure
        impl crate::Readable for LTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ltr::W](W) writer structure
        impl crate::Writable for LTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets LTR to value 0
        impl crate::Resettable for LTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SQR1 register accessor: an alias for `Reg<SQR1_SPEC>`
    pub type SQR1 = crate::Reg<sqr1::SQR1_SPEC>;
    ///regular sequence register 1
    pub mod sqr1 {
        ///Register `SQR1` reader
        pub struct R(crate::R<SQR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SQR1_SPEC>> for R {
            fn from(reader: crate::R<SQR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SQR1` writer
        pub struct W(crate::W<SQR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SQR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SQR1_SPEC>> for W {
            fn from(writer: crate::W<SQR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `L` reader - Regular channel sequence length
        pub struct L_R(crate::FieldReader<u8, u8>);
        impl L_R {
            pub(crate) fn new(bits: u8) -> Self {
                L_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for L_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `L` writer - Regular channel sequence length
        pub struct L_W<'a> {
            w: &'a mut W,
        }
        impl<'a> L_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 20)) | ((value as u32 & 0x0f) << 20);
                self.w
            }
        }
        ///Field `SQ16` reader - 16th conversion in regular sequence
        pub struct SQ16_R(crate::FieldReader<u8, u8>);
        impl SQ16_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ16_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ16_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ16` writer - 16th conversion in regular sequence
        pub struct SQ16_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ16_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | ((value as u32 & 0x1f) << 15);
                self.w
            }
        }
        ///Field `SQ15` reader - 15th conversion in regular sequence
        pub struct SQ15_R(crate::FieldReader<u8, u8>);
        impl SQ15_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ15_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ15_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ15` writer - 15th conversion in regular sequence
        pub struct SQ15_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ15_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | ((value as u32 & 0x1f) << 10);
                self.w
            }
        }
        ///Field `SQ14` reader - 14th conversion in regular sequence
        pub struct SQ14_R(crate::FieldReader<u8, u8>);
        impl SQ14_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ14_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ14_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ14` writer - 14th conversion in regular sequence
        pub struct SQ14_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ14_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | ((value as u32 & 0x1f) << 5);
                self.w
            }
        }
        ///Field `SQ13` reader - 13th conversion in regular sequence
        pub struct SQ13_R(crate::FieldReader<u8, u8>);
        impl SQ13_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ13_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ13_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ13` writer - 13th conversion in regular sequence
        pub struct SQ13_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ13_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            pub fn l(&self) -> L_R {
                L_R::new(((self.bits >> 20) & 0x0f) as u8)
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            pub fn sq16(&self) -> SQ16_R {
                SQ16_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            pub fn sq15(&self) -> SQ15_R {
                SQ15_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            pub fn sq14(&self) -> SQ14_R {
                SQ14_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            pub fn sq13(&self) -> SQ13_R {
                SQ13_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 20:23 - Regular channel sequence length
            #[inline(always)]
            pub fn l(&mut self) -> L_W {
                L_W { w: self }
            }
            ///Bits 15:19 - 16th conversion in regular sequence
            #[inline(always)]
            pub fn sq16(&mut self) -> SQ16_W {
                SQ16_W { w: self }
            }
            ///Bits 10:14 - 15th conversion in regular sequence
            #[inline(always)]
            pub fn sq15(&mut self) -> SQ15_W {
                SQ15_W { w: self }
            }
            ///Bits 5:9 - 14th conversion in regular sequence
            #[inline(always)]
            pub fn sq14(&mut self) -> SQ14_W {
                SQ14_W { w: self }
            }
            ///Bits 0:4 - 13th conversion in regular sequence
            #[inline(always)]
            pub fn sq13(&mut self) -> SQ13_W {
                SQ13_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sqr1](index.html) module
        pub struct SQR1_SPEC;
        impl crate::RegisterSpec for SQR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sqr1::R](R) reader structure
        impl crate::Readable for SQR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sqr1::W](W) writer structure
        impl crate::Writable for SQR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SQR1 to value 0
        impl crate::Resettable for SQR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SQR2 register accessor: an alias for `Reg<SQR2_SPEC>`
    pub type SQR2 = crate::Reg<sqr2::SQR2_SPEC>;
    ///regular sequence register 2
    pub mod sqr2 {
        ///Register `SQR2` reader
        pub struct R(crate::R<SQR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SQR2_SPEC>> for R {
            fn from(reader: crate::R<SQR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SQR2` writer
        pub struct W(crate::W<SQR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SQR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SQR2_SPEC>> for W {
            fn from(writer: crate::W<SQR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ12` reader - 12th conversion in regular sequence
        pub struct SQ12_R(crate::FieldReader<u8, u8>);
        impl SQ12_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ12_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ12_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ12` writer - 12th conversion in regular sequence
        pub struct SQ12_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ12_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 25)) | ((value as u32 & 0x1f) << 25);
                self.w
            }
        }
        ///Field `SQ11` reader - 11th conversion in regular sequence
        pub struct SQ11_R(crate::FieldReader<u8, u8>);
        impl SQ11_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ11_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ11_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ11` writer - 11th conversion in regular sequence
        pub struct SQ11_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ11_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 20)) | ((value as u32 & 0x1f) << 20);
                self.w
            }
        }
        ///Field `SQ10` reader - 10th conversion in regular sequence
        pub struct SQ10_R(crate::FieldReader<u8, u8>);
        impl SQ10_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ10_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ10_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ10` writer - 10th conversion in regular sequence
        pub struct SQ10_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ10_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | ((value as u32 & 0x1f) << 15);
                self.w
            }
        }
        ///Field `SQ9` reader - 9th conversion in regular sequence
        pub struct SQ9_R(crate::FieldReader<u8, u8>);
        impl SQ9_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ9_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ9_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ9` writer - 9th conversion in regular sequence
        pub struct SQ9_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ9_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | ((value as u32 & 0x1f) << 10);
                self.w
            }
        }
        ///Field `SQ8` reader - 8th conversion in regular sequence
        pub struct SQ8_R(crate::FieldReader<u8, u8>);
        impl SQ8_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ8_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ8_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ8` writer - 8th conversion in regular sequence
        pub struct SQ8_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ8_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | ((value as u32 & 0x1f) << 5);
                self.w
            }
        }
        ///Field `SQ7` reader - 7th conversion in regular sequence
        pub struct SQ7_R(crate::FieldReader<u8, u8>);
        impl SQ7_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ7_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ7_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ7` writer - 7th conversion in regular sequence
        pub struct SQ7_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ7_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            pub fn sq12(&self) -> SQ12_R {
                SQ12_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            pub fn sq11(&self) -> SQ11_R {
                SQ11_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            pub fn sq10(&self) -> SQ10_R {
                SQ10_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            pub fn sq9(&self) -> SQ9_R {
                SQ9_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            pub fn sq8(&self) -> SQ8_R {
                SQ8_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            pub fn sq7(&self) -> SQ7_R {
                SQ7_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 25:29 - 12th conversion in regular sequence
            #[inline(always)]
            pub fn sq12(&mut self) -> SQ12_W {
                SQ12_W { w: self }
            }
            ///Bits 20:24 - 11th conversion in regular sequence
            #[inline(always)]
            pub fn sq11(&mut self) -> SQ11_W {
                SQ11_W { w: self }
            }
            ///Bits 15:19 - 10th conversion in regular sequence
            #[inline(always)]
            pub fn sq10(&mut self) -> SQ10_W {
                SQ10_W { w: self }
            }
            ///Bits 10:14 - 9th conversion in regular sequence
            #[inline(always)]
            pub fn sq9(&mut self) -> SQ9_W {
                SQ9_W { w: self }
            }
            ///Bits 5:9 - 8th conversion in regular sequence
            #[inline(always)]
            pub fn sq8(&mut self) -> SQ8_W {
                SQ8_W { w: self }
            }
            ///Bits 0:4 - 7th conversion in regular sequence
            #[inline(always)]
            pub fn sq7(&mut self) -> SQ7_W {
                SQ7_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sqr2](index.html) module
        pub struct SQR2_SPEC;
        impl crate::RegisterSpec for SQR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sqr2::R](R) reader structure
        impl crate::Readable for SQR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sqr2::W](W) writer structure
        impl crate::Writable for SQR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SQR2 to value 0
        impl crate::Resettable for SQR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SQR3 register accessor: an alias for `Reg<SQR3_SPEC>`
    pub type SQR3 = crate::Reg<sqr3::SQR3_SPEC>;
    ///regular sequence register 3
    pub mod sqr3 {
        ///Register `SQR3` reader
        pub struct R(crate::R<SQR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SQR3_SPEC>> for R {
            fn from(reader: crate::R<SQR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SQR3` writer
        pub struct W(crate::W<SQR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SQR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SQR3_SPEC>> for W {
            fn from(writer: crate::W<SQR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `SQ6` reader - 6th conversion in regular sequence
        pub struct SQ6_R(crate::FieldReader<u8, u8>);
        impl SQ6_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ6_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ6_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ6` writer - 6th conversion in regular sequence
        pub struct SQ6_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ6_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 25)) | ((value as u32 & 0x1f) << 25);
                self.w
            }
        }
        ///Field `SQ5` reader - 5th conversion in regular sequence
        pub struct SQ5_R(crate::FieldReader<u8, u8>);
        impl SQ5_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ5_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ5_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ5` writer - 5th conversion in regular sequence
        pub struct SQ5_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ5_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 20)) | ((value as u32 & 0x1f) << 20);
                self.w
            }
        }
        ///Field `SQ4` reader - 4th conversion in regular sequence
        pub struct SQ4_R(crate::FieldReader<u8, u8>);
        impl SQ4_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ4_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ4_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ4` writer - 4th conversion in regular sequence
        pub struct SQ4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ4_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | ((value as u32 & 0x1f) << 15);
                self.w
            }
        }
        ///Field `SQ3` reader - 3rd conversion in regular sequence
        pub struct SQ3_R(crate::FieldReader<u8, u8>);
        impl SQ3_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ3_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ3_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ3` writer - 3rd conversion in regular sequence
        pub struct SQ3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ3_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | ((value as u32 & 0x1f) << 10);
                self.w
            }
        }
        ///Field `SQ2` reader - 2nd conversion in regular sequence
        pub struct SQ2_R(crate::FieldReader<u8, u8>);
        impl SQ2_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ2_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ2` writer - 2nd conversion in regular sequence
        pub struct SQ2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | ((value as u32 & 0x1f) << 5);
                self.w
            }
        }
        ///Field `SQ1` reader - 1st conversion in regular sequence
        pub struct SQ1_R(crate::FieldReader<u8, u8>);
        impl SQ1_R {
            pub(crate) fn new(bits: u8) -> Self {
                SQ1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SQ1_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SQ1` writer - 1st conversion in regular sequence
        pub struct SQ1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SQ1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            pub fn sq6(&self) -> SQ6_R {
                SQ6_R::new(((self.bits >> 25) & 0x1f) as u8)
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            pub fn sq5(&self) -> SQ5_R {
                SQ5_R::new(((self.bits >> 20) & 0x1f) as u8)
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            pub fn sq4(&self) -> SQ4_R {
                SQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            pub fn sq3(&self) -> SQ3_R {
                SQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            pub fn sq2(&self) -> SQ2_R {
                SQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            pub fn sq1(&self) -> SQ1_R {
                SQ1_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 25:29 - 6th conversion in regular sequence
            #[inline(always)]
            pub fn sq6(&mut self) -> SQ6_W {
                SQ6_W { w: self }
            }
            ///Bits 20:24 - 5th conversion in regular sequence
            #[inline(always)]
            pub fn sq5(&mut self) -> SQ5_W {
                SQ5_W { w: self }
            }
            ///Bits 15:19 - 4th conversion in regular sequence
            #[inline(always)]
            pub fn sq4(&mut self) -> SQ4_W {
                SQ4_W { w: self }
            }
            ///Bits 10:14 - 3rd conversion in regular sequence
            #[inline(always)]
            pub fn sq3(&mut self) -> SQ3_W {
                SQ3_W { w: self }
            }
            ///Bits 5:9 - 2nd conversion in regular sequence
            #[inline(always)]
            pub fn sq2(&mut self) -> SQ2_W {
                SQ2_W { w: self }
            }
            ///Bits 0:4 - 1st conversion in regular sequence
            #[inline(always)]
            pub fn sq1(&mut self) -> SQ1_W {
                SQ1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///regular sequence register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sqr3](index.html) module
        pub struct SQR3_SPEC;
        impl crate::RegisterSpec for SQR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sqr3::R](R) reader structure
        impl crate::Readable for SQR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sqr3::W](W) writer structure
        impl crate::Writable for SQR3_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SQR3 to value 0
        impl crate::Resettable for SQR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JSQR register accessor: an alias for `Reg<JSQR_SPEC>`
    pub type JSQR = crate::Reg<jsqr::JSQR_SPEC>;
    ///injected sequence register
    pub mod jsqr {
        ///Register `JSQR` reader
        pub struct R(crate::R<JSQR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JSQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JSQR_SPEC>> for R {
            fn from(reader: crate::R<JSQR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `JSQR` writer
        pub struct W(crate::W<JSQR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<JSQR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<JSQR_SPEC>> for W {
            fn from(writer: crate::W<JSQR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `JL` reader - Injected sequence length
        pub struct JL_R(crate::FieldReader<u8, u8>);
        impl JL_R {
            pub(crate) fn new(bits: u8) -> Self {
                JL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JL` writer - Injected sequence length
        pub struct JL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 20)) | ((value as u32 & 0x03) << 20);
                self.w
            }
        }
        ///Field `JSQ4` reader - 4th conversion in injected sequence
        pub struct JSQ4_R(crate::FieldReader<u8, u8>);
        impl JSQ4_R {
            pub(crate) fn new(bits: u8) -> Self {
                JSQ4_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JSQ4_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JSQ4` writer - 4th conversion in injected sequence
        pub struct JSQ4_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ4_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 15)) | ((value as u32 & 0x1f) << 15);
                self.w
            }
        }
        ///Field `JSQ3` reader - 3rd conversion in injected sequence
        pub struct JSQ3_R(crate::FieldReader<u8, u8>);
        impl JSQ3_R {
            pub(crate) fn new(bits: u8) -> Self {
                JSQ3_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JSQ3_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JSQ3` writer - 3rd conversion in injected sequence
        pub struct JSQ3_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ3_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 10)) | ((value as u32 & 0x1f) << 10);
                self.w
            }
        }
        ///Field `JSQ2` reader - 2nd conversion in injected sequence
        pub struct JSQ2_R(crate::FieldReader<u8, u8>);
        impl JSQ2_R {
            pub(crate) fn new(bits: u8) -> Self {
                JSQ2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JSQ2_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JSQ2` writer - 2nd conversion in injected sequence
        pub struct JSQ2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 5)) | ((value as u32 & 0x1f) << 5);
                self.w
            }
        }
        ///Field `JSQ1` reader - 1st conversion in injected sequence
        pub struct JSQ1_R(crate::FieldReader<u8, u8>);
        impl JSQ1_R {
            pub(crate) fn new(bits: u8) -> Self {
                JSQ1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JSQ1_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `JSQ1` writer - 1st conversion in injected sequence
        pub struct JSQ1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> JSQ1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            pub fn jl(&self) -> JL_R {
                JL_R::new(((self.bits >> 20) & 0x03) as u8)
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            pub fn jsq4(&self) -> JSQ4_R {
                JSQ4_R::new(((self.bits >> 15) & 0x1f) as u8)
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            pub fn jsq3(&self) -> JSQ3_R {
                JSQ3_R::new(((self.bits >> 10) & 0x1f) as u8)
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            pub fn jsq2(&self) -> JSQ2_R {
                JSQ2_R::new(((self.bits >> 5) & 0x1f) as u8)
            }
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            pub fn jsq1(&self) -> JSQ1_R {
                JSQ1_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 20:21 - Injected sequence length
            #[inline(always)]
            pub fn jl(&mut self) -> JL_W {
                JL_W { w: self }
            }
            ///Bits 15:19 - 4th conversion in injected sequence
            #[inline(always)]
            pub fn jsq4(&mut self) -> JSQ4_W {
                JSQ4_W { w: self }
            }
            ///Bits 10:14 - 3rd conversion in injected sequence
            #[inline(always)]
            pub fn jsq3(&mut self) -> JSQ3_W {
                JSQ3_W { w: self }
            }
            ///Bits 5:9 - 2nd conversion in injected sequence
            #[inline(always)]
            pub fn jsq2(&mut self) -> JSQ2_W {
                JSQ2_W { w: self }
            }
            ///Bits 0:4 - 1st conversion in injected sequence
            #[inline(always)]
            pub fn jsq1(&mut self) -> JSQ1_W {
                JSQ1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///injected sequence register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jsqr](index.html) module
        pub struct JSQR_SPEC;
        impl crate::RegisterSpec for JSQR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jsqr::R](R) reader structure
        impl crate::Readable for JSQR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [jsqr::W](W) writer structure
        impl crate::Writable for JSQR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets JSQR to value 0
        impl crate::Resettable for JSQR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JDR1 register accessor: an alias for `Reg<JDR1_SPEC>`
    pub type JDR1 = crate::Reg<jdr1::JDR1_SPEC>;
    ///injected data register x
    pub mod jdr1 {
        ///Register `JDR1` reader
        pub struct R(crate::R<JDR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JDR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JDR1_SPEC>> for R {
            fn from(reader: crate::R<JDR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `JDATA` reader - Injected data
        pub struct JDATA_R(crate::FieldReader<u16, u16>);
        impl JDATA_R {
            pub(crate) fn new(bits: u16) -> Self {
                JDATA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JDATA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jdr1](index.html) module
        pub struct JDR1_SPEC;
        impl crate::RegisterSpec for JDR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jdr1::R](R) reader structure
        impl crate::Readable for JDR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets JDR1 to value 0
        impl crate::Resettable for JDR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JDR2 register accessor: an alias for `Reg<JDR2_SPEC>`
    pub type JDR2 = crate::Reg<jdr2::JDR2_SPEC>;
    ///injected data register x
    pub mod jdr2 {
        ///Register `JDR2` reader
        pub struct R(crate::R<JDR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JDR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JDR2_SPEC>> for R {
            fn from(reader: crate::R<JDR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `JDATA` reader - Injected data
        pub struct JDATA_R(crate::FieldReader<u16, u16>);
        impl JDATA_R {
            pub(crate) fn new(bits: u16) -> Self {
                JDATA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JDATA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jdr2](index.html) module
        pub struct JDR2_SPEC;
        impl crate::RegisterSpec for JDR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jdr2::R](R) reader structure
        impl crate::Readable for JDR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets JDR2 to value 0
        impl crate::Resettable for JDR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JDR3 register accessor: an alias for `Reg<JDR3_SPEC>`
    pub type JDR3 = crate::Reg<jdr3::JDR3_SPEC>;
    ///injected data register x
    pub mod jdr3 {
        ///Register `JDR3` reader
        pub struct R(crate::R<JDR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JDR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JDR3_SPEC>> for R {
            fn from(reader: crate::R<JDR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `JDATA` reader - Injected data
        pub struct JDATA_R(crate::FieldReader<u16, u16>);
        impl JDATA_R {
            pub(crate) fn new(bits: u16) -> Self {
                JDATA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JDATA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jdr3](index.html) module
        pub struct JDR3_SPEC;
        impl crate::RegisterSpec for JDR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jdr3::R](R) reader structure
        impl crate::Readable for JDR3_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets JDR3 to value 0
        impl crate::Resettable for JDR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///JDR4 register accessor: an alias for `Reg<JDR4_SPEC>`
    pub type JDR4 = crate::Reg<jdr4::JDR4_SPEC>;
    ///injected data register x
    pub mod jdr4 {
        ///Register `JDR4` reader
        pub struct R(crate::R<JDR4_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<JDR4_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<JDR4_SPEC>> for R {
            fn from(reader: crate::R<JDR4_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `JDATA` reader - Injected data
        pub struct JDATA_R(crate::FieldReader<u16, u16>);
        impl JDATA_R {
            pub(crate) fn new(bits: u16) -> Self {
                JDATA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for JDATA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Injected data
            #[inline(always)]
            pub fn jdata(&self) -> JDATA_R {
                JDATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///injected data register x
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [jdr4](index.html) module
        pub struct JDR4_SPEC;
        impl crate::RegisterSpec for JDR4_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [jdr4::R](R) reader structure
        impl crate::Readable for JDR4_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets JDR4 to value 0
        impl crate::Resettable for JDR4_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///regular data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DATA` reader - Regular data
        pub struct DATA_R(crate::FieldReader<u16, u16>);
        impl DATA_R {
            pub(crate) fn new(bits: u16) -> Self {
                DATA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:15 - Regular data
            #[inline(always)]
            pub fn data(&self) -> DATA_R {
                DATA_R::new((self.bits & 0xffff) as u16)
            }
        }
        ///regular data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DR to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Digital to analog converter
pub struct DAC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DAC {}
impl DAC {
    ///Pointer to the register block
    pub const PTR: *const dac::RegisterBlock = 0x4000_7400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dac::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DAC {
    type Target = dac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DAC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DAC").finish()
    }
}
///Digital to analog converter
pub mod dac {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Control register (DAC_CR)
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x04 - DAC software trigger register (DAC_SWTRIGR)
        pub swtrigr: crate::Reg<swtrigr::SWTRIGR_SPEC>,
        ///0x08 - DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)
        pub dhr12r1: crate::Reg<dhr12r1::DHR12R1_SPEC>,
        ///0x0c - DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)
        pub dhr12l1: crate::Reg<dhr12l1::DHR12L1_SPEC>,
        ///0x10 - DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)
        pub dhr8r1: crate::Reg<dhr8r1::DHR8R1_SPEC>,
        ///0x14 - DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)
        pub dhr12r2: crate::Reg<dhr12r2::DHR12R2_SPEC>,
        ///0x18 - DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)
        pub dhr12l2: crate::Reg<dhr12l2::DHR12L2_SPEC>,
        ///0x1c - DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)
        pub dhr8r2: crate::Reg<dhr8r2::DHR8R2_SPEC>,
        ///0x20 - Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved
        pub dhr12rd: crate::Reg<dhr12rd::DHR12RD_SPEC>,
        ///0x24 - DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved
        pub dhr12ld: crate::Reg<dhr12ld::DHR12LD_SPEC>,
        ///0x28 - DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved
        pub dhr8rd: crate::Reg<dhr8rd::DHR8RD_SPEC>,
        ///0x2c - DAC channel1 data output register (DAC_DOR1)
        pub dor1: crate::Reg<dor1::DOR1_SPEC>,
        ///0x30 - DAC channel2 data output register (DAC_DOR2)
        pub dor2: crate::Reg<dor2::DOR2_SPEC>,
        ///0x34 - DAC status register
        pub sr: crate::Reg<sr::SR_SPEC>,
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Control register (DAC_CR)
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///DAC channel1 enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EN1_A {
            ///0: DAC channel X disabled
            DISABLED = 0,
            ///1: DAC channel X enabled
            ENABLED = 1,
        }
        impl From<EN1_A> for bool {
            #[inline(always)]
            fn from(variant: EN1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EN1` reader - DAC channel1 enable
        pub struct EN1_R(crate::FieldReader<bool, EN1_A>);
        impl EN1_R {
            pub(crate) fn new(bits: bool) -> Self {
                EN1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EN1_A {
                match self.bits {
                    false => EN1_A::DISABLED,
                    true => EN1_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EN1_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EN1_A::ENABLED
            }
        }
        impl core::ops::Deref for EN1_R {
            type Target = crate::FieldReader<bool, EN1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EN1` writer - DAC channel1 enable
        pub struct EN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EN1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN1_A::DISABLED)
            }
            ///DAC channel X enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///DAC channel1 output buffer disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BOFF1_A {
            ///0: DAC channel X output buffer enabled
            ENABLED = 0,
            ///1: DAC channel X output buffer disabled
            DISABLED = 1,
        }
        impl From<BOFF1_A> for bool {
            #[inline(always)]
            fn from(variant: BOFF1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BOFF1` reader - DAC channel1 output buffer disable
        pub struct BOFF1_R(crate::FieldReader<bool, BOFF1_A>);
        impl BOFF1_R {
            pub(crate) fn new(bits: bool) -> Self {
                BOFF1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BOFF1_A {
                match self.bits {
                    false => BOFF1_A::ENABLED,
                    true => BOFF1_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == BOFF1_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == BOFF1_A::DISABLED
            }
        }
        impl core::ops::Deref for BOFF1_R {
            type Target = crate::FieldReader<bool, BOFF1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BOFF1` writer - DAC channel1 output buffer disable
        pub struct BOFF1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BOFF1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BOFF1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X output buffer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF1_A::ENABLED)
            }
            ///DAC channel X output buffer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF1_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///DAC channel1 trigger enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TEN1_A {
            ///0: DAC channel X trigger disabled
            DISABLED = 0,
            ///1: DAC channel X trigger enabled
            ENABLED = 1,
        }
        impl From<TEN1_A> for bool {
            #[inline(always)]
            fn from(variant: TEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TEN1` reader - DAC channel1 trigger enable
        pub struct TEN1_R(crate::FieldReader<bool, TEN1_A>);
        impl TEN1_R {
            pub(crate) fn new(bits: bool) -> Self {
                TEN1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TEN1_A {
                match self.bits {
                    false => TEN1_A::DISABLED,
                    true => TEN1_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TEN1_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TEN1_A::ENABLED
            }
        }
        impl core::ops::Deref for TEN1_R {
            type Target = crate::FieldReader<bool, TEN1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TEN1` writer - DAC channel1 trigger enable
        pub struct TEN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEN1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TEN1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN1_A::DISABLED)
            }
            ///DAC channel X trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///DAC channel1 trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TSEL1_A {
            ///0: Timer 6 TRGO event
            TIM6_TRGO = 0,
            ///1: Timer 3 TRGO event
            TIM3_TRGO = 1,
            ///2: Timer 7 TRGO event
            TIM7_TRGO = 2,
            ///3: Timer 15 TRGO event
            TIM15_TRGO = 3,
            ///4: Timer 2 TRGO event
            TIM2_TRGO = 4,
            ///6: EXTI line9
            EXTI9 = 6,
            ///7: Software trigger
            SOFTWARE = 7,
        }
        impl From<TSEL1_A> for u8 {
            #[inline(always)]
            fn from(variant: TSEL1_A) -> Self {
                variant as _
            }
        }
        ///Field `TSEL1` reader - DAC channel1 trigger selection
        pub struct TSEL1_R(crate::FieldReader<u8, TSEL1_A>);
        impl TSEL1_R {
            pub(crate) fn new(bits: u8) -> Self {
                TSEL1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<TSEL1_A> {
                match self.bits {
                    0 => Some(TSEL1_A::TIM6_TRGO),
                    1 => Some(TSEL1_A::TIM3_TRGO),
                    2 => Some(TSEL1_A::TIM7_TRGO),
                    3 => Some(TSEL1_A::TIM15_TRGO),
                    4 => Some(TSEL1_A::TIM2_TRGO),
                    6 => Some(TSEL1_A::EXTI9),
                    7 => Some(TSEL1_A::SOFTWARE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `TIM6_TRGO`
            #[inline(always)]
            pub fn is_tim6_trgo(&self) -> bool {
                **self == TSEL1_A::TIM6_TRGO
            }
            ///Checks if the value of the field is `TIM3_TRGO`
            #[inline(always)]
            pub fn is_tim3_trgo(&self) -> bool {
                **self == TSEL1_A::TIM3_TRGO
            }
            ///Checks if the value of the field is `TIM7_TRGO`
            #[inline(always)]
            pub fn is_tim7_trgo(&self) -> bool {
                **self == TSEL1_A::TIM7_TRGO
            }
            ///Checks if the value of the field is `TIM15_TRGO`
            #[inline(always)]
            pub fn is_tim15_trgo(&self) -> bool {
                **self == TSEL1_A::TIM15_TRGO
            }
            ///Checks if the value of the field is `TIM2_TRGO`
            #[inline(always)]
            pub fn is_tim2_trgo(&self) -> bool {
                **self == TSEL1_A::TIM2_TRGO
            }
            ///Checks if the value of the field is `EXTI9`
            #[inline(always)]
            pub fn is_exti9(&self) -> bool {
                **self == TSEL1_A::EXTI9
            }
            ///Checks if the value of the field is `SOFTWARE`
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                **self == TSEL1_A::SOFTWARE
            }
        }
        impl core::ops::Deref for TSEL1_R {
            type Target = crate::FieldReader<u8, TSEL1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TSEL1` writer - DAC channel1 trigger selection
        pub struct TSEL1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEL1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TSEL1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Timer 6 TRGO event
            #[inline(always)]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM6_TRGO)
            }
            ///Timer 3 TRGO event
            #[inline(always)]
            pub fn tim3_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM3_TRGO)
            }
            ///Timer 7 TRGO event
            #[inline(always)]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM7_TRGO)
            }
            ///Timer 15 TRGO event
            #[inline(always)]
            pub fn tim15_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM15_TRGO)
            }
            ///Timer 2 TRGO event
            #[inline(always)]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL1_A::TIM2_TRGO)
            }
            ///EXTI line9
            #[inline(always)]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL1_A::EXTI9)
            }
            ///Software trigger
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL1_A::SOFTWARE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 3)) | ((value as u32 & 0x07) << 3);
                self.w
            }
        }
        ///DAC channel1 noise/triangle wave generation enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WAVE1_A {
            ///0: Wave generation disabled
            DISABLED = 0,
            ///1: Noise wave generation enabled
            NOISE = 1,
            ///2: Triangle wave generation enabled
            TRIANGLE = 2,
        }
        impl From<WAVE1_A> for u8 {
            #[inline(always)]
            fn from(variant: WAVE1_A) -> Self {
                variant as _
            }
        }
        ///Field `WAVE1` reader - DAC channel1 noise/triangle wave generation enable
        pub struct WAVE1_R(crate::FieldReader<u8, WAVE1_A>);
        impl WAVE1_R {
            pub(crate) fn new(bits: u8) -> Self {
                WAVE1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<WAVE1_A> {
                match self.bits {
                    0 => Some(WAVE1_A::DISABLED),
                    1 => Some(WAVE1_A::NOISE),
                    2 => Some(WAVE1_A::TRIANGLE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WAVE1_A::DISABLED
            }
            ///Checks if the value of the field is `NOISE`
            #[inline(always)]
            pub fn is_noise(&self) -> bool {
                **self == WAVE1_A::NOISE
            }
            ///Checks if the value of the field is `TRIANGLE`
            #[inline(always)]
            pub fn is_triangle(&self) -> bool {
                **self == WAVE1_A::TRIANGLE
            }
        }
        impl core::ops::Deref for WAVE1_R {
            type Target = crate::FieldReader<u8, WAVE1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAVE1` writer - DAC channel1 noise/triangle wave generation enable
        pub struct WAVE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVE1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAVE1_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Wave generation disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE1_A::DISABLED)
            }
            ///Noise wave generation enabled
            #[inline(always)]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE1_A::NOISE)
            }
            ///Triangle wave generation enabled
            #[inline(always)]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE1_A::TRIANGLE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | ((value as u32 & 0x03) << 6);
                self.w
            }
        }
        ///Field `MAMP1` reader - DAC channel1 mask/amplitude selector
        pub struct MAMP1_R(crate::FieldReader<u8, u8>);
        impl MAMP1_R {
            pub(crate) fn new(bits: u8) -> Self {
                MAMP1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MAMP1_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MAMP1` writer - DAC channel1 mask/amplitude selector
        pub struct MAMP1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MAMP1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 8)) | ((value as u32 & 0x0f) << 8);
                self.w
            }
        }
        ///DAC channel1 DMA enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAEN1_A {
            ///0: DAC channel X DMA mode disabled
            DISABLED = 0,
            ///1: DAC channel X DMA mode enabled
            ENABLED = 1,
        }
        impl From<DMAEN1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAEN1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAEN1` reader - DAC channel1 DMA enable
        pub struct DMAEN1_R(crate::FieldReader<bool, DMAEN1_A>);
        impl DMAEN1_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAEN1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAEN1_A {
                match self.bits {
                    false => DMAEN1_A::DISABLED,
                    true => DMAEN1_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAEN1_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAEN1_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAEN1_R {
            type Target = crate::FieldReader<bool, DMAEN1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAEN1` writer - DAC channel1 DMA enable
        pub struct DMAEN1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAEN1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X DMA mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::DISABLED)
            }
            ///DAC channel X DMA mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///DAC channel2 enable
        pub type EN2_A = EN1_A;
        ///Field `EN2` reader - DAC channel2 enable
        pub type EN2_R = EN1_R;
        ///Field `EN2` writer - DAC channel2 enable
        pub struct EN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EN2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EN2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EN2_A::DISABLED)
            }
            ///DAC channel X enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EN2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///DAC channel2 output buffer disable
        pub type BOFF2_A = BOFF1_A;
        ///Field `BOFF2` reader - DAC channel2 output buffer disable
        pub type BOFF2_R = BOFF1_R;
        ///Field `BOFF2` writer - DAC channel2 output buffer disable
        pub struct BOFF2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BOFF2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BOFF2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X output buffer enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BOFF2_A::ENABLED)
            }
            ///DAC channel X output buffer disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BOFF2_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 17)) | ((value as u32 & 0x01) << 17);
                self.w
            }
        }
        ///DAC channel2 trigger enable
        pub type TEN2_A = TEN1_A;
        ///Field `TEN2` reader - DAC channel2 trigger enable
        pub type TEN2_R = TEN1_R;
        ///Field `TEN2` writer - DAC channel2 trigger enable
        pub struct TEN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEN2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TEN2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TEN2_A::DISABLED)
            }
            ///DAC channel X trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TEN2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///DAC channel2 trigger selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum TSEL2_A {
            ///0: Timer 6 TRGO event
            TIM6_TRGO = 0,
            ///1: Timer 8 TRGO event
            TIM8_TRGO = 1,
            ///2: Timer 7 TRGO event
            TIM7_TRGO = 2,
            ///3: Timer 5 TRGO event
            TIM5_TRGO = 3,
            ///4: Timer 2 TRGO event
            TIM2_TRGO = 4,
            ///5: Timer 4 TRGO event
            TIM4_TRGO = 5,
            ///6: EXTI line9
            EXTI9 = 6,
            ///7: Software trigger
            SOFTWARE = 7,
        }
        impl From<TSEL2_A> for u8 {
            #[inline(always)]
            fn from(variant: TSEL2_A) -> Self {
                variant as _
            }
        }
        ///Field `TSEL2` reader - DAC channel2 trigger selection
        pub struct TSEL2_R(crate::FieldReader<u8, TSEL2_A>);
        impl TSEL2_R {
            pub(crate) fn new(bits: u8) -> Self {
                TSEL2_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TSEL2_A {
                match self.bits {
                    0 => TSEL2_A::TIM6_TRGO,
                    1 => TSEL2_A::TIM8_TRGO,
                    2 => TSEL2_A::TIM7_TRGO,
                    3 => TSEL2_A::TIM5_TRGO,
                    4 => TSEL2_A::TIM2_TRGO,
                    5 => TSEL2_A::TIM4_TRGO,
                    6 => TSEL2_A::EXTI9,
                    7 => TSEL2_A::SOFTWARE,
                    _ => unreachable!(),
                }
            }
            ///Checks if the value of the field is `TIM6_TRGO`
            #[inline(always)]
            pub fn is_tim6_trgo(&self) -> bool {
                **self == TSEL2_A::TIM6_TRGO
            }
            ///Checks if the value of the field is `TIM8_TRGO`
            #[inline(always)]
            pub fn is_tim8_trgo(&self) -> bool {
                **self == TSEL2_A::TIM8_TRGO
            }
            ///Checks if the value of the field is `TIM7_TRGO`
            #[inline(always)]
            pub fn is_tim7_trgo(&self) -> bool {
                **self == TSEL2_A::TIM7_TRGO
            }
            ///Checks if the value of the field is `TIM5_TRGO`
            #[inline(always)]
            pub fn is_tim5_trgo(&self) -> bool {
                **self == TSEL2_A::TIM5_TRGO
            }
            ///Checks if the value of the field is `TIM2_TRGO`
            #[inline(always)]
            pub fn is_tim2_trgo(&self) -> bool {
                **self == TSEL2_A::TIM2_TRGO
            }
            ///Checks if the value of the field is `TIM4_TRGO`
            #[inline(always)]
            pub fn is_tim4_trgo(&self) -> bool {
                **self == TSEL2_A::TIM4_TRGO
            }
            ///Checks if the value of the field is `EXTI9`
            #[inline(always)]
            pub fn is_exti9(&self) -> bool {
                **self == TSEL2_A::EXTI9
            }
            ///Checks if the value of the field is `SOFTWARE`
            #[inline(always)]
            pub fn is_software(&self) -> bool {
                **self == TSEL2_A::SOFTWARE
            }
        }
        impl core::ops::Deref for TSEL2_R {
            type Target = crate::FieldReader<u8, TSEL2_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TSEL2` writer - DAC channel2 trigger selection
        pub struct TSEL2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSEL2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TSEL2_A) -> &'a mut W {
                self.bits(variant.into())
            }
            ///Timer 6 TRGO event
            #[inline(always)]
            pub fn tim6_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM6_TRGO)
            }
            ///Timer 8 TRGO event
            #[inline(always)]
            pub fn tim8_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM8_TRGO)
            }
            ///Timer 7 TRGO event
            #[inline(always)]
            pub fn tim7_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM7_TRGO)
            }
            ///Timer 5 TRGO event
            #[inline(always)]
            pub fn tim5_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM5_TRGO)
            }
            ///Timer 2 TRGO event
            #[inline(always)]
            pub fn tim2_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM2_TRGO)
            }
            ///Timer 4 TRGO event
            #[inline(always)]
            pub fn tim4_trgo(self) -> &'a mut W {
                self.variant(TSEL2_A::TIM4_TRGO)
            }
            ///EXTI line9
            #[inline(always)]
            pub fn exti9(self) -> &'a mut W {
                self.variant(TSEL2_A::EXTI9)
            }
            ///Software trigger
            #[inline(always)]
            pub fn software(self) -> &'a mut W {
                self.variant(TSEL2_A::SOFTWARE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 19)) | ((value as u32 & 0x07) << 19);
                self.w
            }
        }
        ///DAC channel2 noise/triangle wave generation enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum WAVE2_A {
            ///0: Wave generation disabled
            DISABLED = 0,
            ///1: Noise wave generation enabled
            NOISE = 1,
            ///2: Triangle wave generation enabled
            TRIANGLE = 2,
        }
        impl From<WAVE2_A> for u8 {
            #[inline(always)]
            fn from(variant: WAVE2_A) -> Self {
                variant as _
            }
        }
        ///Field `WAVE2` reader - DAC channel2 noise/triangle wave generation enable
        pub struct WAVE2_R(crate::FieldReader<u8, WAVE2_A>);
        impl WAVE2_R {
            pub(crate) fn new(bits: u8) -> Self {
                WAVE2_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<WAVE2_A> {
                match self.bits {
                    0 => Some(WAVE2_A::DISABLED),
                    1 => Some(WAVE2_A::NOISE),
                    2 => Some(WAVE2_A::TRIANGLE),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == WAVE2_A::DISABLED
            }
            ///Checks if the value of the field is `NOISE`
            #[inline(always)]
            pub fn is_noise(&self) -> bool {
                **self == WAVE2_A::NOISE
            }
            ///Checks if the value of the field is `TRIANGLE`
            #[inline(always)]
            pub fn is_triangle(&self) -> bool {
                **self == WAVE2_A::TRIANGLE
            }
        }
        impl core::ops::Deref for WAVE2_R {
            type Target = crate::FieldReader<u8, WAVE2_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAVE2` writer - DAC channel2 noise/triangle wave generation enable
        pub struct WAVE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAVE2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAVE2_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///Wave generation disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(WAVE2_A::DISABLED)
            }
            ///Noise wave generation enabled
            #[inline(always)]
            pub fn noise(self) -> &'a mut W {
                self.variant(WAVE2_A::NOISE)
            }
            ///Triangle wave generation enabled
            #[inline(always)]
            pub fn triangle(self) -> &'a mut W {
                self.variant(WAVE2_A::TRIANGLE)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 22)) | ((value as u32 & 0x03) << 22);
                self.w
            }
        }
        ///Field `MAMP2` reader - DAC channel2 mask/amplitude selector
        pub struct MAMP2_R(crate::FieldReader<u8, u8>);
        impl MAMP2_R {
            pub(crate) fn new(bits: u8) -> Self {
                MAMP2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MAMP2_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MAMP2` writer - DAC channel2 mask/amplitude selector
        pub struct MAMP2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MAMP2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 24)) | ((value as u32 & 0x0f) << 24);
                self.w
            }
        }
        ///DAC channel2 DMA enable
        pub type DMAEN2_A = DMAEN1_A;
        ///Field `DMAEN2` reader - DAC channel2 DMA enable
        pub type DMAEN2_R = DMAEN1_R;
        ///Field `DMAEN2` writer - DAC channel2 DMA enable
        pub struct DMAEN2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAEN2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAEN2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X DMA mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAEN2_A::DISABLED)
            }
            ///DAC channel X DMA mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAEN2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 28)) | ((value as u32 & 0x01) << 28);
                self.w
            }
        }
        ///DAC channel1 DMA underrun interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDRIE1_A {
            ///0: DAC channel X DMA Underrun Interrupt disabled
            DISABLED = 0,
            ///1: DAC channel X DMA Underrun Interrupt enabled
            ENABLED = 1,
        }
        impl From<DMAUDRIE1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAUDRIE1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAUDRIE1` reader - DAC channel1 DMA underrun interrupt enable
        pub struct DMAUDRIE1_R(crate::FieldReader<bool, DMAUDRIE1_A>);
        impl DMAUDRIE1_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAUDRIE1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAUDRIE1_A {
                match self.bits {
                    false => DMAUDRIE1_A::DISABLED,
                    true => DMAUDRIE1_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAUDRIE1_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAUDRIE1_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAUDRIE1_R {
            type Target = crate::FieldReader<bool, DMAUDRIE1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAUDRIE1` writer - DAC channel1 DMA underrun interrupt enable
        pub struct DMAUDRIE1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDRIE1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAUDRIE1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X DMA Underrun Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::DISABLED)
            }
            ///DAC channel X DMA Underrun Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE1_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///DAC channel2 DMA underrun interrupt enable
        pub type DMAUDRIE2_A = DMAUDRIE1_A;
        ///Field `DMAUDRIE2` reader - DAC channel2 DMA underrun interrupt enable
        pub type DMAUDRIE2_R = DMAUDRIE1_R;
        ///Field `DMAUDRIE2` writer - DAC channel2 DMA underrun interrupt enable
        pub struct DMAUDRIE2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDRIE2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAUDRIE2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X DMA Underrun Interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAUDRIE2_A::DISABLED)
            }
            ///DAC channel X DMA Underrun Interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAUDRIE2_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        impl R {
            ///Bit 0 - DAC channel1 enable
            #[inline(always)]
            pub fn en1(&self) -> EN1_R {
                EN1_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - DAC channel1 output buffer disable
            #[inline(always)]
            pub fn boff1(&self) -> BOFF1_R {
                BOFF1_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - DAC channel1 trigger enable
            #[inline(always)]
            pub fn ten1(&self) -> TEN1_R {
                TEN1_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 3:5 - DAC channel1 trigger selection
            #[inline(always)]
            pub fn tsel1(&self) -> TSEL1_R {
                TSEL1_R::new(((self.bits >> 3) & 0x07) as u8)
            }
            ///Bits 6:7 - DAC channel1 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave1(&self) -> WAVE1_R {
                WAVE1_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            ///Bits 8:11 - DAC channel1 mask/amplitude selector
            #[inline(always)]
            pub fn mamp1(&self) -> MAMP1_R {
                MAMP1_R::new(((self.bits >> 8) & 0x0f) as u8)
            }
            ///Bit 12 - DAC channel1 DMA enable
            #[inline(always)]
            pub fn dmaen1(&self) -> DMAEN1_R {
                DMAEN1_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 16 - DAC channel2 enable
            #[inline(always)]
            pub fn en2(&self) -> EN2_R {
                EN2_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 17 - DAC channel2 output buffer disable
            #[inline(always)]
            pub fn boff2(&self) -> BOFF2_R {
                BOFF2_R::new(((self.bits >> 17) & 0x01) != 0)
            }
            ///Bit 18 - DAC channel2 trigger enable
            #[inline(always)]
            pub fn ten2(&self) -> TEN2_R {
                TEN2_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bits 19:21 - DAC channel2 trigger selection
            #[inline(always)]
            pub fn tsel2(&self) -> TSEL2_R {
                TSEL2_R::new(((self.bits >> 19) & 0x07) as u8)
            }
            ///Bits 22:23 - DAC channel2 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave2(&self) -> WAVE2_R {
                WAVE2_R::new(((self.bits >> 22) & 0x03) as u8)
            }
            ///Bits 24:27 - DAC channel2 mask/amplitude selector
            #[inline(always)]
            pub fn mamp2(&self) -> MAMP2_R {
                MAMP2_R::new(((self.bits >> 24) & 0x0f) as u8)
            }
            ///Bit 28 - DAC channel2 DMA enable
            #[inline(always)]
            pub fn dmaen2(&self) -> DMAEN2_R {
                DMAEN2_R::new(((self.bits >> 28) & 0x01) != 0)
            }
            ///Bit 13 - DAC channel1 DMA underrun interrupt enable
            #[inline(always)]
            pub fn dmaudrie1(&self) -> DMAUDRIE1_R {
                DMAUDRIE1_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 29 - DAC channel2 DMA underrun interrupt enable
            #[inline(always)]
            pub fn dmaudrie2(&self) -> DMAUDRIE2_R {
                DMAUDRIE2_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - DAC channel1 enable
            #[inline(always)]
            pub fn en1(&mut self) -> EN1_W {
                EN1_W { w: self }
            }
            ///Bit 1 - DAC channel1 output buffer disable
            #[inline(always)]
            pub fn boff1(&mut self) -> BOFF1_W {
                BOFF1_W { w: self }
            }
            ///Bit 2 - DAC channel1 trigger enable
            #[inline(always)]
            pub fn ten1(&mut self) -> TEN1_W {
                TEN1_W { w: self }
            }
            ///Bits 3:5 - DAC channel1 trigger selection
            #[inline(always)]
            pub fn tsel1(&mut self) -> TSEL1_W {
                TSEL1_W { w: self }
            }
            ///Bits 6:7 - DAC channel1 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave1(&mut self) -> WAVE1_W {
                WAVE1_W { w: self }
            }
            ///Bits 8:11 - DAC channel1 mask/amplitude selector
            #[inline(always)]
            pub fn mamp1(&mut self) -> MAMP1_W {
                MAMP1_W { w: self }
            }
            ///Bit 12 - DAC channel1 DMA enable
            #[inline(always)]
            pub fn dmaen1(&mut self) -> DMAEN1_W {
                DMAEN1_W { w: self }
            }
            ///Bit 16 - DAC channel2 enable
            #[inline(always)]
            pub fn en2(&mut self) -> EN2_W {
                EN2_W { w: self }
            }
            ///Bit 17 - DAC channel2 output buffer disable
            #[inline(always)]
            pub fn boff2(&mut self) -> BOFF2_W {
                BOFF2_W { w: self }
            }
            ///Bit 18 - DAC channel2 trigger enable
            #[inline(always)]
            pub fn ten2(&mut self) -> TEN2_W {
                TEN2_W { w: self }
            }
            ///Bits 19:21 - DAC channel2 trigger selection
            #[inline(always)]
            pub fn tsel2(&mut self) -> TSEL2_W {
                TSEL2_W { w: self }
            }
            ///Bits 22:23 - DAC channel2 noise/triangle wave generation enable
            #[inline(always)]
            pub fn wave2(&mut self) -> WAVE2_W {
                WAVE2_W { w: self }
            }
            ///Bits 24:27 - DAC channel2 mask/amplitude selector
            #[inline(always)]
            pub fn mamp2(&mut self) -> MAMP2_W {
                MAMP2_W { w: self }
            }
            ///Bit 28 - DAC channel2 DMA enable
            #[inline(always)]
            pub fn dmaen2(&mut self) -> DMAEN2_W {
                DMAEN2_W { w: self }
            }
            ///Bit 13 - DAC channel1 DMA underrun interrupt enable
            #[inline(always)]
            pub fn dmaudrie1(&mut self) -> DMAUDRIE1_W {
                DMAUDRIE1_W { w: self }
            }
            ///Bit 29 - DAC channel2 DMA underrun interrupt enable
            #[inline(always)]
            pub fn dmaudrie2(&mut self) -> DMAUDRIE2_W {
                DMAUDRIE2_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register (DAC_CR)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SWTRIGR register accessor: an alias for `Reg<SWTRIGR_SPEC>`
    pub type SWTRIGR = crate::Reg<swtrigr::SWTRIGR_SPEC>;
    ///DAC software trigger register (DAC_SWTRIGR)
    pub mod swtrigr {
        ///Register `SWTRIGR` writer
        pub struct W(crate::W<SWTRIGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SWTRIGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SWTRIGR_SPEC>> for W {
            fn from(writer: crate::W<SWTRIGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///DAC channel1 software trigger
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SWTRIG1_AW {
            ///0: DAC channel X software trigger disabled
            DISABLED = 0,
            ///1: DAC channel X software trigger enabled
            ENABLED = 1,
        }
        impl From<SWTRIG1_AW> for bool {
            #[inline(always)]
            fn from(variant: SWTRIG1_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SWTRIG1` writer - DAC channel1 software trigger
        pub struct SWTRIG1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWTRIG1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWTRIG1_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X software trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::DISABLED)
            }
            ///DAC channel X software trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG1_AW::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///DAC channel2 software trigger
        pub type SWTRIG2_AW = SWTRIG1_AW;
        ///Field `SWTRIG2` writer - DAC channel2 software trigger
        pub struct SWTRIG2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SWTRIG2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SWTRIG2_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DAC channel X software trigger disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(SWTRIG2_AW::DISABLED)
            }
            ///DAC channel X software trigger enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(SWTRIG2_AW::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        impl W {
            ///Bit 0 - DAC channel1 software trigger
            #[inline(always)]
            pub fn swtrig1(&mut self) -> SWTRIG1_W {
                SWTRIG1_W { w: self }
            }
            ///Bit 1 - DAC channel2 software trigger
            #[inline(always)]
            pub fn swtrig2(&mut self) -> SWTRIG2_W {
                SWTRIG2_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC software trigger register (DAC_SWTRIGR)
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [swtrigr](index.html) module
        pub struct SWTRIGR_SPEC;
        impl crate::RegisterSpec for SWTRIGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [swtrigr::W](W) writer structure
        impl crate::Writable for SWTRIGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SWTRIGR to value 0
        impl crate::Resettable for SWTRIGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12R1 register accessor: an alias for `Reg<DHR12R1_SPEC>`
    pub type DHR12R1 = crate::Reg<dhr12r1::DHR12R1_SPEC>;
    ///DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)
    pub mod dhr12r1 {
        ///Register `DHR12R1` reader
        pub struct R(crate::R<DHR12R1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12R1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12R1_SPEC>> for R {
            fn from(reader: crate::R<DHR12R1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12R1` writer
        pub struct W(crate::W<DHR12R1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12R1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12R1_SPEC>> for W {
            fn from(writer: crate::W<DHR12R1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit right-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u16, u16>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 12-bit right-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel1 12-bit right-aligned data holding register(DAC_DHR12R1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12r1](index.html) module
        pub struct DHR12R1_SPEC;
        impl crate::RegisterSpec for DHR12R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12r1::R](R) reader structure
        impl crate::Readable for DHR12R1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12r1::W](W) writer structure
        impl crate::Writable for DHR12R1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12R1 to value 0
        impl crate::Resettable for DHR12R1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12L1 register accessor: an alias for `Reg<DHR12L1_SPEC>`
    pub type DHR12L1 = crate::Reg<dhr12l1::DHR12L1_SPEC>;
    ///DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)
    pub mod dhr12l1 {
        ///Register `DHR12L1` reader
        pub struct R(crate::R<DHR12L1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12L1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12L1_SPEC>> for R {
            fn from(reader: crate::R<DHR12L1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12L1` writer
        pub struct W(crate::W<DHR12L1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12L1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12L1_SPEC>> for W {
            fn from(writer: crate::W<DHR12L1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit left-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u16, u16>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 12-bit left-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | ((value as u32 & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel1 12-bit left aligned data holding register (DAC_DHR12L1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12l1](index.html) module
        pub struct DHR12L1_SPEC;
        impl crate::RegisterSpec for DHR12L1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12l1::R](R) reader structure
        impl crate::Readable for DHR12L1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12l1::W](W) writer structure
        impl crate::Writable for DHR12L1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12L1 to value 0
        impl crate::Resettable for DHR12L1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR8R1 register accessor: an alias for `Reg<DHR8R1_SPEC>`
    pub type DHR8R1 = crate::Reg<dhr8r1::DHR8R1_SPEC>;
    ///DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)
    pub mod dhr8r1 {
        ///Register `DHR8R1` reader
        pub struct R(crate::R<DHR8R1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR8R1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR8R1_SPEC>> for R {
            fn from(reader: crate::R<DHR8R1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR8R1` writer
        pub struct W(crate::W<DHR8R1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR8R1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR8R1_SPEC>> for W {
            fn from(writer: crate::W<DHR8R1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 8-bit right-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u8, u8>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u8) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 8-bit right-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - DAC channel1 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - DAC channel1 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel1 8-bit right aligned data holding register (DAC_DHR8R1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr8r1](index.html) module
        pub struct DHR8R1_SPEC;
        impl crate::RegisterSpec for DHR8R1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr8r1::R](R) reader structure
        impl crate::Readable for DHR8R1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr8r1::W](W) writer structure
        impl crate::Writable for DHR8R1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR8R1 to value 0
        impl crate::Resettable for DHR8R1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12R2 register accessor: an alias for `Reg<DHR12R2_SPEC>`
    pub type DHR12R2 = crate::Reg<dhr12r2::DHR12R2_SPEC>;
    ///DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)
    pub mod dhr12r2 {
        ///Register `DHR12R2` reader
        pub struct R(crate::R<DHR12R2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12R2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12R2_SPEC>> for R {
            fn from(reader: crate::R<DHR12R2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12R2` writer
        pub struct W(crate::W<DHR12R2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12R2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12R2_SPEC>> for W {
            fn from(writer: crate::W<DHR12R2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u16, u16>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel2 12-bit right aligned data holding register (DAC_DHR12R2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12r2](index.html) module
        pub struct DHR12R2_SPEC;
        impl crate::RegisterSpec for DHR12R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12r2::R](R) reader structure
        impl crate::Readable for DHR12R2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12r2::W](W) writer structure
        impl crate::Writable for DHR12R2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12R2 to value 0
        impl crate::Resettable for DHR12R2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12L2 register accessor: an alias for `Reg<DHR12L2_SPEC>`
    pub type DHR12L2 = crate::Reg<dhr12l2::DHR12L2_SPEC>;
    ///DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)
    pub mod dhr12l2 {
        ///Register `DHR12L2` reader
        pub struct R(crate::R<DHR12L2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12L2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12L2_SPEC>> for R {
            fn from(reader: crate::R<DHR12L2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12L2` writer
        pub struct W(crate::W<DHR12L2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12L2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12L2_SPEC>> for W {
            fn from(writer: crate::W<DHR12L2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit left-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u16, u16>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 12-bit left-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | ((value as u32 & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 4:15 - DAC channel2 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 4:15 - DAC channel2 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel2 12-bit left aligned data holding register (DAC_DHR12L2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12l2](index.html) module
        pub struct DHR12L2_SPEC;
        impl crate::RegisterSpec for DHR12L2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12l2::R](R) reader structure
        impl crate::Readable for DHR12L2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12l2::W](W) writer structure
        impl crate::Writable for DHR12L2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12L2 to value 0
        impl crate::Resettable for DHR12L2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR8R2 register accessor: an alias for `Reg<DHR8R2_SPEC>`
    pub type DHR8R2 = crate::Reg<dhr8r2::DHR8R2_SPEC>;
    ///DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)
    pub mod dhr8r2 {
        ///Register `DHR8R2` reader
        pub struct R(crate::R<DHR8R2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR8R2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR8R2_SPEC>> for R {
            fn from(reader: crate::R<DHR8R2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR8R2` writer
        pub struct W(crate::W<DHR8R2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR8R2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR8R2_SPEC>> for W {
            fn from(writer: crate::W<DHR8R2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 8-bit right-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u8, u8>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u8) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 8-bit right-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - DAC channel2 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - DAC channel2 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC channel2 8-bit right-aligned data holding register (DAC_DHR8R2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr8r2](index.html) module
        pub struct DHR8R2_SPEC;
        impl crate::RegisterSpec for DHR8R2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr8r2::R](R) reader structure
        impl crate::Readable for DHR8R2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr8r2::W](W) writer structure
        impl crate::Writable for DHR8R2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR8R2 to value 0
        impl crate::Resettable for DHR8R2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12RD register accessor: an alias for `Reg<DHR12RD_SPEC>`
    pub type DHR12RD = crate::Reg<dhr12rd::DHR12RD_SPEC>;
    ///Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved
    pub mod dhr12rd {
        ///Register `DHR12RD` reader
        pub struct R(crate::R<DHR12RD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12RD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12RD_SPEC>> for R {
            fn from(reader: crate::R<DHR12RD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12RD` writer
        pub struct W(crate::W<DHR12RD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12RD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12RD_SPEC>> for W {
            fn from(writer: crate::W<DHR12RD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit right-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u16, u16>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 12-bit right-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0fff) | (value as u32 & 0x0fff);
                self.w
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u16, u16>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 16)) | ((value as u32 & 0x0fff) << 16);
                self.w
            }
        }
        impl R {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0x0fff) as u16)
            }
            ///Bits 16:27 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 16) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:11 - DAC channel1 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Bits 16:27 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Dual DAC 12-bit right-aligned data holding register (DAC_DHR12RD), Bits 31:28 Reserved, Bits 15:12 Reserved
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12rd](index.html) module
        pub struct DHR12RD_SPEC;
        impl crate::RegisterSpec for DHR12RD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12rd::R](R) reader structure
        impl crate::Readable for DHR12RD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12rd::W](W) writer structure
        impl crate::Writable for DHR12RD_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12RD to value 0
        impl crate::Resettable for DHR12RD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR12LD register accessor: an alias for `Reg<DHR12LD_SPEC>`
    pub type DHR12LD = crate::Reg<dhr12ld::DHR12LD_SPEC>;
    ///DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved
    pub mod dhr12ld {
        ///Register `DHR12LD` reader
        pub struct R(crate::R<DHR12LD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR12LD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR12LD_SPEC>> for R {
            fn from(reader: crate::R<DHR12LD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR12LD` writer
        pub struct W(crate::W<DHR12LD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR12LD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR12LD_SPEC>> for W {
            fn from(writer: crate::W<DHR12LD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 12-bit left-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u16, u16>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 12-bit left-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | ((value as u32 & 0x0fff) << 4);
                self.w
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u16, u16>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 12-bit right-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 20)) | ((value as u32 & 0x0fff) << 20);
                self.w
            }
        }
        impl R {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
            ///Bits 20:31 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 20) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 4:15 - DAC channel1 12-bit left-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Bits 20:31 - DAC channel2 12-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DUAL DAC 12-bit left aligned data holding register (DAC_DHR12LD), Bits 19:16 Reserved, Bits 3:0 Reserved
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr12ld](index.html) module
        pub struct DHR12LD_SPEC;
        impl crate::RegisterSpec for DHR12LD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr12ld::R](R) reader structure
        impl crate::Readable for DHR12LD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr12ld::W](W) writer structure
        impl crate::Writable for DHR12LD_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR12LD to value 0
        impl crate::Resettable for DHR12LD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DHR8RD register accessor: an alias for `Reg<DHR8RD_SPEC>`
    pub type DHR8RD = crate::Reg<dhr8rd::DHR8RD_SPEC>;
    ///DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved
    pub mod dhr8rd {
        ///Register `DHR8RD` reader
        pub struct R(crate::R<DHR8RD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DHR8RD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DHR8RD_SPEC>> for R {
            fn from(reader: crate::R<DHR8RD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DHR8RD` writer
        pub struct W(crate::W<DHR8RD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DHR8RD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DHR8RD_SPEC>> for W {
            fn from(writer: crate::W<DHR8RD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DACC1DHR` reader - DAC channel1 8-bit right-aligned data
        pub struct DACC1DHR_R(crate::FieldReader<u8, u8>);
        impl DACC1DHR_R {
            pub(crate) fn new(bits: u8) -> Self {
                DACC1DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DHR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC1DHR` writer - DAC channel1 8-bit right-aligned data
        pub struct DACC1DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC1DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        ///Field `DACC2DHR` reader - DAC channel2 8-bit right-aligned data
        pub struct DACC2DHR_R(crate::FieldReader<u8, u8>);
        impl DACC2DHR_R {
            pub(crate) fn new(bits: u8) -> Self {
                DACC2DHR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DHR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DACC2DHR` writer - DAC channel2 8-bit right-aligned data
        pub struct DACC2DHR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DACC2DHR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0xff << 8)) | ((value as u32 & 0xff) << 8);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - DAC channel1 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&self) -> DACC1DHR_R {
                DACC1DHR_R::new((self.bits & 0xff) as u8)
            }
            ///Bits 8:15 - DAC channel2 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&self) -> DACC2DHR_R {
                DACC2DHR_R::new(((self.bits >> 8) & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - DAC channel1 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc1dhr(&mut self) -> DACC1DHR_W {
                DACC1DHR_W { w: self }
            }
            ///Bits 8:15 - DAC channel2 8-bit right-aligned data
            #[inline(always)]
            pub fn dacc2dhr(&mut self) -> DACC2DHR_W {
                DACC2DHR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DUAL DAC 8-bit right aligned data holding register (DAC_DHR8RD), Bits 31:16 Reserved
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dhr8rd](index.html) module
        pub struct DHR8RD_SPEC;
        impl crate::RegisterSpec for DHR8RD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dhr8rd::R](R) reader structure
        impl crate::Readable for DHR8RD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dhr8rd::W](W) writer structure
        impl crate::Writable for DHR8RD_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DHR8RD to value 0
        impl crate::Resettable for DHR8RD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DOR1 register accessor: an alias for `Reg<DOR1_SPEC>`
    pub type DOR1 = crate::Reg<dor1::DOR1_SPEC>;
    ///DAC channel1 data output register (DAC_DOR1)
    pub mod dor1 {
        ///Register `DOR1` reader
        pub struct R(crate::R<DOR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DOR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DOR1_SPEC>> for R {
            fn from(reader: crate::R<DOR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DACC1DOR` reader - DAC channel1 data output
        pub struct DACC1DOR_R(crate::FieldReader<u16, u16>);
        impl DACC1DOR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC1DOR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC1DOR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:11 - DAC channel1 data output
            #[inline(always)]
            pub fn dacc1dor(&self) -> DACC1DOR_R {
                DACC1DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        ///DAC channel1 data output register (DAC_DOR1)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dor1](index.html) module
        pub struct DOR1_SPEC;
        impl crate::RegisterSpec for DOR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dor1::R](R) reader structure
        impl crate::Readable for DOR1_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DOR1 to value 0
        impl crate::Resettable for DOR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DOR2 register accessor: an alias for `Reg<DOR2_SPEC>`
    pub type DOR2 = crate::Reg<dor2::DOR2_SPEC>;
    ///DAC channel2 data output register (DAC_DOR2)
    pub mod dor2 {
        ///Register `DOR2` reader
        pub struct R(crate::R<DOR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DOR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DOR2_SPEC>> for R {
            fn from(reader: crate::R<DOR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DACC2DOR` reader - DAC channel2 data output
        pub struct DACC2DOR_R(crate::FieldReader<u16, u16>);
        impl DACC2DOR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DACC2DOR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DACC2DOR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:11 - DAC channel2 data output
            #[inline(always)]
            pub fn dacc2dor(&self) -> DACC2DOR_R {
                DACC2DOR_R::new((self.bits & 0x0fff) as u16)
            }
        }
        ///DAC channel2 data output register (DAC_DOR2)
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dor2](index.html) module
        pub struct DOR2_SPEC;
        impl crate::RegisterSpec for DOR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dor2::R](R) reader structure
        impl crate::Readable for DOR2_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets DOR2 to value 0
        impl crate::Resettable for DOR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///DAC status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///DAC channel1 DMA underrun flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAUDR1_A {
            ///0: No DMA underrun error condition occurred for DAC channel X
            NOUNDERRUN = 0,
            ///1: DMA underrun error condition occurred for DAC channel X
            UNDERRUN = 1,
        }
        impl From<DMAUDR1_A> for bool {
            #[inline(always)]
            fn from(variant: DMAUDR1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAUDR1` reader - DAC channel1 DMA underrun flag
        pub struct DMAUDR1_R(crate::FieldReader<bool, DMAUDR1_A>);
        impl DMAUDR1_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAUDR1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAUDR1_A {
                match self.bits {
                    false => DMAUDR1_A::NOUNDERRUN,
                    true => DMAUDR1_A::UNDERRUN,
                }
            }
            ///Checks if the value of the field is `NOUNDERRUN`
            #[inline(always)]
            pub fn is_no_underrun(&self) -> bool {
                **self == DMAUDR1_A::NOUNDERRUN
            }
            ///Checks if the value of the field is `UNDERRUN`
            #[inline(always)]
            pub fn is_underrun(&self) -> bool {
                **self == DMAUDR1_A::UNDERRUN
            }
        }
        impl core::ops::Deref for DMAUDR1_R {
            type Target = crate::FieldReader<bool, DMAUDR1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAUDR1` writer - DAC channel1 DMA underrun flag
        pub struct DMAUDR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDR1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAUDR1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No DMA underrun error condition occurred for DAC channel X
            #[inline(always)]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::NOUNDERRUN)
            }
            ///DMA underrun error condition occurred for DAC channel X
            #[inline(always)]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR1_A::UNDERRUN)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///DAC channel2 DMA underrun flag
        pub type DMAUDR2_A = DMAUDR1_A;
        ///Field `DMAUDR2` reader - DAC channel2 DMA underrun flag
        pub type DMAUDR2_R = DMAUDR1_R;
        ///Field `DMAUDR2` writer - DAC channel2 DMA underrun flag
        pub struct DMAUDR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAUDR2_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAUDR2_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No DMA underrun error condition occurred for DAC channel X
            #[inline(always)]
            pub fn no_underrun(self) -> &'a mut W {
                self.variant(DMAUDR2_A::NOUNDERRUN)
            }
            ///DMA underrun error condition occurred for DAC channel X
            #[inline(always)]
            pub fn underrun(self) -> &'a mut W {
                self.variant(DMAUDR2_A::UNDERRUN)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 29)) | ((value as u32 & 0x01) << 29);
                self.w
            }
        }
        impl R {
            ///Bit 13 - DAC channel1 DMA underrun flag
            #[inline(always)]
            pub fn dmaudr1(&self) -> DMAUDR1_R {
                DMAUDR1_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 29 - DAC channel2 DMA underrun flag
            #[inline(always)]
            pub fn dmaudr2(&self) -> DMAUDR2_R {
                DMAUDR2_R::new(((self.bits >> 29) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 13 - DAC channel1 DMA underrun flag
            #[inline(always)]
            pub fn dmaudr1(&mut self) -> DMAUDR1_W {
                DMAUDR1_W { w: self }
            }
            ///Bit 29 - DAC channel2 DMA underrun flag
            #[inline(always)]
            pub fn dmaudr2(&mut self) -> DMAUDR2_W {
                DMAUDR2_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DAC status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Debug support
pub struct DBGMCU {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for DBGMCU {}
impl DBGMCU {
    ///Pointer to the register block
    pub const PTR: *const dbgmcu::RegisterBlock = 0xe004_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const dbgmcu::RegisterBlock {
        Self::PTR
    }
}
impl Deref for DBGMCU {
    type Target = dbgmcu::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for DBGMCU {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("DBGMCU").finish()
    }
}
///Debug support
pub mod dbgmcu {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - DBGMCU_IDCODE
        pub idcode: crate::Reg<idcode::IDCODE_SPEC>,
        ///0x04 - DBGMCU_CR
        pub cr: crate::Reg<cr::CR_SPEC>,
    }
    ///IDCODE register accessor: an alias for `Reg<IDCODE_SPEC>`
    pub type IDCODE = crate::Reg<idcode::IDCODE_SPEC>;
    ///DBGMCU_IDCODE
    pub mod idcode {
        ///Register `IDCODE` reader
        pub struct R(crate::R<IDCODE_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDCODE_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<IDCODE_SPEC>> for R {
            fn from(reader: crate::R<IDCODE_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `DEV_ID` reader - DEV_ID
        pub struct DEV_ID_R(crate::FieldReader<u16, u16>);
        impl DEV_ID_R {
            pub(crate) fn new(bits: u16) -> Self {
                DEV_ID_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DEV_ID_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `REV_ID` reader - REV_ID
        pub struct REV_ID_R(crate::FieldReader<u16, u16>);
        impl REV_ID_R {
            pub(crate) fn new(bits: u16) -> Self {
                REV_ID_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for REV_ID_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:11 - DEV_ID
            #[inline(always)]
            pub fn dev_id(&self) -> DEV_ID_R {
                DEV_ID_R::new((self.bits & 0x0fff) as u16)
            }
            ///Bits 16:31 - REV_ID
            #[inline(always)]
            pub fn rev_id(&self) -> REV_ID_R {
                REV_ID_R::new(((self.bits >> 16) & 0xffff) as u16)
            }
        }
        ///DBGMCU_IDCODE
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idcode](index.html) module
        pub struct IDCODE_SPEC;
        impl crate::RegisterSpec for IDCODE_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idcode::R](R) reader structure
        impl crate::Readable for IDCODE_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets IDCODE to value 0
        impl crate::Resettable for IDCODE_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///DBGMCU_CR
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBG_SLEEP` reader - DBG_SLEEP
        pub struct DBG_SLEEP_R(crate::FieldReader<bool, bool>);
        impl DBG_SLEEP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_SLEEP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_SLEEP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_SLEEP` writer - DBG_SLEEP
        pub struct DBG_SLEEP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_SLEEP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `DBG_STOP` reader - DBG_STOP
        pub struct DBG_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_STOP` writer - DBG_STOP
        pub struct DBG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `DBG_STANDBY` reader - DBG_STANDBY
        pub struct DBG_STANDBY_R(crate::FieldReader<bool, bool>);
        impl DBG_STANDBY_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_STANDBY_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_STANDBY_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_STANDBY` writer - DBG_STANDBY
        pub struct DBG_STANDBY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_STANDBY_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `TRACE_IOEN` reader - TRACE_IOEN
        pub struct TRACE_IOEN_R(crate::FieldReader<bool, bool>);
        impl TRACE_IOEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                TRACE_IOEN_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TRACE_IOEN_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TRACE_IOEN` writer - TRACE_IOEN
        pub struct TRACE_IOEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRACE_IOEN_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `TRACE_MODE` reader - TRACE_MODE
        pub struct TRACE_MODE_R(crate::FieldReader<u8, u8>);
        impl TRACE_MODE_R {
            pub(crate) fn new(bits: u8) -> Self {
                TRACE_MODE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TRACE_MODE_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TRACE_MODE` writer - TRACE_MODE
        pub struct TRACE_MODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TRACE_MODE_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 6)) | ((value as u32 & 0x03) << 6);
                self.w
            }
        }
        ///Field `DBG_IWDG_STOP` reader - DBG_IWDG_STOP
        pub struct DBG_IWDG_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_IWDG_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_IWDG_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_IWDG_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_IWDG_STOP` writer - DBG_IWDG_STOP
        pub struct DBG_IWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_IWDG_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `DBG_WWDG_STOP` reader - DBG_WWDG_STOP
        pub struct DBG_WWDG_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_WWDG_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_WWDG_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_WWDG_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_WWDG_STOP` writer - DBG_WWDG_STOP
        pub struct DBG_WWDG_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_WWDG_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `DBG_TIM1_STOP` reader - DBG_TIM1_STOP
        pub struct DBG_TIM1_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM1_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM1_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM1_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM1_STOP` writer - DBG_TIM1_STOP
        pub struct DBG_TIM1_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM1_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `DBG_TIM2_STOP` reader - DBG_TIM2_STOP
        pub struct DBG_TIM2_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM2_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM2_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM2_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM2_STOP` writer - DBG_TIM2_STOP
        pub struct DBG_TIM2_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM2_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `DBG_TIM3_STOP` reader - DBG_TIM3_STOP
        pub struct DBG_TIM3_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM3_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM3_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM3_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM3_STOP` writer - DBG_TIM3_STOP
        pub struct DBG_TIM3_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM3_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `DBG_TIM4_STOP` reader - DBG_TIM4_STOP
        pub struct DBG_TIM4_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM4_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM4_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM4_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM4_STOP` writer - DBG_TIM4_STOP
        pub struct DBG_TIM4_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM4_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `DBG_I2C1_SMBUS_TIMEOUT` reader - DBG_I2C1_SMBUS_TIMEOUT
        pub struct DBG_I2C1_SMBUS_TIMEOUT_R(crate::FieldReader<bool, bool>);
        impl DBG_I2C1_SMBUS_TIMEOUT_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_I2C1_SMBUS_TIMEOUT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_I2C1_SMBUS_TIMEOUT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_I2C1_SMBUS_TIMEOUT` writer - DBG_I2C1_SMBUS_TIMEOUT
        pub struct DBG_I2C1_SMBUS_TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C1_SMBUS_TIMEOUT_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `DBG_I2C2_SMBUS_TIMEOUT` reader - DBG_I2C2_SMBUS_TIMEOUT
        pub struct DBG_I2C2_SMBUS_TIMEOUT_R(crate::FieldReader<bool, bool>);
        impl DBG_I2C2_SMBUS_TIMEOUT_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_I2C2_SMBUS_TIMEOUT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_I2C2_SMBUS_TIMEOUT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_I2C2_SMBUS_TIMEOUT` writer - DBG_I2C2_SMBUS_TIMEOUT
        pub struct DBG_I2C2_SMBUS_TIMEOUT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_I2C2_SMBUS_TIMEOUT_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        ///Field `DBG_TIM5_STOP` reader - DBG_TIM5_STOP
        pub struct DBG_TIM5_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM5_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM5_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM5_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM5_STOP` writer - DBG_TIM5_STOP
        pub struct DBG_TIM5_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM5_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 18)) | ((value as u32 & 0x01) << 18);
                self.w
            }
        }
        ///Field `DBG_TIM6_STOP` reader - DBG_TIM6_STOP
        pub struct DBG_TIM6_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM6_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM6_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM6_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM6_STOP` writer - DBG_TIM6_STOP
        pub struct DBG_TIM6_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM6_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 19)) | ((value as u32 & 0x01) << 19);
                self.w
            }
        }
        ///Field `DBG_TIM7_STOP` reader - DBG_TIM7_STOP
        pub struct DBG_TIM7_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM7_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM7_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM7_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM7_STOP` writer - DBG_TIM7_STOP
        pub struct DBG_TIM7_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM7_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 20)) | ((value as u32 & 0x01) << 20);
                self.w
            }
        }
        ///Field `DBG_TIM15_STOP` reader - DBG_TIM15_STOP
        pub struct DBG_TIM15_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM15_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM15_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM15_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM15_STOP` writer - DBG_TIM15_STOP
        pub struct DBG_TIM15_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM15_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 22)) | ((value as u32 & 0x01) << 22);
                self.w
            }
        }
        ///Field `DBG_TIM16_STOP` reader - DBG_TIM16_STOP
        pub struct DBG_TIM16_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM16_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM16_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM16_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM16_STOP` writer - DBG_TIM16_STOP
        pub struct DBG_TIM16_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM16_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 23)) | ((value as u32 & 0x01) << 23);
                self.w
            }
        }
        ///Field `DBG_TIM17_STOP` reader - DBG_TIM17_STOP
        pub struct DBG_TIM17_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM17_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM17_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM17_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM17_STOP` writer - DBG_TIM17_STOP
        pub struct DBG_TIM17_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM17_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 24)) | ((value as u32 & 0x01) << 24);
                self.w
            }
        }
        ///Field `DBG_TIM12_STOP` reader - DBG_TIM12_STOP
        pub struct DBG_TIM12_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM12_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM12_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM12_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM12_STOP` writer - DBG_TIM12_STOP
        pub struct DBG_TIM12_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM12_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 25)) | ((value as u32 & 0x01) << 25);
                self.w
            }
        }
        ///Field `DBG_TIM13_STOP` reader - DBG_TIM13_STOP
        pub struct DBG_TIM13_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM13_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM13_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM13_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM13_STOP` writer - DBG_TIM13_STOP
        pub struct DBG_TIM13_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM13_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 26)) | ((value as u32 & 0x01) << 26);
                self.w
            }
        }
        ///Field `DBG_TIM14_STOP` reader - DBG_TIM14_STOP
        pub struct DBG_TIM14_STOP_R(crate::FieldReader<bool, bool>);
        impl DBG_TIM14_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                DBG_TIM14_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBG_TIM14_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBG_TIM14_STOP` writer - DBG_TIM14_STOP
        pub struct DBG_TIM14_STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBG_TIM14_STOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 27)) | ((value as u32 & 0x01) << 27);
                self.w
            }
        }
        impl R {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            pub fn dbg_sleep(&self) -> DBG_SLEEP_R {
                DBG_SLEEP_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            pub fn dbg_stop(&self) -> DBG_STOP_R {
                DBG_STOP_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            pub fn dbg_standby(&self) -> DBG_STANDBY_R {
                DBG_STANDBY_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 5 - TRACE_IOEN
            #[inline(always)]
            pub fn trace_ioen(&self) -> TRACE_IOEN_R {
                TRACE_IOEN_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bits 6:7 - TRACE_MODE
            #[inline(always)]
            pub fn trace_mode(&self) -> TRACE_MODE_R {
                TRACE_MODE_R::new(((self.bits >> 6) & 0x03) as u8)
            }
            ///Bit 8 - DBG_IWDG_STOP
            #[inline(always)]
            pub fn dbg_iwdg_stop(&self) -> DBG_IWDG_STOP_R {
                DBG_IWDG_STOP_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - DBG_WWDG_STOP
            #[inline(always)]
            pub fn dbg_wwdg_stop(&self) -> DBG_WWDG_STOP_R {
                DBG_WWDG_STOP_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - DBG_TIM1_STOP
            #[inline(always)]
            pub fn dbg_tim1_stop(&self) -> DBG_TIM1_STOP_R {
                DBG_TIM1_STOP_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - DBG_TIM2_STOP
            #[inline(always)]
            pub fn dbg_tim2_stop(&self) -> DBG_TIM2_STOP_R {
                DBG_TIM2_STOP_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - DBG_TIM3_STOP
            #[inline(always)]
            pub fn dbg_tim3_stop(&self) -> DBG_TIM3_STOP_R {
                DBG_TIM3_STOP_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - DBG_TIM4_STOP
            #[inline(always)]
            pub fn dbg_tim4_stop(&self) -> DBG_TIM4_STOP_R {
                DBG_TIM4_STOP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 15 - DBG_I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c1_smbus_timeout(&self) -> DBG_I2C1_SMBUS_TIMEOUT_R {
                DBG_I2C1_SMBUS_TIMEOUT_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 16 - DBG_I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c2_smbus_timeout(&self) -> DBG_I2C2_SMBUS_TIMEOUT_R {
                DBG_I2C2_SMBUS_TIMEOUT_R::new(((self.bits >> 16) & 0x01) != 0)
            }
            ///Bit 18 - DBG_TIM5_STOP
            #[inline(always)]
            pub fn dbg_tim5_stop(&self) -> DBG_TIM5_STOP_R {
                DBG_TIM5_STOP_R::new(((self.bits >> 18) & 0x01) != 0)
            }
            ///Bit 19 - DBG_TIM6_STOP
            #[inline(always)]
            pub fn dbg_tim6_stop(&self) -> DBG_TIM6_STOP_R {
                DBG_TIM6_STOP_R::new(((self.bits >> 19) & 0x01) != 0)
            }
            ///Bit 20 - DBG_TIM7_STOP
            #[inline(always)]
            pub fn dbg_tim7_stop(&self) -> DBG_TIM7_STOP_R {
                DBG_TIM7_STOP_R::new(((self.bits >> 20) & 0x01) != 0)
            }
            ///Bit 22 - DBG_TIM15_STOP
            #[inline(always)]
            pub fn dbg_tim15_stop(&self) -> DBG_TIM15_STOP_R {
                DBG_TIM15_STOP_R::new(((self.bits >> 22) & 0x01) != 0)
            }
            ///Bit 23 - DBG_TIM16_STOP
            #[inline(always)]
            pub fn dbg_tim16_stop(&self) -> DBG_TIM16_STOP_R {
                DBG_TIM16_STOP_R::new(((self.bits >> 23) & 0x01) != 0)
            }
            ///Bit 24 - DBG_TIM17_STOP
            #[inline(always)]
            pub fn dbg_tim17_stop(&self) -> DBG_TIM17_STOP_R {
                DBG_TIM17_STOP_R::new(((self.bits >> 24) & 0x01) != 0)
            }
            ///Bit 25 - DBG_TIM12_STOP
            #[inline(always)]
            pub fn dbg_tim12_stop(&self) -> DBG_TIM12_STOP_R {
                DBG_TIM12_STOP_R::new(((self.bits >> 25) & 0x01) != 0)
            }
            ///Bit 26 - DBG_TIM13_STOP
            #[inline(always)]
            pub fn dbg_tim13_stop(&self) -> DBG_TIM13_STOP_R {
                DBG_TIM13_STOP_R::new(((self.bits >> 26) & 0x01) != 0)
            }
            ///Bit 27 - DBG_TIM14_STOP
            #[inline(always)]
            pub fn dbg_tim14_stop(&self) -> DBG_TIM14_STOP_R {
                DBG_TIM14_STOP_R::new(((self.bits >> 27) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - DBG_SLEEP
            #[inline(always)]
            pub fn dbg_sleep(&mut self) -> DBG_SLEEP_W {
                DBG_SLEEP_W { w: self }
            }
            ///Bit 1 - DBG_STOP
            #[inline(always)]
            pub fn dbg_stop(&mut self) -> DBG_STOP_W {
                DBG_STOP_W { w: self }
            }
            ///Bit 2 - DBG_STANDBY
            #[inline(always)]
            pub fn dbg_standby(&mut self) -> DBG_STANDBY_W {
                DBG_STANDBY_W { w: self }
            }
            ///Bit 5 - TRACE_IOEN
            #[inline(always)]
            pub fn trace_ioen(&mut self) -> TRACE_IOEN_W {
                TRACE_IOEN_W { w: self }
            }
            ///Bits 6:7 - TRACE_MODE
            #[inline(always)]
            pub fn trace_mode(&mut self) -> TRACE_MODE_W {
                TRACE_MODE_W { w: self }
            }
            ///Bit 8 - DBG_IWDG_STOP
            #[inline(always)]
            pub fn dbg_iwdg_stop(&mut self) -> DBG_IWDG_STOP_W {
                DBG_IWDG_STOP_W { w: self }
            }
            ///Bit 9 - DBG_WWDG_STOP
            #[inline(always)]
            pub fn dbg_wwdg_stop(&mut self) -> DBG_WWDG_STOP_W {
                DBG_WWDG_STOP_W { w: self }
            }
            ///Bit 10 - DBG_TIM1_STOP
            #[inline(always)]
            pub fn dbg_tim1_stop(&mut self) -> DBG_TIM1_STOP_W {
                DBG_TIM1_STOP_W { w: self }
            }
            ///Bit 11 - DBG_TIM2_STOP
            #[inline(always)]
            pub fn dbg_tim2_stop(&mut self) -> DBG_TIM2_STOP_W {
                DBG_TIM2_STOP_W { w: self }
            }
            ///Bit 12 - DBG_TIM3_STOP
            #[inline(always)]
            pub fn dbg_tim3_stop(&mut self) -> DBG_TIM3_STOP_W {
                DBG_TIM3_STOP_W { w: self }
            }
            ///Bit 13 - DBG_TIM4_STOP
            #[inline(always)]
            pub fn dbg_tim4_stop(&mut self) -> DBG_TIM4_STOP_W {
                DBG_TIM4_STOP_W { w: self }
            }
            ///Bit 15 - DBG_I2C1_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c1_smbus_timeout(&mut self) -> DBG_I2C1_SMBUS_TIMEOUT_W {
                DBG_I2C1_SMBUS_TIMEOUT_W { w: self }
            }
            ///Bit 16 - DBG_I2C2_SMBUS_TIMEOUT
            #[inline(always)]
            pub fn dbg_i2c2_smbus_timeout(&mut self) -> DBG_I2C2_SMBUS_TIMEOUT_W {
                DBG_I2C2_SMBUS_TIMEOUT_W { w: self }
            }
            ///Bit 18 - DBG_TIM5_STOP
            #[inline(always)]
            pub fn dbg_tim5_stop(&mut self) -> DBG_TIM5_STOP_W {
                DBG_TIM5_STOP_W { w: self }
            }
            ///Bit 19 - DBG_TIM6_STOP
            #[inline(always)]
            pub fn dbg_tim6_stop(&mut self) -> DBG_TIM6_STOP_W {
                DBG_TIM6_STOP_W { w: self }
            }
            ///Bit 20 - DBG_TIM7_STOP
            #[inline(always)]
            pub fn dbg_tim7_stop(&mut self) -> DBG_TIM7_STOP_W {
                DBG_TIM7_STOP_W { w: self }
            }
            ///Bit 22 - DBG_TIM15_STOP
            #[inline(always)]
            pub fn dbg_tim15_stop(&mut self) -> DBG_TIM15_STOP_W {
                DBG_TIM15_STOP_W { w: self }
            }
            ///Bit 23 - DBG_TIM16_STOP
            #[inline(always)]
            pub fn dbg_tim16_stop(&mut self) -> DBG_TIM16_STOP_W {
                DBG_TIM16_STOP_W { w: self }
            }
            ///Bit 24 - DBG_TIM17_STOP
            #[inline(always)]
            pub fn dbg_tim17_stop(&mut self) -> DBG_TIM17_STOP_W {
                DBG_TIM17_STOP_W { w: self }
            }
            ///Bit 25 - DBG_TIM12_STOP
            #[inline(always)]
            pub fn dbg_tim12_stop(&mut self) -> DBG_TIM12_STOP_W {
                DBG_TIM12_STOP_W { w: self }
            }
            ///Bit 26 - DBG_TIM13_STOP
            #[inline(always)]
            pub fn dbg_tim13_stop(&mut self) -> DBG_TIM13_STOP_W {
                DBG_TIM13_STOP_W { w: self }
            }
            ///Bit 27 - DBG_TIM14_STOP
            #[inline(always)]
            pub fn dbg_tim14_stop(&mut self) -> DBG_TIM14_STOP_W {
                DBG_TIM14_STOP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DBGMCU_CR
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Universal asynchronous receiver transmitter
pub struct UART4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART4 {}
impl UART4 {
    ///Pointer to the register block
    pub const PTR: *const uart4::RegisterBlock = 0x4000_4c00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart4::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART4 {
    type Target = uart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART4").finish()
    }
}
///Universal asynchronous receiver transmitter
pub mod uart4 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x04 - Data register
        pub dr: crate::Reg<dr::DR_SPEC>,
        ///0x08 - Baud rate register
        pub brr: crate::Reg<brr::BRR_SPEC>,
        ///0x0c - Control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x10 - Control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x14 - Control register 3
        pub cr3: crate::Reg<cr3::CR3_SPEC>,
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///Status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Parity error
        pub struct PE_R(crate::FieldReader<bool, bool>);
        impl PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FE` reader - Framing error
        pub struct FE_R(crate::FieldReader<bool, bool>);
        impl FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `NE` reader - Noise error flag
        pub struct NE_R(crate::FieldReader<bool, bool>);
        impl NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ORE` reader - Overrun error
        pub struct ORE_R(crate::FieldReader<bool, bool>);
        impl ORE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ORE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ORE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IDLE` reader - IDLE line detected
        pub struct IDLE_R(crate::FieldReader<bool, bool>);
        impl IDLE_R {
            pub(crate) fn new(bits: bool) -> Self {
                IDLE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IDLE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNE` reader - Read data register not empty
        pub struct RXNE_R(crate::FieldReader<bool, bool>);
        impl RXNE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RXNE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNE` writer - Read data register not empty
        pub struct RXNE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `TC` reader - Transmission complete
        pub struct TC_R(crate::FieldReader<bool, bool>);
        impl TC_R {
            pub(crate) fn new(bits: bool) -> Self {
                TC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TC_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TC` writer - Transmission complete
        pub struct TC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TC_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `TXE` reader - Transmit data register empty
        pub struct TXE_R(crate::FieldReader<bool, bool>);
        impl TXE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TXE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBD` reader - LIN break detection flag
        pub struct LBD_R(crate::FieldReader<bool, bool>);
        impl LBD_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LBD_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBD` writer - LIN break detection flag
        pub struct LBD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBD_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Parity error
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Framing error
            #[inline(always)]
            pub fn fe(&self) -> FE_R {
                FE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Noise error flag
            #[inline(always)]
            pub fn ne(&self) -> NE_R {
                NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Overrun error
            #[inline(always)]
            pub fn ore(&self) -> ORE_R {
                ORE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - IDLE line detected
            #[inline(always)]
            pub fn idle(&self) -> IDLE_R {
                IDLE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&self) -> RXNE_R {
                RXNE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&self) -> TC_R {
                TC_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Transmit data register empty
            #[inline(always)]
            pub fn txe(&self) -> TXE_R {
                TXE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&self) -> LBD_R {
                LBD_R::new(((self.bits >> 8) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 5 - Read data register not empty
            #[inline(always)]
            pub fn rxne(&mut self) -> RXNE_W {
                RXNE_W { w: self }
            }
            ///Bit 6 - Transmission complete
            #[inline(always)]
            pub fn tc(&mut self) -> TC_W {
                TC_W { w: self }
            }
            ///Bit 8 - LIN break detection flag
            #[inline(always)]
            pub fn lbd(&mut self) -> LBD_W {
                LBD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///Data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - DR
        pub struct DR_R(crate::FieldReader<u16, u16>);
        impl DR_R {
            pub(crate) fn new(bits: u16) -> Self {
                DR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DR` writer - DR
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | (value as u32 & 0x01ff);
                self.w
            }
        }
        impl R {
            ///Bits 0:8 - DR
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - DR
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR to value 0
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BRR register accessor: an alias for `Reg<BRR_SPEC>`
    pub type BRR = crate::Reg<brr::BRR_SPEC>;
    ///Baud rate register
    pub mod brr {
        ///Register `BRR` reader
        pub struct R(crate::R<BRR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BRR_SPEC>> for R {
            fn from(reader: crate::R<BRR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BRR` writer
        pub struct W(crate::W<BRR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BRR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BRR_SPEC>> for W {
            fn from(writer: crate::W<BRR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DIV_Fraction` reader - DIV_Fraction
        pub struct DIV_FRACTION_R(crate::FieldReader<u8, u8>);
        impl DIV_FRACTION_R {
            pub(crate) fn new(bits: u8) -> Self {
                DIV_FRACTION_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIV_FRACTION_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIV_Fraction` writer - DIV_Fraction
        pub struct DIV_FRACTION_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_FRACTION_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///Field `DIV_Mantissa` reader - DIV_Mantissa
        pub struct DIV_MANTISSA_R(crate::FieldReader<u16, u16>);
        impl DIV_MANTISSA_R {
            pub(crate) fn new(bits: u16) -> Self {
                DIV_MANTISSA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DIV_MANTISSA_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DIV_Mantissa` writer - DIV_Mantissa
        pub struct DIV_MANTISSA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DIV_MANTISSA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0fff << 4)) | ((value as u32 & 0x0fff) << 4);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - DIV_Fraction
            #[inline(always)]
            pub fn div_fraction(&self) -> DIV_FRACTION_R {
                DIV_FRACTION_R::new((self.bits & 0x0f) as u8)
            }
            ///Bits 4:15 - DIV_Mantissa
            #[inline(always)]
            pub fn div_mantissa(&self) -> DIV_MANTISSA_R {
                DIV_MANTISSA_R::new(((self.bits >> 4) & 0x0fff) as u16)
            }
        }
        impl W {
            ///Bits 0:3 - DIV_Fraction
            #[inline(always)]
            pub fn div_fraction(&mut self) -> DIV_FRACTION_W {
                DIV_FRACTION_W { w: self }
            }
            ///Bits 4:15 - DIV_Mantissa
            #[inline(always)]
            pub fn div_mantissa(&mut self) -> DIV_MANTISSA_W {
                DIV_MANTISSA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Baud rate register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [brr](index.html) module
        pub struct BRR_SPEC;
        impl crate::RegisterSpec for BRR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [brr::R](R) reader structure
        impl crate::Readable for BRR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [brr::W](W) writer structure
        impl crate::Writable for BRR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BRR to value 0
        impl crate::Resettable for BRR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///Control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Send break
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum SBK_A {
            ///0: No break character is transmitted
            NOBREAK = 0,
            ///1: Break character transmitted
            BREAK = 1,
        }
        impl From<SBK_A> for bool {
            #[inline(always)]
            fn from(variant: SBK_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `SBK` reader - Send break
        pub struct SBK_R(crate::FieldReader<bool, SBK_A>);
        impl SBK_R {
            pub(crate) fn new(bits: bool) -> Self {
                SBK_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> SBK_A {
                match self.bits {
                    false => SBK_A::NOBREAK,
                    true => SBK_A::BREAK,
                }
            }
            ///Checks if the value of the field is `NOBREAK`
            #[inline(always)]
            pub fn is_no_break(&self) -> bool {
                **self == SBK_A::NOBREAK
            }
            ///Checks if the value of the field is `BREAK`
            #[inline(always)]
            pub fn is_break(&self) -> bool {
                **self == SBK_A::BREAK
            }
        }
        impl core::ops::Deref for SBK_R {
            type Target = crate::FieldReader<bool, SBK_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SBK` writer - Send break
        pub struct SBK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SBK_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: SBK_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No break character is transmitted
            #[inline(always)]
            pub fn no_break(self) -> &'a mut W {
                self.variant(SBK_A::NOBREAK)
            }
            ///Break character transmitted
            #[inline(always)]
            pub fn break_(self) -> &'a mut W {
                self.variant(SBK_A::BREAK)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Receiver wakeup
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RWU_A {
            ///0: Receiver in active mode
            ACTIVE = 0,
            ///1: Receiver in mute mode
            MUTE = 1,
        }
        impl From<RWU_A> for bool {
            #[inline(always)]
            fn from(variant: RWU_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RWU` reader - Receiver wakeup
        pub struct RWU_R(crate::FieldReader<bool, RWU_A>);
        impl RWU_R {
            pub(crate) fn new(bits: bool) -> Self {
                RWU_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RWU_A {
                match self.bits {
                    false => RWU_A::ACTIVE,
                    true => RWU_A::MUTE,
                }
            }
            ///Checks if the value of the field is `ACTIVE`
            #[inline(always)]
            pub fn is_active(&self) -> bool {
                **self == RWU_A::ACTIVE
            }
            ///Checks if the value of the field is `MUTE`
            #[inline(always)]
            pub fn is_mute(&self) -> bool {
                **self == RWU_A::MUTE
            }
        }
        impl core::ops::Deref for RWU_R {
            type Target = crate::FieldReader<bool, RWU_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RWU` writer - Receiver wakeup
        pub struct RWU_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RWU_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RWU_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Receiver in active mode
            #[inline(always)]
            pub fn active(self) -> &'a mut W {
                self.variant(RWU_A::ACTIVE)
            }
            ///Receiver in mute mode
            #[inline(always)]
            pub fn mute(self) -> &'a mut W {
                self.variant(RWU_A::MUTE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Receiver enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RE_A {
            ///0: Receiver disabled
            DISABLED = 0,
            ///1: Receiver enabled
            ENABLED = 1,
        }
        impl From<RE_A> for bool {
            #[inline(always)]
            fn from(variant: RE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RE` reader - Receiver enable
        pub struct RE_R(crate::FieldReader<bool, RE_A>);
        impl RE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RE_A {
                match self.bits {
                    false => RE_A::DISABLED,
                    true => RE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RE_A::ENABLED
            }
        }
        impl core::ops::Deref for RE_R {
            type Target = crate::FieldReader<bool, RE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RE` writer - Receiver enable
        pub struct RE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Receiver disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RE_A::DISABLED)
            }
            ///Receiver enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Transmitter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TE_A {
            ///0: Transmitter disabled
            DISABLED = 0,
            ///1: Transmitter enabled
            ENABLED = 1,
        }
        impl From<TE_A> for bool {
            #[inline(always)]
            fn from(variant: TE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TE` reader - Transmitter enable
        pub struct TE_R(crate::FieldReader<bool, TE_A>);
        impl TE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TE_A {
                match self.bits {
                    false => TE_A::DISABLED,
                    true => TE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TE_A::ENABLED
            }
        }
        impl core::ops::Deref for TE_R {
            type Target = crate::FieldReader<bool, TE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TE` writer - Transmitter enable
        pub struct TE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Transmitter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TE_A::DISABLED)
            }
            ///Transmitter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///IDLE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IDLEIE_A {
            ///0: IDLE interrupt disabled
            DISABLED = 0,
            ///1: IDLE interrupt enabled
            ENABLED = 1,
        }
        impl From<IDLEIE_A> for bool {
            #[inline(always)]
            fn from(variant: IDLEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IDLEIE` reader - IDLE interrupt enable
        pub struct IDLEIE_R(crate::FieldReader<bool, IDLEIE_A>);
        impl IDLEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                IDLEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IDLEIE_A {
                match self.bits {
                    false => IDLEIE_A::DISABLED,
                    true => IDLEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == IDLEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == IDLEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for IDLEIE_R {
            type Target = crate::FieldReader<bool, IDLEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IDLEIE` writer - IDLE interrupt enable
        pub struct IDLEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDLEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IDLEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///IDLE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::DISABLED)
            }
            ///IDLE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IDLEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///RXNE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RXNEIE_A {
            ///0: RXNE interrupt disabled
            DISABLED = 0,
            ///1: RXNE interrupt enabled
            ENABLED = 1,
        }
        impl From<RXNEIE_A> for bool {
            #[inline(always)]
            fn from(variant: RXNEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RXNEIE` reader - RXNE interrupt enable
        pub struct RXNEIE_R(crate::FieldReader<bool, RXNEIE_A>);
        impl RXNEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RXNEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> RXNEIE_A {
                match self.bits {
                    false => RXNEIE_A::DISABLED,
                    true => RXNEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == RXNEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == RXNEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for RXNEIE_R {
            type Target = crate::FieldReader<bool, RXNEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RXNEIE` writer - RXNE interrupt enable
        pub struct RXNEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RXNEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RXNEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///RXNE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::DISABLED)
            }
            ///RXNE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(RXNEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Transmission complete interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TCIE_A {
            ///0: TC interrupt disabled
            DISABLED = 0,
            ///1: TC interrupt enabled
            ENABLED = 1,
        }
        impl From<TCIE_A> for bool {
            #[inline(always)]
            fn from(variant: TCIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TCIE` reader - Transmission complete interrupt enable
        pub struct TCIE_R(crate::FieldReader<bool, TCIE_A>);
        impl TCIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TCIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TCIE_A {
                match self.bits {
                    false => TCIE_A::DISABLED,
                    true => TCIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TCIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TCIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TCIE_R {
            type Target = crate::FieldReader<bool, TCIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TCIE` writer - Transmission complete interrupt enable
        pub struct TCIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TCIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TCIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TC interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TCIE_A::DISABLED)
            }
            ///TC interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TCIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///TXE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum TXEIE_A {
            ///0: TXE interrupt disabled
            DISABLED = 0,
            ///1: TXE interrupt enabled
            ENABLED = 1,
        }
        impl From<TXEIE_A> for bool {
            #[inline(always)]
            fn from(variant: TXEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `TXEIE` reader - TXE interrupt enable
        pub struct TXEIE_R(crate::FieldReader<bool, TXEIE_A>);
        impl TXEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TXEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> TXEIE_A {
                match self.bits {
                    false => TXEIE_A::DISABLED,
                    true => TXEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == TXEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == TXEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for TXEIE_R {
            type Target = crate::FieldReader<bool, TXEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TXEIE` writer - TXE interrupt enable
        pub struct TXEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: TXEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TXE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(TXEIE_A::DISABLED)
            }
            ///TXE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(TXEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///PE interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PEIE_A {
            ///0: PE interrupt disabled
            DISABLED = 0,
            ///1: PE interrupt enabled
            ENABLED = 1,
        }
        impl From<PEIE_A> for bool {
            #[inline(always)]
            fn from(variant: PEIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PEIE` reader - PE interrupt enable
        pub struct PEIE_R(crate::FieldReader<bool, PEIE_A>);
        impl PEIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PEIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PEIE_A {
                match self.bits {
                    false => PEIE_A::DISABLED,
                    true => PEIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PEIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PEIE_A::ENABLED
            }
        }
        impl core::ops::Deref for PEIE_R {
            type Target = crate::FieldReader<bool, PEIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PEIE` writer - PE interrupt enable
        pub struct PEIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PEIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PEIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///PE interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PEIE_A::DISABLED)
            }
            ///PE interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PEIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Parity selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PS_A {
            ///0: Even parity
            EVEN = 0,
            ///1: Odd parity
            ODD = 1,
        }
        impl From<PS_A> for bool {
            #[inline(always)]
            fn from(variant: PS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PS` reader - Parity selection
        pub struct PS_R(crate::FieldReader<bool, PS_A>);
        impl PS_R {
            pub(crate) fn new(bits: bool) -> Self {
                PS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PS_A {
                match self.bits {
                    false => PS_A::EVEN,
                    true => PS_A::ODD,
                }
            }
            ///Checks if the value of the field is `EVEN`
            #[inline(always)]
            pub fn is_even(&self) -> bool {
                **self == PS_A::EVEN
            }
            ///Checks if the value of the field is `ODD`
            #[inline(always)]
            pub fn is_odd(&self) -> bool {
                **self == PS_A::ODD
            }
        }
        impl core::ops::Deref for PS_R {
            type Target = crate::FieldReader<bool, PS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PS` writer - Parity selection
        pub struct PS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Even parity
            #[inline(always)]
            pub fn even(self) -> &'a mut W {
                self.variant(PS_A::EVEN)
            }
            ///Odd parity
            #[inline(always)]
            pub fn odd(self) -> &'a mut W {
                self.variant(PS_A::ODD)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Parity control enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum PCE_A {
            ///0: Parity control disabled
            DISABLED = 0,
            ///1: Parity control enabled
            ENABLED = 1,
        }
        impl From<PCE_A> for bool {
            #[inline(always)]
            fn from(variant: PCE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `PCE` reader - Parity control enable
        pub struct PCE_R(crate::FieldReader<bool, PCE_A>);
        impl PCE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PCE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> PCE_A {
                match self.bits {
                    false => PCE_A::DISABLED,
                    true => PCE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == PCE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == PCE_A::ENABLED
            }
        }
        impl core::ops::Deref for PCE_R {
            type Target = crate::FieldReader<bool, PCE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PCE` writer - Parity control enable
        pub struct PCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PCE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: PCE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Parity control disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(PCE_A::DISABLED)
            }
            ///Parity control enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(PCE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Wakeup method
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum WAKE_A {
            ///0: USART wakeup on idle line
            IDLELINE = 0,
            ///1: USART wakeup on address mark
            ADDRESSMARK = 1,
        }
        impl From<WAKE_A> for bool {
            #[inline(always)]
            fn from(variant: WAKE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `WAKE` reader - Wakeup method
        pub struct WAKE_R(crate::FieldReader<bool, WAKE_A>);
        impl WAKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                WAKE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> WAKE_A {
                match self.bits {
                    false => WAKE_A::IDLELINE,
                    true => WAKE_A::ADDRESSMARK,
                }
            }
            ///Checks if the value of the field is `IDLELINE`
            #[inline(always)]
            pub fn is_idle_line(&self) -> bool {
                **self == WAKE_A::IDLELINE
            }
            ///Checks if the value of the field is `ADDRESSMARK`
            #[inline(always)]
            pub fn is_address_mark(&self) -> bool {
                **self == WAKE_A::ADDRESSMARK
            }
        }
        impl core::ops::Deref for WAKE_R {
            type Target = crate::FieldReader<bool, WAKE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WAKE` writer - Wakeup method
        pub struct WAKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WAKE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: WAKE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///USART wakeup on idle line
            #[inline(always)]
            pub fn idle_line(self) -> &'a mut W {
                self.variant(WAKE_A::IDLELINE)
            }
            ///USART wakeup on address mark
            #[inline(always)]
            pub fn address_mark(self) -> &'a mut W {
                self.variant(WAKE_A::ADDRESSMARK)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Word length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum M_A {
            ///0: 8 data bits
            M8 = 0,
            ///1: 9 data bits
            M9 = 1,
        }
        impl From<M_A> for bool {
            #[inline(always)]
            fn from(variant: M_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `M` reader - Word length
        pub struct M_R(crate::FieldReader<bool, M_A>);
        impl M_R {
            pub(crate) fn new(bits: bool) -> Self {
                M_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> M_A {
                match self.bits {
                    false => M_A::M8,
                    true => M_A::M9,
                }
            }
            ///Checks if the value of the field is `M8`
            #[inline(always)]
            pub fn is_m8(&self) -> bool {
                **self == M_A::M8
            }
            ///Checks if the value of the field is `M9`
            #[inline(always)]
            pub fn is_m9(&self) -> bool {
                **self == M_A::M9
            }
        }
        impl core::ops::Deref for M_R {
            type Target = crate::FieldReader<bool, M_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `M` writer - Word length
        pub struct M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> M_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: M_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///8 data bits
            #[inline(always)]
            pub fn m8(self) -> &'a mut W {
                self.variant(M_A::M8)
            }
            ///9 data bits
            #[inline(always)]
            pub fn m9(self) -> &'a mut W {
                self.variant(M_A::M9)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///USART enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UE_A {
            ///0: USART prescaler and outputs disabled
            DISABLED = 0,
            ///1: USART enabled
            ENABLED = 1,
        }
        impl From<UE_A> for bool {
            #[inline(always)]
            fn from(variant: UE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UE` reader - USART enable
        pub struct UE_R(crate::FieldReader<bool, UE_A>);
        impl UE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UE_A {
                match self.bits {
                    false => UE_A::DISABLED,
                    true => UE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UE_A::ENABLED
            }
        }
        impl core::ops::Deref for UE_R {
            type Target = crate::FieldReader<bool, UE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UE` writer - USART enable
        pub struct UE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///USART prescaler and outputs disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UE_A::DISABLED)
            }
            ///USART enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&self) -> SBK_R {
                SBK_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&self) -> RWU_R {
                RWU_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&self) -> RE_R {
                RE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&self) -> TE_R {
                TE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&self) -> IDLEIE_R {
                IDLEIE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&self) -> RXNEIE_R {
                RXNEIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&self) -> TCIE_R {
                TCIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&self) -> TXEIE_R {
                TXEIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&self) -> PEIE_R {
                PEIE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&self) -> PS_R {
                PS_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&self) -> PCE_R {
                PCE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&self) -> WAKE_R {
                WAKE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&self) -> M_R {
                M_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&self) -> UE_R {
                UE_R::new(((self.bits >> 13) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Send break
            #[inline(always)]
            pub fn sbk(&mut self) -> SBK_W {
                SBK_W { w: self }
            }
            ///Bit 1 - Receiver wakeup
            #[inline(always)]
            pub fn rwu(&mut self) -> RWU_W {
                RWU_W { w: self }
            }
            ///Bit 2 - Receiver enable
            #[inline(always)]
            pub fn re(&mut self) -> RE_W {
                RE_W { w: self }
            }
            ///Bit 3 - Transmitter enable
            #[inline(always)]
            pub fn te(&mut self) -> TE_W {
                TE_W { w: self }
            }
            ///Bit 4 - IDLE interrupt enable
            #[inline(always)]
            pub fn idleie(&mut self) -> IDLEIE_W {
                IDLEIE_W { w: self }
            }
            ///Bit 5 - RXNE interrupt enable
            #[inline(always)]
            pub fn rxneie(&mut self) -> RXNEIE_W {
                RXNEIE_W { w: self }
            }
            ///Bit 6 - Transmission complete interrupt enable
            #[inline(always)]
            pub fn tcie(&mut self) -> TCIE_W {
                TCIE_W { w: self }
            }
            ///Bit 7 - TXE interrupt enable
            #[inline(always)]
            pub fn txeie(&mut self) -> TXEIE_W {
                TXEIE_W { w: self }
            }
            ///Bit 8 - PE interrupt enable
            #[inline(always)]
            pub fn peie(&mut self) -> PEIE_W {
                PEIE_W { w: self }
            }
            ///Bit 9 - Parity selection
            #[inline(always)]
            pub fn ps(&mut self) -> PS_W {
                PS_W { w: self }
            }
            ///Bit 10 - Parity control enable
            #[inline(always)]
            pub fn pce(&mut self) -> PCE_W {
                PCE_W { w: self }
            }
            ///Bit 11 - Wakeup method
            #[inline(always)]
            pub fn wake(&mut self) -> WAKE_W {
                WAKE_W { w: self }
            }
            ///Bit 12 - Word length
            #[inline(always)]
            pub fn m(&mut self) -> M_W {
                M_W { w: self }
            }
            ///Bit 13 - USART enable
            #[inline(always)]
            pub fn ue(&mut self) -> UE_W {
                UE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///Control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ADD` reader - Address of the USART node
        pub struct ADD_R(crate::FieldReader<u8, u8>);
        impl ADD_R {
            pub(crate) fn new(bits: u8) -> Self {
                ADD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ADD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ADD` writer - Address of the USART node
        pub struct ADD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ADD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        ///lin break detection length
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDL_A {
            ///0: 10-bit break detection
            LBDL10 = 0,
            ///1: 11-bit break detection
            LBDL11 = 1,
        }
        impl From<LBDL_A> for bool {
            #[inline(always)]
            fn from(variant: LBDL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LBDL` reader - lin break detection length
        pub struct LBDL_R(crate::FieldReader<bool, LBDL_A>);
        impl LBDL_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBDL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDL_A {
                match self.bits {
                    false => LBDL_A::LBDL10,
                    true => LBDL_A::LBDL11,
                }
            }
            ///Checks if the value of the field is `LBDL10`
            #[inline(always)]
            pub fn is_lbdl10(&self) -> bool {
                **self == LBDL_A::LBDL10
            }
            ///Checks if the value of the field is `LBDL11`
            #[inline(always)]
            pub fn is_lbdl11(&self) -> bool {
                **self == LBDL_A::LBDL11
            }
        }
        impl core::ops::Deref for LBDL_R {
            type Target = crate::FieldReader<bool, LBDL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBDL` writer - lin break detection length
        pub struct LBDL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LBDL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///10-bit break detection
            #[inline(always)]
            pub fn lbdl10(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL10)
            }
            ///11-bit break detection
            #[inline(always)]
            pub fn lbdl11(self) -> &'a mut W {
                self.variant(LBDL_A::LBDL11)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///LIN break detection interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LBDIE_A {
            ///0: LIN break detection interrupt disabled
            DISABLED = 0,
            ///1: LIN break detection interrupt enabled
            ENABLED = 1,
        }
        impl From<LBDIE_A> for bool {
            #[inline(always)]
            fn from(variant: LBDIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LBDIE` reader - LIN break detection interrupt enable
        pub struct LBDIE_R(crate::FieldReader<bool, LBDIE_A>);
        impl LBDIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                LBDIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LBDIE_A {
                match self.bits {
                    false => LBDIE_A::DISABLED,
                    true => LBDIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == LBDIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == LBDIE_A::ENABLED
            }
        }
        impl core::ops::Deref for LBDIE_R {
            type Target = crate::FieldReader<bool, LBDIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LBDIE` writer - LIN break detection interrupt enable
        pub struct LBDIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LBDIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LBDIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LIN break detection interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LBDIE_A::DISABLED)
            }
            ///LIN break detection interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LBDIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///STOP bits
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum STOP_A {
            ///0: 1 stop bit
            STOP1 = 0,
            ///2: 2 stop bits
            STOP2 = 2,
        }
        impl From<STOP_A> for u8 {
            #[inline(always)]
            fn from(variant: STOP_A) -> Self {
                variant as _
            }
        }
        ///Field `STOP` reader - STOP bits
        pub struct STOP_R(crate::FieldReader<u8, STOP_A>);
        impl STOP_R {
            pub(crate) fn new(bits: u8) -> Self {
                STOP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<STOP_A> {
                match self.bits {
                    0 => Some(STOP_A::STOP1),
                    2 => Some(STOP_A::STOP2),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `STOP1`
            #[inline(always)]
            pub fn is_stop1(&self) -> bool {
                **self == STOP_A::STOP1
            }
            ///Checks if the value of the field is `STOP2`
            #[inline(always)]
            pub fn is_stop2(&self) -> bool {
                **self == STOP_A::STOP2
            }
        }
        impl core::ops::Deref for STOP_R {
            type Target = crate::FieldReader<u8, STOP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `STOP` writer - STOP bits
        pub struct STOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STOP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: STOP_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///1 stop bit
            #[inline(always)]
            pub fn stop1(self) -> &'a mut W {
                self.variant(STOP_A::STOP1)
            }
            ///2 stop bits
            #[inline(always)]
            pub fn stop2(self) -> &'a mut W {
                self.variant(STOP_A::STOP2)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 12)) | ((value as u32 & 0x03) << 12);
                self.w
            }
        }
        ///LIN mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum LINEN_A {
            ///0: LIN mode disabled
            DISABLED = 0,
            ///1: LIN mode enabled
            ENABLED = 1,
        }
        impl From<LINEN_A> for bool {
            #[inline(always)]
            fn from(variant: LINEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `LINEN` reader - LIN mode enable
        pub struct LINEN_R(crate::FieldReader<bool, LINEN_A>);
        impl LINEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                LINEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> LINEN_A {
                match self.bits {
                    false => LINEN_A::DISABLED,
                    true => LINEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == LINEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == LINEN_A::ENABLED
            }
        }
        impl core::ops::Deref for LINEN_R {
            type Target = crate::FieldReader<bool, LINEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LINEN` writer - LIN mode enable
        pub struct LINEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LINEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: LINEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///LIN mode disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(LINEN_A::DISABLED)
            }
            ///LIN mode enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(LINEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&self) -> ADD_R {
                ADD_R::new((self.bits & 0x0f) as u8)
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&self) -> LBDL_R {
                LBDL_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&self) -> LBDIE_R {
                LBDIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&self) -> STOP_R {
                STOP_R::new(((self.bits >> 12) & 0x03) as u8)
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&self) -> LINEN_R {
                LINEN_R::new(((self.bits >> 14) & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 0:3 - Address of the USART node
            #[inline(always)]
            pub fn add(&mut self) -> ADD_W {
                ADD_W { w: self }
            }
            ///Bit 5 - lin break detection length
            #[inline(always)]
            pub fn lbdl(&mut self) -> LBDL_W {
                LBDL_W { w: self }
            }
            ///Bit 6 - LIN break detection interrupt enable
            #[inline(always)]
            pub fn lbdie(&mut self) -> LBDIE_W {
                LBDIE_W { w: self }
            }
            ///Bits 12:13 - STOP bits
            #[inline(always)]
            pub fn stop(&mut self) -> STOP_W {
                STOP_W { w: self }
            }
            ///Bit 14 - LIN mode enable
            #[inline(always)]
            pub fn linen(&mut self) -> LINEN_W {
                LINEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR3 register accessor: an alias for `Reg<CR3_SPEC>`
    pub type CR3 = crate::Reg<cr3::CR3_SPEC>;
    ///Control register 3
    pub mod cr3 {
        ///Register `CR3` reader
        pub struct R(crate::R<CR3_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR3_SPEC>> for R {
            fn from(reader: crate::R<CR3_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR3` writer
        pub struct W(crate::W<CR3_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR3_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR3_SPEC>> for W {
            fn from(writer: crate::W<CR3_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Error interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum EIE_A {
            ///0: Error interrupt disabled
            DISABLED = 0,
            ///1: Error interrupt enabled
            ENABLED = 1,
        }
        impl From<EIE_A> for bool {
            #[inline(always)]
            fn from(variant: EIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `EIE` reader - Error interrupt enable
        pub struct EIE_R(crate::FieldReader<bool, EIE_A>);
        impl EIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                EIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> EIE_A {
                match self.bits {
                    false => EIE_A::DISABLED,
                    true => EIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == EIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == EIE_A::ENABLED
            }
        }
        impl core::ops::Deref for EIE_R {
            type Target = crate::FieldReader<bool, EIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EIE` writer - Error interrupt enable
        pub struct EIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: EIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Error interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(EIE_A::DISABLED)
            }
            ///Error interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(EIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///IrDA mode enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IREN_A {
            ///0: IrDA disabled
            DISABLED = 0,
            ///1: IrDA enabled
            ENABLED = 1,
        }
        impl From<IREN_A> for bool {
            #[inline(always)]
            fn from(variant: IREN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IREN` reader - IrDA mode enable
        pub struct IREN_R(crate::FieldReader<bool, IREN_A>);
        impl IREN_R {
            pub(crate) fn new(bits: bool) -> Self {
                IREN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IREN_A {
                match self.bits {
                    false => IREN_A::DISABLED,
                    true => IREN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == IREN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == IREN_A::ENABLED
            }
        }
        impl core::ops::Deref for IREN_R {
            type Target = crate::FieldReader<bool, IREN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IREN` writer - IrDA mode enable
        pub struct IREN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IREN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IREN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///IrDA disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(IREN_A::DISABLED)
            }
            ///IrDA enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(IREN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///IrDA low-power
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum IRLP_A {
            ///0: Normal mode
            NORMAL = 0,
            ///1: Low-power mode
            LOWPOWER = 1,
        }
        impl From<IRLP_A> for bool {
            #[inline(always)]
            fn from(variant: IRLP_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `IRLP` reader - IrDA low-power
        pub struct IRLP_R(crate::FieldReader<bool, IRLP_A>);
        impl IRLP_R {
            pub(crate) fn new(bits: bool) -> Self {
                IRLP_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> IRLP_A {
                match self.bits {
                    false => IRLP_A::NORMAL,
                    true => IRLP_A::LOWPOWER,
                }
            }
            ///Checks if the value of the field is `NORMAL`
            #[inline(always)]
            pub fn is_normal(&self) -> bool {
                **self == IRLP_A::NORMAL
            }
            ///Checks if the value of the field is `LOWPOWER`
            #[inline(always)]
            pub fn is_low_power(&self) -> bool {
                **self == IRLP_A::LOWPOWER
            }
        }
        impl core::ops::Deref for IRLP_R {
            type Target = crate::FieldReader<bool, IRLP_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IRLP` writer - IrDA low-power
        pub struct IRLP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IRLP_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: IRLP_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Normal mode
            #[inline(always)]
            pub fn normal(self) -> &'a mut W {
                self.variant(IRLP_A::NORMAL)
            }
            ///Low-power mode
            #[inline(always)]
            pub fn low_power(self) -> &'a mut W {
                self.variant(IRLP_A::LOWPOWER)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Half-duplex selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum HDSEL_A {
            ///0: Half duplex mode is not selected
            FULLDUPLEX = 0,
            ///1: Half duplex mode is selected
            HALFDUPLEX = 1,
        }
        impl From<HDSEL_A> for bool {
            #[inline(always)]
            fn from(variant: HDSEL_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `HDSEL` reader - Half-duplex selection
        pub struct HDSEL_R(crate::FieldReader<bool, HDSEL_A>);
        impl HDSEL_R {
            pub(crate) fn new(bits: bool) -> Self {
                HDSEL_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> HDSEL_A {
                match self.bits {
                    false => HDSEL_A::FULLDUPLEX,
                    true => HDSEL_A::HALFDUPLEX,
                }
            }
            ///Checks if the value of the field is `FULLDUPLEX`
            #[inline(always)]
            pub fn is_full_duplex(&self) -> bool {
                **self == HDSEL_A::FULLDUPLEX
            }
            ///Checks if the value of the field is `HALFDUPLEX`
            #[inline(always)]
            pub fn is_half_duplex(&self) -> bool {
                **self == HDSEL_A::HALFDUPLEX
            }
        }
        impl core::ops::Deref for HDSEL_R {
            type Target = crate::FieldReader<bool, HDSEL_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HDSEL` writer - Half-duplex selection
        pub struct HDSEL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HDSEL_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: HDSEL_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Half duplex mode is not selected
            #[inline(always)]
            pub fn full_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::FULLDUPLEX)
            }
            ///Half duplex mode is selected
            #[inline(always)]
            pub fn half_duplex(self) -> &'a mut W {
                self.variant(HDSEL_A::HALFDUPLEX)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///DMA enable receiver
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAR_A {
            ///0: DMA mode is disabled for reception
            DISABLED = 0,
            ///1: DMA mode is enabled for reception
            ENABLED = 1,
        }
        impl From<DMAR_A> for bool {
            #[inline(always)]
            fn from(variant: DMAR_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAR` reader - DMA enable receiver
        pub struct DMAR_R(crate::FieldReader<bool, DMAR_A>);
        impl DMAR_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAR_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAR_A {
                match self.bits {
                    false => DMAR_A::DISABLED,
                    true => DMAR_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAR_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAR_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAR_R {
            type Target = crate::FieldReader<bool, DMAR_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAR` writer - DMA enable receiver
        pub struct DMAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAR_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAR_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA mode is disabled for reception
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAR_A::DISABLED)
            }
            ///DMA mode is enabled for reception
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAR_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///DMA enable transmitter
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum DMAT_A {
            ///0: DMA mode is disabled for transmission
            DISABLED = 0,
            ///1: DMA mode is enabled for transmission
            ENABLED = 1,
        }
        impl From<DMAT_A> for bool {
            #[inline(always)]
            fn from(variant: DMAT_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `DMAT` reader - DMA enable transmitter
        pub struct DMAT_R(crate::FieldReader<bool, DMAT_A>);
        impl DMAT_R {
            pub(crate) fn new(bits: bool) -> Self {
                DMAT_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> DMAT_A {
                match self.bits {
                    false => DMAT_A::DISABLED,
                    true => DMAT_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == DMAT_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == DMAT_A::ENABLED
            }
        }
        impl core::ops::Deref for DMAT_R {
            type Target = crate::FieldReader<bool, DMAT_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAT` writer - DMA enable transmitter
        pub struct DMAT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAT_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: DMAT_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///DMA mode is disabled for transmission
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(DMAT_A::DISABLED)
            }
            ///DMA mode is enabled for transmission
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(DMAT_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&self) -> EIE_R {
                EIE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&self) -> IREN_R {
                IREN_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&self) -> IRLP_R {
                IRLP_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&self) -> HDSEL_R {
                HDSEL_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&self) -> DMAR_R {
                DMAR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&self) -> DMAT_R {
                DMAT_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Error interrupt enable
            #[inline(always)]
            pub fn eie(&mut self) -> EIE_W {
                EIE_W { w: self }
            }
            ///Bit 1 - IrDA mode enable
            #[inline(always)]
            pub fn iren(&mut self) -> IREN_W {
                IREN_W { w: self }
            }
            ///Bit 2 - IrDA low-power
            #[inline(always)]
            pub fn irlp(&mut self) -> IRLP_W {
                IRLP_W { w: self }
            }
            ///Bit 3 - Half-duplex selection
            #[inline(always)]
            pub fn hdsel(&mut self) -> HDSEL_W {
                HDSEL_W { w: self }
            }
            ///Bit 6 - DMA enable receiver
            #[inline(always)]
            pub fn dmar(&mut self) -> DMAR_W {
                DMAR_W { w: self }
            }
            ///Bit 7 - DMA enable transmitter
            #[inline(always)]
            pub fn dmat(&mut self) -> DMAT_W {
                DMAT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register 3
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr3](index.html) module
        pub struct CR3_SPEC;
        impl crate::RegisterSpec for CR3_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr3::R](R) reader structure
        impl crate::Readable for CR3_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr3::W](W) writer structure
        impl crate::Writable for CR3_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR3 to value 0
        impl crate::Resettable for CR3_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Universal asynchronous receiver transmitter
pub struct UART5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for UART5 {}
impl UART5 {
    ///Pointer to the register block
    pub const PTR: *const uart4::RegisterBlock = 0x4000_5000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const uart4::RegisterBlock {
        Self::PTR
    }
}
impl Deref for UART5 {
    type Target = uart4::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for UART5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("UART5").finish()
    }
}
///CRC calculation unit
pub struct CRC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CRC {}
impl CRC {
    ///Pointer to the register block
    pub const PTR: *const crc::RegisterBlock = 0x4002_3000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const crc::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CRC {
    type Target = crc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CRC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CRC").finish()
    }
}
///CRC calculation unit
pub mod crc {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Data register
        pub dr: crate::Reg<dr::DR_SPEC>,
        ///0x04 - Independent Data register
        pub idr: crate::Reg<idr::IDR_SPEC>,
        ///0x08 - Control register
        pub cr: crate::Reg<cr::CR_SPEC>,
    }
    ///DR register accessor: an alias for `Reg<DR_SPEC>`
    pub type DR = crate::Reg<dr::DR_SPEC>;
    ///Data register
    pub mod dr {
        ///Register `DR` reader
        pub struct R(crate::R<DR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DR_SPEC>> for R {
            fn from(reader: crate::R<DR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DR` writer
        pub struct W(crate::W<DR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DR_SPEC>> for W {
            fn from(writer: crate::W<DR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DR` reader - Data Register
        pub struct DR_R(crate::FieldReader<u32, u32>);
        impl DR_R {
            pub(crate) fn new(bits: u32) -> Self {
                DR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DR_R {
            type Target = crate::FieldReader<u32, u32>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DR` writer - Data Register
        pub struct DR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            pub fn dr(&self) -> DR_R {
                DR_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:31 - Data Register
            #[inline(always)]
            pub fn dr(&mut self) -> DR_W {
                DR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dr](index.html) module
        pub struct DR_SPEC;
        impl crate::RegisterSpec for DR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dr::R](R) reader structure
        impl crate::Readable for DR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dr::W](W) writer structure
        impl crate::Writable for DR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DR to value 0xffff_ffff
        impl crate::Resettable for DR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xffff_ffff
            }
        }
    }
    ///IDR register accessor: an alias for `Reg<IDR_SPEC>`
    pub type IDR = crate::Reg<idr::IDR_SPEC>;
    ///Independent Data register
    pub mod idr {
        ///Register `IDR` reader
        pub struct R(crate::R<IDR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<IDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<IDR_SPEC>> for R {
            fn from(reader: crate::R<IDR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `IDR` writer
        pub struct W(crate::W<IDR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<IDR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<IDR_SPEC>> for W {
            fn from(writer: crate::W<IDR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IDR` reader - Independent Data register
        pub struct IDR_R(crate::FieldReader<u8, u8>);
        impl IDR_R {
            pub(crate) fn new(bits: u8) -> Self {
                IDR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IDR_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IDR` writer - Independent Data register
        pub struct IDR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IDR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            pub fn idr(&self) -> IDR_R {
                IDR_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Independent Data register
            #[inline(always)]
            pub fn idr(&mut self) -> IDR_W {
                IDR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Independent Data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [idr](index.html) module
        pub struct IDR_SPEC;
        impl crate::RegisterSpec for IDR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [idr::R](R) reader structure
        impl crate::Readable for IDR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [idr::W](W) writer structure
        impl crate::Writable for IDR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets IDR to value 0
        impl crate::Resettable for IDR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Control register
    pub mod cr {
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Reset bit
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum RESET_AW {
            ///1: Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
            RESET = 1,
        }
        impl From<RESET_AW> for bool {
            #[inline(always)]
            fn from(variant: RESET_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `RESET` writer - Reset bit
        pub struct RESET_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RESET_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: RESET_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Resets the CRC calculation unit and sets the data register to 0xFFFF FFFF
            #[inline(always)]
            pub fn reset(self) -> &'a mut W {
                self.variant(RESET_AW::RESET)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 0 - Reset bit
            #[inline(always)]
            pub fn reset(&mut self) -> RESET_W {
                RESET_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///FLASH
pub struct FLASH {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for FLASH {}
impl FLASH {
    ///Pointer to the register block
    pub const PTR: *const flash::RegisterBlock = 0x4002_2000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const flash::RegisterBlock {
        Self::PTR
    }
}
impl Deref for FLASH {
    type Target = flash::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for FLASH {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("FLASH").finish()
    }
}
///FLASH
pub mod flash {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Flash access control register
        pub acr: crate::Reg<acr::ACR_SPEC>,
        ///0x04 - Flash key register
        pub keyr: crate::Reg<keyr::KEYR_SPEC>,
        ///0x08 - Flash option key register
        pub optkeyr: crate::Reg<optkeyr::OPTKEYR_SPEC>,
        ///0x0c - Status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x10 - Control register
        pub cr: crate::Reg<cr::CR_SPEC>,
        ///0x14 - Flash address register
        pub ar: crate::Reg<ar::AR_SPEC>,
        _reserved6: [u8; 4usize],
        ///0x1c - Option byte register
        pub obr: crate::Reg<obr::OBR_SPEC>,
        ///0x20 - Write protection register
        pub wrpr: crate::Reg<wrpr::WRPR_SPEC>,
    }
    ///ACR register accessor: an alias for `Reg<ACR_SPEC>`
    pub type ACR = crate::Reg<acr::ACR_SPEC>;
    ///Flash access control register
    pub mod acr {
        ///Register `ACR` reader
        pub struct R(crate::R<ACR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ACR_SPEC>> for R {
            fn from(reader: crate::R<ACR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ACR` writer
        pub struct W(crate::W<ACR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ACR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ACR_SPEC>> for W {
            fn from(writer: crate::W<ACR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `HLFCYA` reader - Flash half cycle access enable
        pub struct HLFCYA_R(crate::FieldReader<bool, bool>);
        impl HLFCYA_R {
            pub(crate) fn new(bits: bool) -> Self {
                HLFCYA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for HLFCYA_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `HLFCYA` writer - Flash half cycle access enable
        pub struct HLFCYA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> HLFCYA_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        impl R {
            ///Bit 3 - Flash half cycle access enable
            #[inline(always)]
            pub fn hlfcya(&self) -> HLFCYA_R {
                HLFCYA_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 3 - Flash half cycle access enable
            #[inline(always)]
            pub fn hlfcya(&mut self) -> HLFCYA_W {
                HLFCYA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash access control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [acr](index.html) module
        pub struct ACR_SPEC;
        impl crate::RegisterSpec for ACR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [acr::R](R) reader structure
        impl crate::Readable for ACR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [acr::W](W) writer structure
        impl crate::Writable for ACR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ACR to value 0
        impl crate::Resettable for ACR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///KEYR register accessor: an alias for `Reg<KEYR_SPEC>`
    pub type KEYR = crate::Reg<keyr::KEYR_SPEC>;
    ///Flash key register
    pub mod keyr {
        ///Register `KEYR` writer
        pub struct W(crate::W<KEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<KEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<KEYR_SPEC>> for W {
            fn from(writer: crate::W<KEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `KEY` writer - FPEC key
        pub struct KEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> KEY_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:31 - FPEC key
            #[inline(always)]
            pub fn key(&mut self) -> KEY_W {
                KEY_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [keyr](index.html) module
        pub struct KEYR_SPEC;
        impl crate::RegisterSpec for KEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [keyr::W](W) writer structure
        impl crate::Writable for KEYR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets KEYR to value 0
        impl crate::Resettable for KEYR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///OPTKEYR register accessor: an alias for `Reg<OPTKEYR_SPEC>`
    pub type OPTKEYR = crate::Reg<optkeyr::OPTKEYR_SPEC>;
    ///Flash option key register
    pub mod optkeyr {
        ///Register `OPTKEYR` writer
        pub struct W(crate::W<OPTKEYR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OPTKEYR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<OPTKEYR_SPEC>> for W {
            fn from(writer: crate::W<OPTKEYR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OPTKEY` writer - Option byte key
        pub struct OPTKEY_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTKEY_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:31 - Option byte key
            #[inline(always)]
            pub fn optkey(&mut self) -> OPTKEY_W {
                OPTKEY_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash option key register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [optkeyr](index.html) module
        pub struct OPTKEYR_SPEC;
        impl crate::RegisterSpec for OPTKEYR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [optkeyr::W](W) writer structure
        impl crate::Writable for OPTKEYR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets OPTKEYR to value 0
        impl crate::Resettable for OPTKEYR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///Status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `EOP` reader - End of operation
        pub struct EOP_R(crate::FieldReader<bool, bool>);
        impl EOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                EOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EOP` writer - End of operation
        pub struct EOP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `WRPRTERR` reader - Write protection error
        pub struct WRPRTERR_R(crate::FieldReader<bool, bool>);
        impl WRPRTERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                WRPRTERR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WRPRTERR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WRPRTERR` writer - Write protection error
        pub struct WRPRTERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> WRPRTERR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `PGERR` reader - Programming error
        pub struct PGERR_R(crate::FieldReader<bool, bool>);
        impl PGERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                PGERR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PGERR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PGERR` writer - Programming error
        pub struct PGERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PGERR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `BSY` reader - Busy
        pub struct BSY_R(crate::FieldReader<bool, bool>);
        impl BSY_R {
            pub(crate) fn new(bits: bool) -> Self {
                BSY_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BSY_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 5 - End of operation
            #[inline(always)]
            pub fn eop(&self) -> EOP_R {
                EOP_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            pub fn wrprterr(&self) -> WRPRTERR_R {
                WRPRTERR_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 2 - Programming error
            #[inline(always)]
            pub fn pgerr(&self) -> PGERR_R {
                PGERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 0 - Busy
            #[inline(always)]
            pub fn bsy(&self) -> BSY_R {
                BSY_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 5 - End of operation
            #[inline(always)]
            pub fn eop(&mut self) -> EOP_W {
                EOP_W { w: self }
            }
            ///Bit 4 - Write protection error
            #[inline(always)]
            pub fn wrprterr(&mut self) -> WRPRTERR_W {
                WRPRTERR_W { w: self }
            }
            ///Bit 2 - Programming error
            #[inline(always)]
            pub fn pgerr(&mut self) -> PGERR_W {
                PGERR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR register accessor: an alias for `Reg<CR_SPEC>`
    pub type CR = crate::Reg<cr::CR_SPEC>;
    ///Control register
    pub mod cr {
        ///Register `CR` reader
        pub struct R(crate::R<CR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR_SPEC>> for R {
            fn from(reader: crate::R<CR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR` writer
        pub struct W(crate::W<CR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR_SPEC>> for W {
            fn from(writer: crate::W<CR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PG` reader - Programming
        pub struct PG_R(crate::FieldReader<bool, bool>);
        impl PG_R {
            pub(crate) fn new(bits: bool) -> Self {
                PG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PG_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PG` writer - Programming
        pub struct PG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `PER` reader - Page Erase
        pub struct PER_R(crate::FieldReader<bool, bool>);
        impl PER_R {
            pub(crate) fn new(bits: bool) -> Self {
                PER_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PER_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PER` writer - Page Erase
        pub struct PER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PER_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `MER` reader - Mass Erase
        pub struct MER_R(crate::FieldReader<bool, bool>);
        impl MER_R {
            pub(crate) fn new(bits: bool) -> Self {
                MER_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MER_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MER` writer - Mass Erase
        pub struct MER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MER_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `OPTPG` reader - Option byte programming
        pub struct OPTPG_R(crate::FieldReader<bool, bool>);
        impl OPTPG_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPTPG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OPTPG_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPTPG` writer - Option byte programming
        pub struct OPTPG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTPG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `OPTER` reader - Option byte erase
        pub struct OPTER_R(crate::FieldReader<bool, bool>);
        impl OPTER_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPTER_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OPTER_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPTER` writer - Option byte erase
        pub struct OPTER_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTER_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `STRT` reader - Start
        pub struct STRT_R(crate::FieldReader<bool, bool>);
        impl STRT_R {
            pub(crate) fn new(bits: bool) -> Self {
                STRT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for STRT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `STRT` writer - Start
        pub struct STRT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> STRT_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `LOCK` reader - Lock
        pub struct LOCK_R(crate::FieldReader<bool, bool>);
        impl LOCK_R {
            pub(crate) fn new(bits: bool) -> Self {
                LOCK_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LOCK_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LOCK` writer - Lock
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `OPTWRE` reader - Option bytes write enable
        pub struct OPTWRE_R(crate::FieldReader<bool, bool>);
        impl OPTWRE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPTWRE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OPTWRE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPTWRE` writer - Option bytes write enable
        pub struct OPTWRE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPTWRE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `ERRIE` reader - Error interrupt enable
        pub struct ERRIE_R(crate::FieldReader<bool, bool>);
        impl ERRIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ERRIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ERRIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ERRIE` writer - Error interrupt enable
        pub struct ERRIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ERRIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `EOPIE` reader - End of operation interrupt enable
        pub struct EOPIE_R(crate::FieldReader<bool, bool>);
        impl EOPIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                EOPIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for EOPIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `EOPIE` writer - End of operation interrupt enable
        pub struct EOPIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> EOPIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Programming
            #[inline(always)]
            pub fn pg(&self) -> PG_R {
                PG_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            pub fn per(&self) -> PER_R {
                PER_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            pub fn mer(&self) -> MER_R {
                MER_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            pub fn optpg(&self) -> OPTPG_R {
                OPTPG_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            pub fn opter(&self) -> OPTER_R {
                OPTER_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Start
            #[inline(always)]
            pub fn strt(&self) -> STRT_R {
                STRT_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Lock
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            pub fn optwre(&self) -> OPTWRE_R {
                OPTWRE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&self) -> ERRIE_R {
                ERRIE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            pub fn eopie(&self) -> EOPIE_R {
                EOPIE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Programming
            #[inline(always)]
            pub fn pg(&mut self) -> PG_W {
                PG_W { w: self }
            }
            ///Bit 1 - Page Erase
            #[inline(always)]
            pub fn per(&mut self) -> PER_W {
                PER_W { w: self }
            }
            ///Bit 2 - Mass Erase
            #[inline(always)]
            pub fn mer(&mut self) -> MER_W {
                MER_W { w: self }
            }
            ///Bit 4 - Option byte programming
            #[inline(always)]
            pub fn optpg(&mut self) -> OPTPG_W {
                OPTPG_W { w: self }
            }
            ///Bit 5 - Option byte erase
            #[inline(always)]
            pub fn opter(&mut self) -> OPTER_W {
                OPTER_W { w: self }
            }
            ///Bit 6 - Start
            #[inline(always)]
            pub fn strt(&mut self) -> STRT_W {
                STRT_W { w: self }
            }
            ///Bit 7 - Lock
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            ///Bit 9 - Option bytes write enable
            #[inline(always)]
            pub fn optwre(&mut self) -> OPTWRE_W {
                OPTWRE_W { w: self }
            }
            ///Bit 10 - Error interrupt enable
            #[inline(always)]
            pub fn errie(&mut self) -> ERRIE_W {
                ERRIE_W { w: self }
            }
            ///Bit 12 - End of operation interrupt enable
            #[inline(always)]
            pub fn eopie(&mut self) -> EOPIE_W {
                EOPIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr](index.html) module
        pub struct CR_SPEC;
        impl crate::RegisterSpec for CR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr::R](R) reader structure
        impl crate::Readable for CR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr::W](W) writer structure
        impl crate::Writable for CR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR to value 0x80
        impl crate::Resettable for CR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x80
            }
        }
    }
    ///AR register accessor: an alias for `Reg<AR_SPEC>`
    pub type AR = crate::Reg<ar::AR_SPEC>;
    ///Flash address register
    pub mod ar {
        ///Register `AR` writer
        pub struct W(crate::W<AR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<AR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<AR_SPEC>> for W {
            fn from(writer: crate::W<AR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `FAR` writer - Flash Address
        pub struct FAR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FAR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff_ffff) | (value as u32 & 0xffff_ffff);
                self.w
            }
        }
        impl W {
            ///Bits 0:31 - Flash Address
            #[inline(always)]
            pub fn far(&mut self) -> FAR_W {
                FAR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Flash address register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ar](index.html) module
        pub struct AR_SPEC;
        impl crate::RegisterSpec for AR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [ar::W](W) writer structure
        impl crate::Writable for AR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets AR to value 0
        impl crate::Resettable for AR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///OBR register accessor: an alias for `Reg<OBR_SPEC>`
    pub type OBR = crate::Reg<obr::OBR_SPEC>;
    ///Option byte register
    pub mod obr {
        ///Register `OBR` reader
        pub struct R(crate::R<OBR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OBR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<OBR_SPEC>> for R {
            fn from(reader: crate::R<OBR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `OPTERR` reader - Option byte error
        pub struct OPTERR_R(crate::FieldReader<bool, bool>);
        impl OPTERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPTERR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OPTERR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RDPRT` reader - Read protection
        pub struct RDPRT_R(crate::FieldReader<bool, bool>);
        impl RDPRT_R {
            pub(crate) fn new(bits: bool) -> Self {
                RDPRT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RDPRT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `WDG_SW` reader - WDG_SW
        pub struct WDG_SW_R(crate::FieldReader<bool, bool>);
        impl WDG_SW_R {
            pub(crate) fn new(bits: bool) -> Self {
                WDG_SW_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WDG_SW_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `nRST_STOP` reader - nRST_STOP
        pub struct NRST_STOP_R(crate::FieldReader<bool, bool>);
        impl NRST_STOP_R {
            pub(crate) fn new(bits: bool) -> Self {
                NRST_STOP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for NRST_STOP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `nRST_STDBY` reader - nRST_STDBY
        pub struct NRST_STDBY_R(crate::FieldReader<bool, bool>);
        impl NRST_STDBY_R {
            pub(crate) fn new(bits: bool) -> Self {
                NRST_STDBY_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for NRST_STDBY_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `Data0` reader - Data0
        pub struct DATA0_R(crate::FieldReader<u8, u8>);
        impl DATA0_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATA0_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATA0_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `Data1` reader - Data1
        pub struct DATA1_R(crate::FieldReader<u8, u8>);
        impl DATA1_R {
            pub(crate) fn new(bits: u8) -> Self {
                DATA1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DATA1_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 0 - Option byte error
            #[inline(always)]
            pub fn opterr(&self) -> OPTERR_R {
                OPTERR_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Read protection
            #[inline(always)]
            pub fn rdprt(&self) -> RDPRT_R {
                RDPRT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - WDG_SW
            #[inline(always)]
            pub fn wdg_sw(&self) -> WDG_SW_R {
                WDG_SW_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - nRST_STOP
            #[inline(always)]
            pub fn n_rst_stop(&self) -> NRST_STOP_R {
                NRST_STOP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - nRST_STDBY
            #[inline(always)]
            pub fn n_rst_stdby(&self) -> NRST_STDBY_R {
                NRST_STDBY_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bits 10:17 - Data0
            #[inline(always)]
            pub fn data0(&self) -> DATA0_R {
                DATA0_R::new(((self.bits >> 10) & 0xff) as u8)
            }
            ///Bits 18:25 - Data1
            #[inline(always)]
            pub fn data1(&self) -> DATA1_R {
                DATA1_R::new(((self.bits >> 18) & 0xff) as u8)
            }
        }
        ///Option byte register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [obr](index.html) module
        pub struct OBR_SPEC;
        impl crate::RegisterSpec for OBR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [obr::R](R) reader structure
        impl crate::Readable for OBR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets OBR to value 0x03ff_fffc
        impl crate::Resettable for OBR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0x03ff_fffc
            }
        }
    }
    ///WRPR register accessor: an alias for `Reg<WRPR_SPEC>`
    pub type WRPR = crate::Reg<wrpr::WRPR_SPEC>;
    ///Write protection register
    pub mod wrpr {
        ///Register `WRPR` reader
        pub struct R(crate::R<WRPR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<WRPR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<WRPR_SPEC>> for R {
            fn from(reader: crate::R<WRPR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `WRP` reader - Write protect
        pub struct WRP_R(crate::FieldReader<u32, u32>);
        impl WRP_R {
            pub(crate) fn new(bits: u32) -> Self {
                WRP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for WRP_R {
            type Target = crate::FieldReader<u32, u32>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:31 - Write protect
            #[inline(always)]
            pub fn wrp(&self) -> WRP_R {
                WRP_R::new((self.bits & 0xffff_ffff) as u32)
            }
        }
        ///Write protection register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [wrpr](index.html) module
        pub struct WRPR_SPEC;
        impl crate::RegisterSpec for WRPR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [wrpr::R](R) reader structure
        impl crate::Readable for WRPR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets WRPR to value 0xffff_ffff
        impl crate::Resettable for WRPR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0xffff_ffff
            }
        }
    }
}
///General purpose timers
pub struct TIM15 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM15 {}
impl TIM15 {
    ///Pointer to the register block
    pub const PTR: *const tim15::RegisterBlock = 0x4001_4000 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim15::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM15 {
    type Target = tim15::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM15 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM15").finish()
    }
}
///General purpose timers
pub mod tim15 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        ///0x08 - slave mode control register
        pub smcr: crate::Reg<smcr::SMCR_SPEC>,
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_6_ccmr1: [u8; 4usize],
        _reserved7: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        ///0x30 - repetition counter register
        pub rcr: crate::Reg<rcr::RCR_SPEC>,
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr1::CCR1_SPEC>,
        ///0x38 - capture/compare register 2
        pub ccr2: crate::Reg<ccr2::CCR2_SPEC>,
        _reserved14: [u8; 8usize],
        ///0x44 - break and dead-time register
        pub bdtr: crate::Reg<bdtr::BDTR_SPEC>,
        ///0x48 - DMA control register
        pub dcr: crate::Reg<dcr::DCR_SPEC>,
        ///0x4c - DMA address for full transfer
        pub dmar: crate::Reg<dmar::DMAR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, bool>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OIS2` reader - Output Idle state 2
        pub struct OIS2_R(crate::FieldReader<bool, bool>);
        impl OIS2_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS2_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS2` writer - Output Idle state 2
        pub struct OIS2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS2_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `OIS1N` reader - Output Idle state 1
        pub struct OIS1N_R(crate::FieldReader<bool, bool>);
        impl OIS1N_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1N_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS1N_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1N` writer - Output Idle state 1
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `OIS1` reader - Output Idle state 1
        pub struct OIS1_R(crate::FieldReader<bool, bool>);
        impl OIS1_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OIS1_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1` writer - Output Idle state 1
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `MMS` reader - Master mode selection
        pub struct MMS_R(crate::FieldReader<u8, u8>);
        impl MMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                MMS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MMS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MMS` writer - Master mode selection
        pub struct MMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MMS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub struct CCDS_R(crate::FieldReader<bool, bool>);
        impl CCDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCDS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCDS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CCUS` reader - Capture/compare control update selection
        pub struct CCUS_R(crate::FieldReader<bool, bool>);
        impl CCUS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCUS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCUS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCUS` writer - Capture/compare control update selection
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub struct CCPC_R(crate::FieldReader<bool, bool>);
        impl CCPC_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCPC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCPC_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&self) -> OIS2_R {
                OIS2_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&self) -> MMS_R {
                MMS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 10 - Output Idle state 2
            #[inline(always)]
            pub fn ois2(&mut self) -> OIS2_W {
                OIS2_W { w: self }
            }
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            ///Bits 4:6 - Master mode selection
            #[inline(always)]
            pub fn mms(&mut self) -> MMS_W {
                MMS_W { w: self }
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SMCR register accessor: an alias for `Reg<SMCR_SPEC>`
    pub type SMCR = crate::Reg<smcr::SMCR_SPEC>;
    ///slave mode control register
    pub mod smcr {
        ///Register `SMCR` reader
        pub struct R(crate::R<SMCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SMCR_SPEC>> for R {
            fn from(reader: crate::R<SMCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SMCR` writer
        pub struct W(crate::W<SMCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SMCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SMCR_SPEC>> for W {
            fn from(writer: crate::W<SMCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MSM` reader - Master/Slave mode
        pub struct MSM_R(crate::FieldReader<bool, bool>);
        impl MSM_R {
            pub(crate) fn new(bits: bool) -> Self {
                MSM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MSM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MSM` writer - Master/Slave mode
        pub struct MSM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MSM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TS` reader - Trigger selection
        pub struct TS_R(crate::FieldReader<u8, u8>);
        impl TS_R {
            pub(crate) fn new(bits: u8) -> Self {
                TS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TS` writer - Trigger selection
        pub struct TS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `SMS` reader - Slave mode selection
        pub struct SMS_R(crate::FieldReader<u8, u8>);
        impl SMS_R {
            pub(crate) fn new(bits: u8) -> Self {
                SMS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SMS_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SMS` writer - Slave mode selection
        pub struct SMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> SMS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x07) | (value as u32 & 0x07);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&self) -> MSM_R {
                MSM_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&self) -> TS_R {
                TS_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&self) -> SMS_R {
                SMS_R::new((self.bits & 0x07) as u8)
            }
        }
        impl W {
            ///Bit 7 - Master/Slave mode
            #[inline(always)]
            pub fn msm(&mut self) -> MSM_W {
                MSM_W { w: self }
            }
            ///Bits 4:6 - Trigger selection
            #[inline(always)]
            pub fn ts(&mut self) -> TS_W {
                TS_W { w: self }
            }
            ///Bits 0:2 - Slave mode selection
            #[inline(always)]
            pub fn sms(&mut self) -> SMS_W {
                SMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///slave mode control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [smcr](index.html) module
        pub struct SMCR_SPEC;
        impl crate::RegisterSpec for SMCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [smcr::R](R) reader structure
        impl crate::Readable for SMCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [smcr::W](W) writer structure
        impl crate::Writable for SMCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SMCR to value 0
        impl crate::Resettable for SMCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TDE` reader - Trigger DMA request enable
        pub struct TDE_R(crate::FieldReader<bool, bool>);
        impl TDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TDE` writer - Trigger DMA request enable
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `CC2DE` reader - Capture/Compare 2 DMA request enable
        pub struct CC2DE_R(crate::FieldReader<bool, bool>);
        impl CC2DE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2DE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2DE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2DE` writer - Capture/Compare 2 DMA request enable
        pub struct CC2DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2DE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub struct CC1DE_R(crate::FieldReader<bool, bool>);
        impl CC1DE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1DE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1DE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `UDE` reader - Update DMA request enable
        pub struct UDE_R(crate::FieldReader<bool, bool>);
        impl UDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for UDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Field `BIE` reader - Break interrupt enable
        pub struct BIE_R(crate::FieldReader<bool, bool>);
        impl BIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIE` writer - Break interrupt enable
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TIE` reader - Trigger interrupt enable
        pub struct TIE_R(crate::FieldReader<bool, bool>);
        impl TIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIE` writer - Trigger interrupt enable
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMIE` reader - COM interrupt enable
        pub struct COMIE_R(crate::FieldReader<bool, bool>);
        impl COMIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIE` writer - COM interrupt enable
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2IE` reader - Capture/Compare 2 interrupt enable
        pub struct CC2IE_R(crate::FieldReader<bool, bool>);
        impl CC2IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2IE` writer - Capture/Compare 2 interrupt enable
        pub struct CC2IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub struct CC1IE_R(crate::FieldReader<bool, bool>);
        impl CC1IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&self) -> CC2DE_R {
                CC2DE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&self) -> CC2IE_R {
                CC2IE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            ///Bit 10 - Capture/Compare 2 DMA request enable
            #[inline(always)]
            pub fn cc2de(&mut self) -> CC2DE_W {
                CC2DE_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt enable
            #[inline(always)]
            pub fn cc2ie(&mut self) -> CC2IE_W {
                CC2IE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC2OF` reader - Capture/compare 2 overcapture flag
        pub struct CC2OF_R(crate::FieldReader<bool, bool>);
        impl CC2OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2OF` writer - Capture/compare 2 overcapture flag
        pub struct CC2OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub struct CC1OF_R(crate::FieldReader<bool, bool>);
        impl CC1OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `BIF` reader - Break interrupt flag
        pub struct BIF_R(crate::FieldReader<bool, bool>);
        impl BIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIF` writer - Break interrupt flag
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TIF` reader - Trigger interrupt flag
        pub struct TIF_R(crate::FieldReader<bool, bool>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIF` writer - Trigger interrupt flag
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMIF` reader - COM interrupt flag
        pub struct COMIF_R(crate::FieldReader<bool, bool>);
        impl COMIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIF` writer - COM interrupt flag
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2IF` reader - Capture/Compare 2 interrupt flag
        pub struct CC2IF_R(crate::FieldReader<bool, bool>);
        impl CC2IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2IF` writer - Capture/Compare 2 interrupt flag
        pub struct CC2IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub struct CC1IF_R(crate::FieldReader<bool, bool>);
        impl CC1IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&self) -> CC2OF_R {
                CC2OF_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&self) -> CC2IF_R {
                CC2IF_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 10 - Capture/compare 2 overcapture flag
            #[inline(always)]
            pub fn cc2of(&mut self) -> CC2OF_W {
                CC2OF_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            ///Bit 2 - Capture/Compare 2 interrupt flag
            #[inline(always)]
            pub fn cc2if(&mut self) -> CC2IF_W {
                CC2IF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BG` writer - Break generation
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TG` writer - Trigger generation
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMG` writer - Capture/Compare control update generation
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2G` writer - Capture/compare 2 generation
        pub struct CC2G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 7 - Break generation
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            ///Bit 2 - Capture/compare 2 generation
            #[inline(always)]
            pub fn cc2g(&mut self) -> CC2G_W {
                CC2G_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC2M` reader - Output Compare 2 mode
        pub struct OC2M_R(crate::FieldReader<u8, u8>);
        impl OC2M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC2M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2M` writer - Output Compare 2 mode
        pub struct OC2M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 12)) | ((value as u32 & 0x07) << 12);
                self.w
            }
        }
        ///Field `OC2PE` reader - Output Compare 2 preload enable
        pub struct OC2PE_R(crate::FieldReader<bool, bool>);
        impl OC2PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2PE` writer - Output Compare 2 preload enable
        pub struct OC2PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OC2FE` reader - Output Compare 2 fast enable
        pub struct OC2FE_R(crate::FieldReader<bool, bool>);
        impl OC2FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC2FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC2FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC2FE` writer - Output Compare 2 fast enable
        pub struct OC2FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC2FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, u8>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub struct OC1M_R(crate::FieldReader<u8, u8>);
        impl OC1M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC1M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, bool>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&self) -> OC2M_R {
                OC2M_R::new(((self.bits >> 12) & 0x07) as u8)
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&self) -> OC2PE_R {
                OC2PE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&self) -> OC2FE_R {
                OC2FE_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:14 - Output Compare 2 mode
            #[inline(always)]
            pub fn oc2m(&mut self) -> OC2M_W {
                OC2M_W { w: self }
            }
            ///Bit 11 - Output Compare 2 preload enable
            #[inline(always)]
            pub fn oc2pe(&mut self) -> OC2PE_W {
                OC2PE_W { w: self }
            }
            ///Bit 10 - Output Compare 2 fast enable
            #[inline(always)]
            pub fn oc2fe(&mut self) -> OC2FE_W {
                OC2FE_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC2F` reader - Input capture 2 filter
        pub struct IC2F_R(crate::FieldReader<u8, u8>);
        impl IC2F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2F` writer - Input capture 2 filter
        pub struct IC2F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 12)) | ((value as u32 & 0x0f) << 12);
                self.w
            }
        }
        ///Field `IC2PSC` reader - Input capture 2 prescaler
        pub struct IC2PSC_R(crate::FieldReader<u8, u8>);
        impl IC2PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC2PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC2PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC2PSC` writer - Input capture 2 prescaler
        pub struct IC2PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC2PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 10)) | ((value as u32 & 0x03) << 10);
                self.w
            }
        }
        ///Field `CC2S` reader - Capture/Compare 2 selection
        pub struct CC2S_R(crate::FieldReader<u8, u8>);
        impl CC2S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC2S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2S` writer - Capture/Compare 2 selection
        pub struct CC2S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, u8>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&self) -> IC2F_R {
                IC2F_R::new(((self.bits >> 12) & 0x0f) as u8)
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&self) -> IC2PSC_R {
                IC2PSC_R::new(((self.bits >> 10) & 0x03) as u8)
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&self) -> CC2S_R {
                CC2S_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 12:15 - Input capture 2 filter
            #[inline(always)]
            pub fn ic2f(&mut self) -> IC2F_W {
                IC2F_W { w: self }
            }
            ///Bits 10:11 - Input capture 2 prescaler
            #[inline(always)]
            pub fn ic2psc(&mut self) -> IC2PSC_W {
                IC2PSC_W { w: self }
            }
            ///Bits 8:9 - Capture/Compare 2 selection
            #[inline(always)]
            pub fn cc2s(&mut self) -> CC2S_W {
                CC2S_W { w: self }
            }
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC2NP` reader - Capture/Compare 2 output Polarity
        pub struct CC2NP_R(crate::FieldReader<bool, bool>);
        impl CC2NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2NP` writer - Capture/Compare 2 output Polarity
        pub struct CC2NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `CC2P` reader - Capture/Compare 2 output Polarity
        pub struct CC2P_R(crate::FieldReader<bool, bool>);
        impl CC2P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2P` writer - Capture/Compare 2 output Polarity
        pub struct CC2P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC2E` reader - Capture/Compare 2 output enable
        pub struct CC2E_R(crate::FieldReader<bool, bool>);
        impl CC2E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC2E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC2E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC2E` writer - Capture/Compare 2 output enable
        pub struct CC2E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC2E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub struct CC1NP_R(crate::FieldReader<bool, bool>);
        impl CC1NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub struct CC1NE_R(crate::FieldReader<bool, bool>);
        impl CC1NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&self) -> CC2NP_R {
                CC2NP_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&self) -> CC2P_R {
                CC2P_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&self) -> CC2E_R {
                CC2E_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 7 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2np(&mut self) -> CC2NP_W {
                CC2NP_W { w: self }
            }
            ///Bit 5 - Capture/Compare 2 output Polarity
            #[inline(always)]
            pub fn cc2p(&mut self) -> CC2P_W {
                CC2P_W { w: self }
            }
            ///Bit 4 - Capture/Compare 2 output enable
            #[inline(always)]
            pub fn cc2e(&mut self) -> CC2E_W {
                CC2E_W { w: self }
            }
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RCR register accessor: an alias for `Reg<RCR_SPEC>`
    pub type RCR = crate::Reg<rcr::RCR_SPEC>;
    ///repetition counter register
    pub mod rcr {
        ///Register `RCR` reader
        pub struct R(crate::R<RCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RCR_SPEC>> for R {
            fn from(reader: crate::R<RCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RCR` writer
        pub struct W(crate::W<RCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RCR_SPEC>> for W {
            fn from(writer: crate::W<RCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `REP` reader - Repetition counter value
        pub struct REP_R(crate::FieldReader<u8, u8>);
        impl REP_R {
            pub(crate) fn new(bits: u8) -> Self {
                REP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for REP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `REP` writer - Repetition counter value
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rcr](index.html) module
        pub struct RCR_SPEC;
        impl crate::RegisterSpec for RCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rcr::R](R) reader structure
        impl crate::Readable for RCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rcr::W](W) writer structure
        impl crate::Writable for RCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RCR to value 0
        impl crate::Resettable for RCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR1 register accessor: an alias for `Reg<CCR1_SPEC>`
    pub type CCR1 = crate::Reg<ccr1::CCR1_SPEC>;
    ///capture/compare register 1
    pub mod ccr1 {
        ///Register `CCR1` reader
        pub struct R(crate::R<CCR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR1_SPEC>> for R {
            fn from(reader: crate::R<CCR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR1` writer
        pub struct W(crate::W<CCR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR1_SPEC>> for W {
            fn from(writer: crate::W<CCR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub struct CCR1_R(crate::FieldReader<u16, u16>);
        impl CCR1_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR1_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub struct CCR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&mut self) -> CCR1_W {
                CCR1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr1](index.html) module
        pub struct CCR1_SPEC;
        impl crate::RegisterSpec for CCR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr1::R](R) reader structure
        impl crate::Readable for CCR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr1::W](W) writer structure
        impl crate::Writable for CCR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR1 to value 0
        impl crate::Resettable for CCR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR2 register accessor: an alias for `Reg<CCR2_SPEC>`
    pub type CCR2 = crate::Reg<ccr2::CCR2_SPEC>;
    ///capture/compare register 2
    pub mod ccr2 {
        ///Register `CCR2` reader
        pub struct R(crate::R<CCR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR2_SPEC>> for R {
            fn from(reader: crate::R<CCR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR2` writer
        pub struct W(crate::W<CCR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR2_SPEC>> for W {
            fn from(writer: crate::W<CCR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR2` reader - Capture/Compare 2 value
        pub struct CCR2_R(crate::FieldReader<u16, u16>);
        impl CCR2_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR2_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR2_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR2` writer - Capture/Compare 2 value
        pub struct CCR2_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR2_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&self) -> CCR2_R {
                CCR2_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 2 value
            #[inline(always)]
            pub fn ccr2(&mut self) -> CCR2_W {
                CCR2_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr2](index.html) module
        pub struct CCR2_SPEC;
        impl crate::RegisterSpec for CCR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr2::R](R) reader structure
        impl crate::Readable for CCR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr2::W](W) writer structure
        impl crate::Writable for CCR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR2 to value 0
        impl crate::Resettable for CCR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BDTR register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BDTR_SPEC>> for R {
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BDTR_SPEC>> for W {
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MOE` reader - Main output enable
        pub struct MOE_R(crate::FieldReader<bool, bool>);
        impl MOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                MOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MOE` writer - Main output enable
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `AOE` reader - Automatic output enable
        pub struct AOE_R(crate::FieldReader<bool, bool>);
        impl AOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                AOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for AOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AOE` writer - Automatic output enable
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `BKP` reader - Break polarity
        pub struct BKP_R(crate::FieldReader<bool, bool>);
        impl BKP_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKP` writer - Break polarity
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `BKE` reader - Break enable
        pub struct BKE_R(crate::FieldReader<bool, bool>);
        impl BKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKE` writer - Break enable
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub struct OSSR_R(crate::FieldReader<bool, bool>);
        impl OSSR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OSSR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub struct OSSI_R(crate::FieldReader<bool, bool>);
        impl OSSI_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSI_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OSSI_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `LOCK` reader - Lock configuration
        pub struct LOCK_R(crate::FieldReader<u8, u8>);
        impl LOCK_R {
            pub(crate) fn new(bits: u8) -> Self {
                LOCK_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LOCK_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LOCK` writer - Lock configuration
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub struct DTG_R(crate::FieldReader<u8, u8>);
        impl DTG_R {
            pub(crate) fn new(bits: u8) -> Self {
                DTG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DTG_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DTG` writer - Dead-time generator setup
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DCR register accessor: an alias for `Reg<DCR_SPEC>`
    pub type DCR = crate::Reg<dcr::DCR_SPEC>;
    ///DMA control register
    pub mod dcr {
        ///Register `DCR` reader
        pub struct R(crate::R<DCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DCR_SPEC>> for R {
            fn from(reader: crate::R<DCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DCR` writer
        pub struct W(crate::W<DCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DCR_SPEC>> for W {
            fn from(writer: crate::W<DCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBL` reader - DMA burst length
        pub struct DBL_R(crate::FieldReader<u8, u8>);
        impl DBL_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBL` writer - DMA burst length
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | ((value as u32 & 0x1f) << 8);
                self.w
            }
        }
        ///Field `DBA` reader - DMA base address
        pub struct DBA_R(crate::FieldReader<u8, u8>);
        impl DBA_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBA_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBA` writer - DMA base address
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dcr](index.html) module
        pub struct DCR_SPEC;
        impl crate::RegisterSpec for DCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dcr::R](R) reader structure
        impl crate::Readable for DCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dcr::W](W) writer structure
        impl crate::Writable for DCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DCR to value 0
        impl crate::Resettable for DCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DMAR register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DMAR_SPEC>> for R {
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DMAR_SPEC>> for W {
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub struct DMAB_R(crate::FieldReader<u16, u16>);
        impl DMAB_R {
            pub(crate) fn new(bits: u16) -> Self {
                DMAB_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DMAB_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAB` writer - DMA register for burst accesses
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General-purpose-timers
pub struct TIM16 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM16 {}
impl TIM16 {
    ///Pointer to the register block
    pub const PTR: *const tim16::RegisterBlock = 0x4001_4400 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim16::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM16 {
    type Target = tim16::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM16 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM16").finish()
    }
}
///General-purpose-timers
pub mod tim16 {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - control register 1
        pub cr1: crate::Reg<cr1::CR1_SPEC>,
        ///0x04 - control register 2
        pub cr2: crate::Reg<cr2::CR2_SPEC>,
        _reserved2: [u8; 4usize],
        ///0x0c - DMA/Interrupt enable register
        pub dier: crate::Reg<dier::DIER_SPEC>,
        ///0x10 - status register
        pub sr: crate::Reg<sr::SR_SPEC>,
        ///0x14 - event generation register
        pub egr: crate::Reg<egr::EGR_SPEC>,
        _reserved_5_ccmr1: [u8; 4usize],
        _reserved6: [u8; 4usize],
        ///0x20 - capture/compare enable register
        pub ccer: crate::Reg<ccer::CCER_SPEC>,
        ///0x24 - counter
        pub cnt: crate::Reg<cnt::CNT_SPEC>,
        ///0x28 - prescaler
        pub psc: crate::Reg<psc::PSC_SPEC>,
        ///0x2c - auto-reload register
        pub arr: crate::Reg<arr::ARR_SPEC>,
        ///0x30 - repetition counter register
        pub rcr: crate::Reg<rcr::RCR_SPEC>,
        ///0x34 - capture/compare register 1
        pub ccr1: crate::Reg<ccr1::CCR1_SPEC>,
        _reserved12: [u8; 12usize],
        ///0x44 - break and dead-time register
        pub bdtr: crate::Reg<bdtr::BDTR_SPEC>,
        ///0x48 - DMA control register
        pub dcr: crate::Reg<dcr::DCR_SPEC>,
        ///0x4c - DMA address for full transfer
        pub dmar: crate::Reg<dmar::DMAR_SPEC>,
    }
    impl RegisterBlock {
        ///0x18 - capture/compare mode register 1 (input mode)
        #[inline(always)]
        pub fn ccmr1_input(&self) -> &crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>)
            }
        }
        ///0x18 - capture/compare mode register (output mode)
        #[inline(always)]
        pub fn ccmr1_output(&self) -> &crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC> {
            unsafe {
                &*(((self as *const Self) as *const u8).add(24usize)
                    as *const crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>)
            }
        }
    }
    ///CR1 register accessor: an alias for `Reg<CR1_SPEC>`
    pub type CR1 = crate::Reg<cr1::CR1_SPEC>;
    ///control register 1
    pub mod cr1 {
        ///Register `CR1` reader
        pub struct R(crate::R<CR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR1_SPEC>> for R {
            fn from(reader: crate::R<CR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR1` writer
        pub struct W(crate::W<CR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR1_SPEC>> for W {
            fn from(writer: crate::W<CR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Clock division
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        #[repr(u8)]
        pub enum CKD_A {
            ///0: t_DTS = t_CK_INT
            DIV1 = 0,
            ///1: t_DTS = 2 × t_CK_INT
            DIV2 = 1,
            ///2: t_DTS = 4 × t_CK_INT
            DIV4 = 2,
        }
        impl From<CKD_A> for u8 {
            #[inline(always)]
            fn from(variant: CKD_A) -> Self {
                variant as _
            }
        }
        ///Field `CKD` reader - Clock division
        pub struct CKD_R(crate::FieldReader<u8, CKD_A>);
        impl CKD_R {
            pub(crate) fn new(bits: u8) -> Self {
                CKD_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> Option<CKD_A> {
                match self.bits {
                    0 => Some(CKD_A::DIV1),
                    1 => Some(CKD_A::DIV2),
                    2 => Some(CKD_A::DIV4),
                    _ => None,
                }
            }
            ///Checks if the value of the field is `DIV1`
            #[inline(always)]
            pub fn is_div1(&self) -> bool {
                **self == CKD_A::DIV1
            }
            ///Checks if the value of the field is `DIV2`
            #[inline(always)]
            pub fn is_div2(&self) -> bool {
                **self == CKD_A::DIV2
            }
            ///Checks if the value of the field is `DIV4`
            #[inline(always)]
            pub fn is_div4(&self) -> bool {
                **self == CKD_A::DIV4
            }
        }
        impl core::ops::Deref for CKD_R {
            type Target = crate::FieldReader<u8, CKD_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CKD` writer - Clock division
        pub struct CKD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CKD_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CKD_A) -> &'a mut W {
                unsafe { self.bits(variant.into()) }
            }
            ///t_DTS = t_CK_INT
            #[inline(always)]
            pub fn div1(self) -> &'a mut W {
                self.variant(CKD_A::DIV1)
            }
            ///t_DTS = 2 × t_CK_INT
            #[inline(always)]
            pub fn div2(self) -> &'a mut W {
                self.variant(CKD_A::DIV2)
            }
            ///t_DTS = 4 × t_CK_INT
            #[inline(always)]
            pub fn div4(self) -> &'a mut W {
                self.variant(CKD_A::DIV4)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Auto-reload preload enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum ARPE_A {
            ///0: TIMx_APRR register is not buffered
            DISABLED = 0,
            ///1: TIMx_APRR register is buffered
            ENABLED = 1,
        }
        impl From<ARPE_A> for bool {
            #[inline(always)]
            fn from(variant: ARPE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `ARPE` reader - Auto-reload preload enable
        pub struct ARPE_R(crate::FieldReader<bool, ARPE_A>);
        impl ARPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ARPE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> ARPE_A {
                match self.bits {
                    false => ARPE_A::DISABLED,
                    true => ARPE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == ARPE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == ARPE_A::ENABLED
            }
        }
        impl core::ops::Deref for ARPE_R {
            type Target = crate::FieldReader<bool, ARPE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARPE` writer - Auto-reload preload enable
        pub struct ARPE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARPE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: ARPE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///TIMx_APRR register is not buffered
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(ARPE_A::DISABLED)
            }
            ///TIMx_APRR register is buffered
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(ARPE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///One-pulse mode
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OPM_A {
            ///0: Not stopped at update event
            NOTSTOPPED = 0,
            ///1: Counter stops counting at next update event
            STOPPED = 1,
        }
        impl From<OPM_A> for bool {
            #[inline(always)]
            fn from(variant: OPM_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OPM` reader - One-pulse mode
        pub struct OPM_R(crate::FieldReader<bool, OPM_A>);
        impl OPM_R {
            pub(crate) fn new(bits: bool) -> Self {
                OPM_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OPM_A {
                match self.bits {
                    false => OPM_A::NOTSTOPPED,
                    true => OPM_A::STOPPED,
                }
            }
            ///Checks if the value of the field is `NOTSTOPPED`
            #[inline(always)]
            pub fn is_not_stopped(&self) -> bool {
                **self == OPM_A::NOTSTOPPED
            }
            ///Checks if the value of the field is `STOPPED`
            #[inline(always)]
            pub fn is_stopped(&self) -> bool {
                **self == OPM_A::STOPPED
            }
        }
        impl core::ops::Deref for OPM_R {
            type Target = crate::FieldReader<bool, OPM_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OPM` writer - One-pulse mode
        pub struct OPM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OPM_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OPM_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Not stopped at update event
            #[inline(always)]
            pub fn not_stopped(self) -> &'a mut W {
                self.variant(OPM_A::NOTSTOPPED)
            }
            ///Counter stops counting at next update event
            #[inline(always)]
            pub fn stopped(self) -> &'a mut W {
                self.variant(OPM_A::STOPPED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Update request source
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum URS_A {
            ///0: Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            ANYEVENT = 0,
            ///1: Only counter overflow/underflow generates an update interrupt or DMA request
            COUNTERONLY = 1,
        }
        impl From<URS_A> for bool {
            #[inline(always)]
            fn from(variant: URS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `URS` reader - Update request source
        pub struct URS_R(crate::FieldReader<bool, URS_A>);
        impl URS_R {
            pub(crate) fn new(bits: bool) -> Self {
                URS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> URS_A {
                match self.bits {
                    false => URS_A::ANYEVENT,
                    true => URS_A::COUNTERONLY,
                }
            }
            ///Checks if the value of the field is `ANYEVENT`
            #[inline(always)]
            pub fn is_any_event(&self) -> bool {
                **self == URS_A::ANYEVENT
            }
            ///Checks if the value of the field is `COUNTERONLY`
            #[inline(always)]
            pub fn is_counter_only(&self) -> bool {
                **self == URS_A::COUNTERONLY
            }
        }
        impl core::ops::Deref for URS_R {
            type Target = crate::FieldReader<bool, URS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `URS` writer - Update request source
        pub struct URS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> URS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: URS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Any of counter overflow/underflow, setting UG, or update through slave mode, generates an update interrupt or DMA request
            #[inline(always)]
            pub fn any_event(self) -> &'a mut W {
                self.variant(URS_A::ANYEVENT)
            }
            ///Only counter overflow/underflow generates an update interrupt or DMA request
            #[inline(always)]
            pub fn counter_only(self) -> &'a mut W {
                self.variant(URS_A::COUNTERONLY)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Update disable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UDIS_A {
            ///0: Update event enabled
            ENABLED = 0,
            ///1: Update event disabled
            DISABLED = 1,
        }
        impl From<UDIS_A> for bool {
            #[inline(always)]
            fn from(variant: UDIS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UDIS` reader - Update disable
        pub struct UDIS_R(crate::FieldReader<bool, UDIS_A>);
        impl UDIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDIS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UDIS_A {
                match self.bits {
                    false => UDIS_A::ENABLED,
                    true => UDIS_A::DISABLED,
                }
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UDIS_A::ENABLED
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UDIS_A::DISABLED
            }
        }
        impl core::ops::Deref for UDIS_R {
            type Target = crate::FieldReader<bool, UDIS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDIS` writer - Update disable
        pub struct UDIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDIS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UDIS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update event enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UDIS_A::ENABLED)
            }
            ///Update event disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UDIS_A::DISABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Counter enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CEN_A {
            ///0: Counter disabled
            DISABLED = 0,
            ///1: Counter enabled
            ENABLED = 1,
        }
        impl From<CEN_A> for bool {
            #[inline(always)]
            fn from(variant: CEN_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CEN` reader - Counter enable
        pub struct CEN_R(crate::FieldReader<bool, CEN_A>);
        impl CEN_R {
            pub(crate) fn new(bits: bool) -> Self {
                CEN_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CEN_A {
                match self.bits {
                    false => CEN_A::DISABLED,
                    true => CEN_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CEN_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CEN_A::ENABLED
            }
        }
        impl core::ops::Deref for CEN_R {
            type Target = crate::FieldReader<bool, CEN_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CEN` writer - Counter enable
        pub struct CEN_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CEN_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CEN_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Counter disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CEN_A::DISABLED)
            }
            ///Counter enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CEN_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&self) -> CKD_R {
                CKD_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&self) -> ARPE_R {
                ARPE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&self) -> OPM_R {
                OPM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&self) -> URS_R {
                URS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&self) -> UDIS_R {
                UDIS_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&self) -> CEN_R {
                CEN_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bits 8:9 - Clock division
            #[inline(always)]
            pub fn ckd(&mut self) -> CKD_W {
                CKD_W { w: self }
            }
            ///Bit 7 - Auto-reload preload enable
            #[inline(always)]
            pub fn arpe(&mut self) -> ARPE_W {
                ARPE_W { w: self }
            }
            ///Bit 3 - One-pulse mode
            #[inline(always)]
            pub fn opm(&mut self) -> OPM_W {
                OPM_W { w: self }
            }
            ///Bit 2 - Update request source
            #[inline(always)]
            pub fn urs(&mut self) -> URS_W {
                URS_W { w: self }
            }
            ///Bit 1 - Update disable
            #[inline(always)]
            pub fn udis(&mut self) -> UDIS_W {
                UDIS_W { w: self }
            }
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn cen(&mut self) -> CEN_W {
                CEN_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr1](index.html) module
        pub struct CR1_SPEC;
        impl crate::RegisterSpec for CR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr1::R](R) reader structure
        impl crate::Readable for CR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr1::W](W) writer structure
        impl crate::Writable for CR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR1 to value 0
        impl crate::Resettable for CR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CR2 register accessor: an alias for `Reg<CR2_SPEC>`
    pub type CR2 = crate::Reg<cr2::CR2_SPEC>;
    ///control register 2
    pub mod cr2 {
        ///Register `CR2` reader
        pub struct R(crate::R<CR2_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CR2_SPEC>> for R {
            fn from(reader: crate::R<CR2_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CR2` writer
        pub struct W(crate::W<CR2_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CR2_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CR2_SPEC>> for W {
            fn from(writer: crate::W<CR2_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Output Idle state 1
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1N_A {
            ///0: OC1N=0 after a dead-time when MOE=0
            LOW = 0,
            ///1: OC1N=1 after a dead-time when MOE=0
            HIGH = 1,
        }
        impl From<OIS1N_A> for bool {
            #[inline(always)]
            fn from(variant: OIS1N_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OIS1N` reader - Output Idle state 1
        pub struct OIS1N_R(crate::FieldReader<bool, OIS1N_A>);
        impl OIS1N_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1N_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OIS1N_A {
                match self.bits {
                    false => OIS1N_A::LOW,
                    true => OIS1N_A::HIGH,
                }
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == OIS1N_A::LOW
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == OIS1N_A::HIGH
            }
        }
        impl core::ops::Deref for OIS1N_R {
            type Target = crate::FieldReader<bool, OIS1N_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1N` writer - Output Idle state 1
        pub struct OIS1N_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1N_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OIS1N_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///OC1N=0 after a dead-time when MOE=0
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1N_A::LOW)
            }
            ///OC1N=1 after a dead-time when MOE=0
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1N_A::HIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Output Idle state 1
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum OIS1_A {
            ///0: OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
            LOW = 0,
            ///1: OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
            HIGH = 1,
        }
        impl From<OIS1_A> for bool {
            #[inline(always)]
            fn from(variant: OIS1_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `OIS1` reader - Output Idle state 1
        pub struct OIS1_R(crate::FieldReader<bool, OIS1_A>);
        impl OIS1_R {
            pub(crate) fn new(bits: bool) -> Self {
                OIS1_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> OIS1_A {
                match self.bits {
                    false => OIS1_A::LOW,
                    true => OIS1_A::HIGH,
                }
            }
            ///Checks if the value of the field is `LOW`
            #[inline(always)]
            pub fn is_low(&self) -> bool {
                **self == OIS1_A::LOW
            }
            ///Checks if the value of the field is `HIGH`
            #[inline(always)]
            pub fn is_high(&self) -> bool {
                **self == OIS1_A::HIGH
            }
        }
        impl core::ops::Deref for OIS1_R {
            type Target = crate::FieldReader<bool, OIS1_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OIS1` writer - Output Idle state 1
        pub struct OIS1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OIS1_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: OIS1_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///OC1=0 (after a dead-time if OC1N is implemented) when MOE=0
            #[inline(always)]
            pub fn low(self) -> &'a mut W {
                self.variant(OIS1_A::LOW)
            }
            ///OC1=1 (after a dead-time if OC1N is implemented) when MOE=0
            #[inline(always)]
            pub fn high(self) -> &'a mut W {
                self.variant(OIS1_A::HIGH)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Capture/compare DMA selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCDS_A {
            ///0: CCx DMA request sent when CCx event occurs
            ONCOMPARE = 0,
            ///1: CCx DMA request sent when update event occurs
            ONUPDATE = 1,
        }
        impl From<CCDS_A> for bool {
            #[inline(always)]
            fn from(variant: CCDS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CCDS` reader - Capture/compare DMA selection
        pub struct CCDS_R(crate::FieldReader<bool, CCDS_A>);
        impl CCDS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCDS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCDS_A {
                match self.bits {
                    false => CCDS_A::ONCOMPARE,
                    true => CCDS_A::ONUPDATE,
                }
            }
            ///Checks if the value of the field is `ONCOMPARE`
            #[inline(always)]
            pub fn is_on_compare(&self) -> bool {
                **self == CCDS_A::ONCOMPARE
            }
            ///Checks if the value of the field is `ONUPDATE`
            #[inline(always)]
            pub fn is_on_update(&self) -> bool {
                **self == CCDS_A::ONUPDATE
            }
        }
        impl core::ops::Deref for CCDS_R {
            type Target = crate::FieldReader<bool, CCDS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCDS` writer - Capture/compare DMA selection
        pub struct CCDS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCDS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CCDS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCx DMA request sent when CCx event occurs
            #[inline(always)]
            pub fn on_compare(self) -> &'a mut W {
                self.variant(CCDS_A::ONCOMPARE)
            }
            ///CCx DMA request sent when update event occurs
            #[inline(always)]
            pub fn on_update(self) -> &'a mut W {
                self.variant(CCDS_A::ONUPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Capture/compare control update selection
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCUS_A {
            ///0: Capture/compare are updated only by setting the COMG bit
            DEFAULT = 0,
            ///1: Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI
            WITHRISINGEDGE = 1,
        }
        impl From<CCUS_A> for bool {
            #[inline(always)]
            fn from(variant: CCUS_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CCUS` reader - Capture/compare control update selection
        pub struct CCUS_R(crate::FieldReader<bool, CCUS_A>);
        impl CCUS_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCUS_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCUS_A {
                match self.bits {
                    false => CCUS_A::DEFAULT,
                    true => CCUS_A::WITHRISINGEDGE,
                }
            }
            ///Checks if the value of the field is `DEFAULT`
            #[inline(always)]
            pub fn is_default(&self) -> bool {
                **self == CCUS_A::DEFAULT
            }
            ///Checks if the value of the field is `WITHRISINGEDGE`
            #[inline(always)]
            pub fn is_with_rising_edge(&self) -> bool {
                **self == CCUS_A::WITHRISINGEDGE
            }
        }
        impl core::ops::Deref for CCUS_R {
            type Target = crate::FieldReader<bool, CCUS_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCUS` writer - Capture/compare control update selection
        pub struct CCUS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCUS_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CCUS_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Capture/compare are updated only by setting the COMG bit
            #[inline(always)]
            pub fn default(self) -> &'a mut W {
                self.variant(CCUS_A::DEFAULT)
            }
            ///Capture/compare are updated by setting the COMG bit or when an rising edge occurs on TRGI
            #[inline(always)]
            pub fn with_rising_edge(self) -> &'a mut W {
                self.variant(CCUS_A::WITHRISINGEDGE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Capture/compare preloaded control
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CCPC_A {
            ///0: CCxE, CCxNE and OCxM bits are not preloaded
            NOTPRELOADED = 0,
            ///1: CCxE, CCxNE and OCxM bits are preloaded
            PRELOADED = 1,
        }
        impl From<CCPC_A> for bool {
            #[inline(always)]
            fn from(variant: CCPC_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CCPC` reader - Capture/compare preloaded control
        pub struct CCPC_R(crate::FieldReader<bool, CCPC_A>);
        impl CCPC_R {
            pub(crate) fn new(bits: bool) -> Self {
                CCPC_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CCPC_A {
                match self.bits {
                    false => CCPC_A::NOTPRELOADED,
                    true => CCPC_A::PRELOADED,
                }
            }
            ///Checks if the value of the field is `NOTPRELOADED`
            #[inline(always)]
            pub fn is_not_preloaded(&self) -> bool {
                **self == CCPC_A::NOTPRELOADED
            }
            ///Checks if the value of the field is `PRELOADED`
            #[inline(always)]
            pub fn is_preloaded(&self) -> bool {
                **self == CCPC_A::PRELOADED
            }
        }
        impl core::ops::Deref for CCPC_R {
            type Target = crate::FieldReader<bool, CCPC_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCPC` writer - Capture/compare preloaded control
        pub struct CCPC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCPC_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CCPC_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CCxE, CCxNE and OCxM bits are not preloaded
            #[inline(always)]
            pub fn not_preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::NOTPRELOADED)
            }
            ///CCxE, CCxNE and OCxM bits are preloaded
            #[inline(always)]
            pub fn preloaded(self) -> &'a mut W {
                self.variant(CCPC_A::PRELOADED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&self) -> OIS1N_R {
                OIS1N_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&self) -> OIS1_R {
                OIS1_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&self) -> CCDS_R {
                CCDS_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&self) -> CCUS_R {
                CCUS_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&self) -> CCPC_R {
                CCPC_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 9 - Output Idle state 1
            #[inline(always)]
            pub fn ois1n(&mut self) -> OIS1N_W {
                OIS1N_W { w: self }
            }
            ///Bit 8 - Output Idle state 1
            #[inline(always)]
            pub fn ois1(&mut self) -> OIS1_W {
                OIS1_W { w: self }
            }
            ///Bit 3 - Capture/compare DMA selection
            #[inline(always)]
            pub fn ccds(&mut self) -> CCDS_W {
                CCDS_W { w: self }
            }
            ///Bit 2 - Capture/compare control update selection
            #[inline(always)]
            pub fn ccus(&mut self) -> CCUS_W {
                CCUS_W { w: self }
            }
            ///Bit 0 - Capture/compare preloaded control
            #[inline(always)]
            pub fn ccpc(&mut self) -> CCPC_W {
                CCPC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///control register 2
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cr2](index.html) module
        pub struct CR2_SPEC;
        impl crate::RegisterSpec for CR2_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cr2::R](R) reader structure
        impl crate::Readable for CR2_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cr2::W](W) writer structure
        impl crate::Writable for CR2_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CR2 to value 0
        impl crate::Resettable for CR2_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DIER register accessor: an alias for `Reg<DIER_SPEC>`
    pub type DIER = crate::Reg<dier::DIER_SPEC>;
    ///DMA/Interrupt enable register
    pub mod dier {
        ///Register `DIER` reader
        pub struct R(crate::R<DIER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DIER_SPEC>> for R {
            fn from(reader: crate::R<DIER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DIER` writer
        pub struct W(crate::W<DIER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DIER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DIER_SPEC>> for W {
            fn from(writer: crate::W<DIER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TDE` reader - Trigger DMA request enable
        pub struct TDE_R(crate::FieldReader<bool, bool>);
        impl TDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TDE` writer - Trigger DMA request enable
        pub struct TDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Capture/Compare 1 DMA request enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1DE_A {
            ///0: CC1 DMA request disabled
            DISABLED = 0,
            ///1: CC1 DMA request enabled
            ENABLED = 1,
        }
        impl From<CC1DE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1DE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1DE` reader - Capture/Compare 1 DMA request enable
        pub struct CC1DE_R(crate::FieldReader<bool, CC1DE_A>);
        impl CC1DE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1DE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1DE_A {
                match self.bits {
                    false => CC1DE_A::DISABLED,
                    true => CC1DE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC1DE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC1DE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC1DE_R {
            type Target = crate::FieldReader<bool, CC1DE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1DE` writer - Capture/Compare 1 DMA request enable
        pub struct CC1DE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1DE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1DE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CC1 DMA request disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1DE_A::DISABLED)
            }
            ///CC1 DMA request enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1DE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `UDE` reader - Update DMA request enable
        pub struct UDE_R(crate::FieldReader<bool, bool>);
        impl UDE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UDE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for UDE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UDE` writer - Update DMA request enable
        pub struct UDE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UDE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 8)) | ((value as u32 & 0x01) << 8);
                self.w
            }
        }
        ///Break interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum BIE_A {
            ///0: Break interrupt disabled
            DISABLED = 0,
            ///1: Break interrupt enabled
            ENABLED = 1,
        }
        impl From<BIE_A> for bool {
            #[inline(always)]
            fn from(variant: BIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `BIE` reader - Break interrupt enable
        pub struct BIE_R(crate::FieldReader<bool, BIE_A>);
        impl BIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> BIE_A {
                match self.bits {
                    false => BIE_A::DISABLED,
                    true => BIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == BIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == BIE_A::ENABLED
            }
        }
        impl core::ops::Deref for BIE_R {
            type Target = crate::FieldReader<bool, BIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIE` writer - Break interrupt enable
        pub struct BIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: BIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Break interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(BIE_A::DISABLED)
            }
            ///Break interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(BIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TIE` reader - Trigger interrupt enable
        pub struct TIE_R(crate::FieldReader<bool, bool>);
        impl TIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIE` writer - Trigger interrupt enable
        pub struct TIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///COM interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum COMIE_A {
            ///0: COM interrupt disabled
            DISABLED = 0,
            ///1: COM interrupt enabled
            ENABLED = 1,
        }
        impl From<COMIE_A> for bool {
            #[inline(always)]
            fn from(variant: COMIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `COMIE` reader - COM interrupt enable
        pub struct COMIE_R(crate::FieldReader<bool, COMIE_A>);
        impl COMIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> COMIE_A {
                match self.bits {
                    false => COMIE_A::DISABLED,
                    true => COMIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == COMIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == COMIE_A::ENABLED
            }
        }
        impl core::ops::Deref for COMIE_R {
            type Target = crate::FieldReader<bool, COMIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIE` writer - COM interrupt enable
        pub struct COMIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: COMIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///COM interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(COMIE_A::DISABLED)
            }
            ///COM interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(COMIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Capture/Compare 1 interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum CC1IE_A {
            ///0: CC1 interrupt disabled
            DISABLED = 0,
            ///1: CC1 interrupt enabled
            ENABLED = 1,
        }
        impl From<CC1IE_A> for bool {
            #[inline(always)]
            fn from(variant: CC1IE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `CC1IE` reader - Capture/Compare 1 interrupt enable
        pub struct CC1IE_R(crate::FieldReader<bool, CC1IE_A>);
        impl CC1IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> CC1IE_A {
                match self.bits {
                    false => CC1IE_A::DISABLED,
                    true => CC1IE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == CC1IE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == CC1IE_A::ENABLED
            }
        }
        impl core::ops::Deref for CC1IE_R {
            type Target = crate::FieldReader<bool, CC1IE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IE` writer - Capture/Compare 1 interrupt enable
        pub struct CC1IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: CC1IE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///CC1 interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(CC1IE_A::DISABLED)
            }
            ///CC1 interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(CC1IE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt enable
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIE_A {
            ///0: Update interrupt disabled
            DISABLED = 0,
            ///1: Update interrupt enabled
            ENABLED = 1,
        }
        impl From<UIE_A> for bool {
            #[inline(always)]
            fn from(variant: UIE_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIE` reader - Update interrupt enable
        pub struct UIE_R(crate::FieldReader<bool, UIE_A>);
        impl UIE_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIE_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIE_A {
                match self.bits {
                    false => UIE_A::DISABLED,
                    true => UIE_A::ENABLED,
                }
            }
            ///Checks if the value of the field is `DISABLED`
            #[inline(always)]
            pub fn is_disabled(&self) -> bool {
                **self == UIE_A::DISABLED
            }
            ///Checks if the value of the field is `ENABLED`
            #[inline(always)]
            pub fn is_enabled(&self) -> bool {
                **self == UIE_A::ENABLED
            }
        }
        impl core::ops::Deref for UIE_R {
            type Target = crate::FieldReader<bool, UIE_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIE` writer - Update interrupt enable
        pub struct UIE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIE_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIE_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Update interrupt disabled
            #[inline(always)]
            pub fn disabled(self) -> &'a mut W {
                self.variant(UIE_A::DISABLED)
            }
            ///Update interrupt enabled
            #[inline(always)]
            pub fn enabled(self) -> &'a mut W {
                self.variant(UIE_A::ENABLED)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&self) -> TDE_R {
                TDE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&self) -> CC1DE_R {
                CC1DE_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&self) -> UDE_R {
                UDE_R::new(((self.bits >> 8) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&self) -> BIE_R {
                BIE_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&self) -> TIE_R {
                TIE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&self) -> COMIE_R {
                COMIE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&self) -> CC1IE_R {
                CC1IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&self) -> UIE_R {
                UIE_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 14 - Trigger DMA request enable
            #[inline(always)]
            pub fn tde(&mut self) -> TDE_W {
                TDE_W { w: self }
            }
            ///Bit 9 - Capture/Compare 1 DMA request enable
            #[inline(always)]
            pub fn cc1de(&mut self) -> CC1DE_W {
                CC1DE_W { w: self }
            }
            ///Bit 8 - Update DMA request enable
            #[inline(always)]
            pub fn ude(&mut self) -> UDE_W {
                UDE_W { w: self }
            }
            ///Bit 7 - Break interrupt enable
            #[inline(always)]
            pub fn bie(&mut self) -> BIE_W {
                BIE_W { w: self }
            }
            ///Bit 6 - Trigger interrupt enable
            #[inline(always)]
            pub fn tie(&mut self) -> TIE_W {
                TIE_W { w: self }
            }
            ///Bit 5 - COM interrupt enable
            #[inline(always)]
            pub fn comie(&mut self) -> COMIE_W {
                COMIE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 interrupt enable
            #[inline(always)]
            pub fn cc1ie(&mut self) -> CC1IE_W {
                CC1IE_W { w: self }
            }
            ///Bit 0 - Update interrupt enable
            #[inline(always)]
            pub fn uie(&mut self) -> UIE_W {
                UIE_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA/Interrupt enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dier](index.html) module
        pub struct DIER_SPEC;
        impl crate::RegisterSpec for DIER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dier::R](R) reader structure
        impl crate::Readable for DIER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dier::W](W) writer structure
        impl crate::Writable for DIER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DIER to value 0
        impl crate::Resettable for DIER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///SR register accessor: an alias for `Reg<SR_SPEC>`
    pub type SR = crate::Reg<sr::SR_SPEC>;
    ///status register
    pub mod sr {
        ///Register `SR` reader
        pub struct R(crate::R<SR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<SR_SPEC>> for R {
            fn from(reader: crate::R<SR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `SR` writer
        pub struct W(crate::W<SR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<SR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<SR_SPEC>> for W {
            fn from(writer: crate::W<SR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1OF` reader - Capture/Compare 1 overcapture flag
        pub struct CC1OF_R(crate::FieldReader<bool, bool>);
        impl CC1OF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1OF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1OF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1OF` writer - Capture/Compare 1 overcapture flag
        pub struct CC1OF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1OF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 9)) | ((value as u32 & 0x01) << 9);
                self.w
            }
        }
        ///Field `BIF` reader - Break interrupt flag
        pub struct BIF_R(crate::FieldReader<bool, bool>);
        impl BIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                BIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BIF` writer - Break interrupt flag
        pub struct BIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TIF` reader - Trigger interrupt flag
        pub struct TIF_R(crate::FieldReader<bool, bool>);
        impl TIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TIF` writer - Trigger interrupt flag
        pub struct TIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMIF` reader - COM interrupt flag
        pub struct COMIF_R(crate::FieldReader<bool, bool>);
        impl COMIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                COMIF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COMIF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COMIF` writer - COM interrupt flag
        pub struct COMIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMIF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC1IF` reader - Capture/compare 1 interrupt flag
        pub struct CC1IF_R(crate::FieldReader<bool, bool>);
        impl CC1IF_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1IF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1IF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1IF` writer - Capture/compare 1 interrupt flag
        pub struct CC1IF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1IF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update interrupt flag
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UIF_A {
            ///0: No update occurred
            CLEAR = 0,
            ///1: Update interrupt pending.
            UPDATEPENDING = 1,
        }
        impl From<UIF_A> for bool {
            #[inline(always)]
            fn from(variant: UIF_A) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UIF` reader - Update interrupt flag
        pub struct UIF_R(crate::FieldReader<bool, UIF_A>);
        impl UIF_R {
            pub(crate) fn new(bits: bool) -> Self {
                UIF_R(crate::FieldReader::new(bits))
            }
            ///Get enumerated values variant
            #[inline(always)]
            pub fn variant(&self) -> UIF_A {
                match self.bits {
                    false => UIF_A::CLEAR,
                    true => UIF_A::UPDATEPENDING,
                }
            }
            ///Checks if the value of the field is `CLEAR`
            #[inline(always)]
            pub fn is_clear(&self) -> bool {
                **self == UIF_A::CLEAR
            }
            ///Checks if the value of the field is `UPDATEPENDING`
            #[inline(always)]
            pub fn is_update_pending(&self) -> bool {
                **self == UIF_A::UPDATEPENDING
            }
        }
        impl core::ops::Deref for UIF_R {
            type Target = crate::FieldReader<bool, UIF_A>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `UIF` writer - Update interrupt flag
        pub struct UIF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UIF_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UIF_A) -> &'a mut W {
                self.bit(variant.into())
            }
            ///No update occurred
            #[inline(always)]
            pub fn clear(self) -> &'a mut W {
                self.variant(UIF_A::CLEAR)
            }
            ///Update interrupt pending.
            #[inline(always)]
            pub fn update_pending(self) -> &'a mut W {
                self.variant(UIF_A::UPDATEPENDING)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&self) -> CC1OF_R {
                CC1OF_R::new(((self.bits >> 9) & 0x01) != 0)
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&self) -> BIF_R {
                BIF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&self) -> TIF_R {
                TIF_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&self) -> COMIF_R {
                COMIF_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&self) -> CC1IF_R {
                CC1IF_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&self) -> UIF_R {
                UIF_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 9 - Capture/Compare 1 overcapture flag
            #[inline(always)]
            pub fn cc1of(&mut self) -> CC1OF_W {
                CC1OF_W { w: self }
            }
            ///Bit 7 - Break interrupt flag
            #[inline(always)]
            pub fn bif(&mut self) -> BIF_W {
                BIF_W { w: self }
            }
            ///Bit 6 - Trigger interrupt flag
            #[inline(always)]
            pub fn tif(&mut self) -> TIF_W {
                TIF_W { w: self }
            }
            ///Bit 5 - COM interrupt flag
            #[inline(always)]
            pub fn comif(&mut self) -> COMIF_W {
                COMIF_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 interrupt flag
            #[inline(always)]
            pub fn cc1if(&mut self) -> CC1IF_W {
                CC1IF_W { w: self }
            }
            ///Bit 0 - Update interrupt flag
            #[inline(always)]
            pub fn uif(&mut self) -> UIF_W {
                UIF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [sr](index.html) module
        pub struct SR_SPEC;
        impl crate::RegisterSpec for SR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [sr::R](R) reader structure
        impl crate::Readable for SR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [sr::W](W) writer structure
        impl crate::Writable for SR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets SR to value 0
        impl crate::Resettable for SR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///EGR register accessor: an alias for `Reg<EGR_SPEC>`
    pub type EGR = crate::Reg<egr::EGR_SPEC>;
    ///event generation register
    pub mod egr {
        ///Register `EGR` writer
        pub struct W(crate::W<EGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<EGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<EGR_SPEC>> for W {
            fn from(writer: crate::W<EGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `BG` writer - Break generation
        pub struct BG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        ///Field `TG` writer - Trigger generation
        pub struct TG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `COMG` writer - Capture/Compare control update generation
        pub struct COMG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COMG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `CC1G` writer - Capture/compare 1 generation
        pub struct CC1G_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1G_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Update generation
        ///
        ///Value on reset: 0
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum UG_AW {
            ///1: Re-initializes the timer counter and generates an update of the registers.
            UPDATE = 1,
        }
        impl From<UG_AW> for bool {
            #[inline(always)]
            fn from(variant: UG_AW) -> Self {
                variant as u8 != 0
            }
        }
        ///Field `UG` writer - Update generation
        pub struct UG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> UG_W<'a> {
            ///Writes `variant` to the field
            #[inline(always)]
            pub fn variant(self, variant: UG_AW) -> &'a mut W {
                self.bit(variant.into())
            }
            ///Re-initializes the timer counter and generates an update of the registers.
            #[inline(always)]
            pub fn update(self) -> &'a mut W {
                self.variant(UG_AW::UPDATE)
            }
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl W {
            ///Bit 7 - Break generation
            #[inline(always)]
            pub fn bg(&mut self) -> BG_W {
                BG_W { w: self }
            }
            ///Bit 6 - Trigger generation
            #[inline(always)]
            pub fn tg(&mut self) -> TG_W {
                TG_W { w: self }
            }
            ///Bit 5 - Capture/Compare control update generation
            #[inline(always)]
            pub fn comg(&mut self) -> COMG_W {
                COMG_W { w: self }
            }
            ///Bit 1 - Capture/compare 1 generation
            #[inline(always)]
            pub fn cc1g(&mut self) -> CC1G_W {
                CC1G_W { w: self }
            }
            ///Bit 0 - Update generation
            #[inline(always)]
            pub fn ug(&mut self) -> UG_W {
                UG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///event generation register
        ///
        ///This register you can [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [egr](index.html) module
        pub struct EGR_SPEC;
        impl crate::RegisterSpec for EGR_SPEC {
            type Ux = u32;
        }
        ///`write(|w| ..)` method takes [egr::W](W) writer structure
        impl crate::Writable for EGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets EGR to value 0
        impl crate::Resettable for EGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Output register accessor: an alias for `Reg<CCMR1_OUTPUT_SPEC>`
    pub type CCMR1_OUTPUT = crate::Reg<ccmr1_output::CCMR1_OUTPUT_SPEC>;
    ///capture/compare mode register (output mode)
    pub mod ccmr1_output {
        ///Register `CCMR1_Output` reader
        pub struct R(crate::R<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_OUTPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_OUTPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Output` writer
        pub struct W(crate::W<CCMR1_OUTPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_OUTPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_OUTPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_OUTPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OC1M` reader - Output Compare 1 mode
        pub struct OC1M_R(crate::FieldReader<u8, u8>);
        impl OC1M_R {
            pub(crate) fn new(bits: u8) -> Self {
                OC1M_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1M_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1M` writer - Output Compare 1 mode
        pub struct OC1M_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1M_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x07 << 4)) | ((value as u32 & 0x07) << 4);
                self.w
            }
        }
        ///Field `OC1PE` reader - Output Compare 1 preload enable
        pub struct OC1PE_R(crate::FieldReader<bool, bool>);
        impl OC1PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1PE` writer - Output Compare 1 preload enable
        pub struct OC1PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `OC1FE` reader - Output Compare 1 fast enable
        pub struct OC1FE_R(crate::FieldReader<bool, bool>);
        impl OC1FE_R {
            pub(crate) fn new(bits: bool) -> Self {
                OC1FE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OC1FE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OC1FE` writer - Output Compare 1 fast enable
        pub struct OC1FE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OC1FE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&self) -> OC1M_R {
                OC1M_R::new(((self.bits >> 4) & 0x07) as u8)
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&self) -> OC1PE_R {
                OC1PE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&self) -> OC1FE_R {
                OC1FE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 4:6 - Output Compare 1 mode
            #[inline(always)]
            pub fn oc1m(&mut self) -> OC1M_W {
                OC1M_W { w: self }
            }
            ///Bit 3 - Output Compare 1 preload enable
            #[inline(always)]
            pub fn oc1pe(&mut self) -> OC1PE_W {
                OC1PE_W { w: self }
            }
            ///Bit 2 - Output Compare 1 fast enable
            #[inline(always)]
            pub fn oc1fe(&mut self) -> OC1FE_W {
                OC1FE_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register (output mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_output](index.html) module
        pub struct CCMR1_OUTPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_OUTPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_output::R](R) reader structure
        impl crate::Readable for CCMR1_OUTPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_output::W](W) writer structure
        impl crate::Writable for CCMR1_OUTPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Output to value 0
        impl crate::Resettable for CCMR1_OUTPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCMR1_Input register accessor: an alias for `Reg<CCMR1_INPUT_SPEC>`
    pub type CCMR1_INPUT = crate::Reg<ccmr1_input::CCMR1_INPUT_SPEC>;
    ///capture/compare mode register 1 (input mode)
    pub mod ccmr1_input {
        ///Register `CCMR1_Input` reader
        pub struct R(crate::R<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCMR1_INPUT_SPEC>> for R {
            fn from(reader: crate::R<CCMR1_INPUT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCMR1_Input` writer
        pub struct W(crate::W<CCMR1_INPUT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCMR1_INPUT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCMR1_INPUT_SPEC>> for W {
            fn from(writer: crate::W<CCMR1_INPUT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `IC1F` reader - Input capture 1 filter
        pub struct IC1F_R(crate::FieldReader<u8, u8>);
        impl IC1F_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1F_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1F_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1F` writer - Input capture 1 filter
        pub struct IC1F_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1F_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x0f << 4)) | ((value as u32 & 0x0f) << 4);
                self.w
            }
        }
        ///Field `IC1PSC` reader - Input capture 1 prescaler
        pub struct IC1PSC_R(crate::FieldReader<u8, u8>);
        impl IC1PSC_R {
            pub(crate) fn new(bits: u8) -> Self {
                IC1PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IC1PSC_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IC1PSC` writer - Input capture 1 prescaler
        pub struct IC1PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IC1PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 2)) | ((value as u32 & 0x03) << 2);
                self.w
            }
        }
        ///Field `CC1S` reader - Capture/Compare 1 selection
        pub struct CC1S_R(crate::FieldReader<u8, u8>);
        impl CC1S_R {
            pub(crate) fn new(bits: u8) -> Self {
                CC1S_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1S_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1S` writer - Capture/Compare 1 selection
        pub struct CC1S_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1S_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x03) | (value as u32 & 0x03);
                self.w
            }
        }
        impl R {
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&self) -> IC1F_R {
                IC1F_R::new(((self.bits >> 4) & 0x0f) as u8)
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&self) -> IC1PSC_R {
                IC1PSC_R::new(((self.bits >> 2) & 0x03) as u8)
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&self) -> CC1S_R {
                CC1S_R::new((self.bits & 0x03) as u8)
            }
        }
        impl W {
            ///Bits 4:7 - Input capture 1 filter
            #[inline(always)]
            pub fn ic1f(&mut self) -> IC1F_W {
                IC1F_W { w: self }
            }
            ///Bits 2:3 - Input capture 1 prescaler
            #[inline(always)]
            pub fn ic1psc(&mut self) -> IC1PSC_W {
                IC1PSC_W { w: self }
            }
            ///Bits 0:1 - Capture/Compare 1 selection
            #[inline(always)]
            pub fn cc1s(&mut self) -> CC1S_W {
                CC1S_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare mode register 1 (input mode)
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccmr1_input](index.html) module
        pub struct CCMR1_INPUT_SPEC;
        impl crate::RegisterSpec for CCMR1_INPUT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccmr1_input::R](R) reader structure
        impl crate::Readable for CCMR1_INPUT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccmr1_input::W](W) writer structure
        impl crate::Writable for CCMR1_INPUT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCMR1_Input to value 0
        impl crate::Resettable for CCMR1_INPUT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCER register accessor: an alias for `Reg<CCER_SPEC>`
    pub type CCER = crate::Reg<ccer::CCER_SPEC>;
    ///capture/compare enable register
    pub mod ccer {
        ///Register `CCER` reader
        pub struct R(crate::R<CCER_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCER_SPEC>> for R {
            fn from(reader: crate::R<CCER_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCER` writer
        pub struct W(crate::W<CCER_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCER_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCER_SPEC>> for W {
            fn from(writer: crate::W<CCER_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CC1NP` reader - Capture/Compare 1 output Polarity
        pub struct CC1NP_R(crate::FieldReader<bool, bool>);
        impl CC1NP_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NP` writer - Capture/Compare 1 output Polarity
        pub struct CC1NP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `CC1NE` reader - Capture/Compare 1 complementary output enable
        pub struct CC1NE_R(crate::FieldReader<bool, bool>);
        impl CC1NE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1NE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1NE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1NE` writer - Capture/Compare 1 complementary output enable
        pub struct CC1NE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1NE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `CC1P` reader - Capture/Compare 1 output Polarity
        pub struct CC1P_R(crate::FieldReader<bool, bool>);
        impl CC1P_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1P_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1P_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1P` writer - Capture/Compare 1 output Polarity
        pub struct CC1P_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1P_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CC1E` reader - Capture/Compare 1 output enable
        pub struct CC1E_R(crate::FieldReader<bool, bool>);
        impl CC1E_R {
            pub(crate) fn new(bits: bool) -> Self {
                CC1E_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CC1E_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CC1E` writer - Capture/Compare 1 output enable
        pub struct CC1E_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CC1E_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        impl R {
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&self) -> CC1NP_R {
                CC1NP_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&self) -> CC1NE_R {
                CC1NE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&self) -> CC1P_R {
                CC1P_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&self) -> CC1E_R {
                CC1E_R::new((self.bits & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 3 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1np(&mut self) -> CC1NP_W {
                CC1NP_W { w: self }
            }
            ///Bit 2 - Capture/Compare 1 complementary output enable
            #[inline(always)]
            pub fn cc1ne(&mut self) -> CC1NE_W {
                CC1NE_W { w: self }
            }
            ///Bit 1 - Capture/Compare 1 output Polarity
            #[inline(always)]
            pub fn cc1p(&mut self) -> CC1P_W {
                CC1P_W { w: self }
            }
            ///Bit 0 - Capture/Compare 1 output enable
            #[inline(always)]
            pub fn cc1e(&mut self) -> CC1E_W {
                CC1E_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare enable register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccer](index.html) module
        pub struct CCER_SPEC;
        impl crate::RegisterSpec for CCER_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccer::R](R) reader structure
        impl crate::Readable for CCER_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccer::W](W) writer structure
        impl crate::Writable for CCER_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCER to value 0
        impl crate::Resettable for CCER_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CNT register accessor: an alias for `Reg<CNT_SPEC>`
    pub type CNT = crate::Reg<cnt::CNT_SPEC>;
    ///counter
    pub mod cnt {
        ///Register `CNT` reader
        pub struct R(crate::R<CNT_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CNT_SPEC>> for R {
            fn from(reader: crate::R<CNT_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CNT` writer
        pub struct W(crate::W<CNT_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CNT_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CNT_SPEC>> for W {
            fn from(writer: crate::W<CNT_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CNT` reader - counter value
        pub struct CNT_R(crate::FieldReader<u16, u16>);
        impl CNT_R {
            pub(crate) fn new(bits: u16) -> Self {
                CNT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CNT_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CNT` writer - counter value
        pub struct CNT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CNT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&self) -> CNT_R {
                CNT_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - counter value
            #[inline(always)]
            pub fn cnt(&mut self) -> CNT_W {
                CNT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///counter
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cnt](index.html) module
        pub struct CNT_SPEC;
        impl crate::RegisterSpec for CNT_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cnt::R](R) reader structure
        impl crate::Readable for CNT_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cnt::W](W) writer structure
        impl crate::Writable for CNT_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CNT to value 0
        impl crate::Resettable for CNT_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PSC register accessor: an alias for `Reg<PSC_SPEC>`
    pub type PSC = crate::Reg<psc::PSC_SPEC>;
    ///prescaler
    pub mod psc {
        ///Register `PSC` reader
        pub struct R(crate::R<PSC_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PSC_SPEC>> for R {
            fn from(reader: crate::R<PSC_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PSC` writer
        pub struct W(crate::W<PSC_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PSC_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PSC_SPEC>> for W {
            fn from(writer: crate::W<PSC_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PSC` reader - Prescaler value
        pub struct PSC_R(crate::FieldReader<u16, u16>);
        impl PSC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PSC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PSC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PSC` writer - Prescaler value
        pub struct PSC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PSC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&self) -> PSC_R {
                PSC_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Prescaler value
            #[inline(always)]
            pub fn psc(&mut self) -> PSC_W {
                PSC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///prescaler
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [psc](index.html) module
        pub struct PSC_SPEC;
        impl crate::RegisterSpec for PSC_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [psc::R](R) reader structure
        impl crate::Readable for PSC_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [psc::W](W) writer structure
        impl crate::Writable for PSC_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PSC to value 0
        impl crate::Resettable for PSC_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ARR register accessor: an alias for `Reg<ARR_SPEC>`
    pub type ARR = crate::Reg<arr::ARR_SPEC>;
    ///auto-reload register
    pub mod arr {
        ///Register `ARR` reader
        pub struct R(crate::R<ARR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ARR_SPEC>> for R {
            fn from(reader: crate::R<ARR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ARR` writer
        pub struct W(crate::W<ARR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ARR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ARR_SPEC>> for W {
            fn from(writer: crate::W<ARR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ARR` reader - Auto-reload value
        pub struct ARR_R(crate::FieldReader<u16, u16>);
        impl ARR_R {
            pub(crate) fn new(bits: u16) -> Self {
                ARR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ARR_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ARR` writer - Auto-reload value
        pub struct ARR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ARR_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&self) -> ARR_R {
                ARR_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Auto-reload value
            #[inline(always)]
            pub fn arr(&mut self) -> ARR_W {
                ARR_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///auto-reload register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [arr](index.html) module
        pub struct ARR_SPEC;
        impl crate::RegisterSpec for ARR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [arr::R](R) reader structure
        impl crate::Readable for ARR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [arr::W](W) writer structure
        impl crate::Writable for ARR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ARR to value 0
        impl crate::Resettable for ARR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RCR register accessor: an alias for `Reg<RCR_SPEC>`
    pub type RCR = crate::Reg<rcr::RCR_SPEC>;
    ///repetition counter register
    pub mod rcr {
        ///Register `RCR` reader
        pub struct R(crate::R<RCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RCR_SPEC>> for R {
            fn from(reader: crate::R<RCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `RCR` writer
        pub struct W(crate::W<RCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<RCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<RCR_SPEC>> for W {
            fn from(writer: crate::W<RCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `REP` reader - Repetition counter value
        pub struct REP_R(crate::FieldReader<u8, u8>);
        impl REP_R {
            pub(crate) fn new(bits: u8) -> Self {
                REP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for REP_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `REP` writer - Repetition counter value
        pub struct REP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REP_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&self) -> REP_R {
                REP_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Repetition counter value
            #[inline(always)]
            pub fn rep(&mut self) -> REP_W {
                REP_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///repetition counter register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rcr](index.html) module
        pub struct RCR_SPEC;
        impl crate::RegisterSpec for RCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rcr::R](R) reader structure
        impl crate::Readable for RCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [rcr::W](W) writer structure
        impl crate::Writable for RCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets RCR to value 0
        impl crate::Resettable for RCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CCR1 register accessor: an alias for `Reg<CCR1_SPEC>`
    pub type CCR1 = crate::Reg<ccr1::CCR1_SPEC>;
    ///capture/compare register 1
    pub mod ccr1 {
        ///Register `CCR1` reader
        pub struct R(crate::R<CCR1_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CCR1_SPEC>> for R {
            fn from(reader: crate::R<CCR1_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CCR1` writer
        pub struct W(crate::W<CCR1_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CCR1_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CCR1_SPEC>> for W {
            fn from(writer: crate::W<CCR1_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CCR1` reader - Capture/Compare 1 value
        pub struct CCR1_R(crate::FieldReader<u16, u16>);
        impl CCR1_R {
            pub(crate) fn new(bits: u16) -> Self {
                CCR1_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CCR1_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CCR1` writer - Capture/Compare 1 value
        pub struct CCR1_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CCR1_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&self) -> CCR1_R {
                CCR1_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - Capture/Compare 1 value
            #[inline(always)]
            pub fn ccr1(&mut self) -> CCR1_W {
                CCR1_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///capture/compare register 1
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ccr1](index.html) module
        pub struct CCR1_SPEC;
        impl crate::RegisterSpec for CCR1_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ccr1::R](R) reader structure
        impl crate::Readable for CCR1_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ccr1::W](W) writer structure
        impl crate::Writable for CCR1_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CCR1 to value 0
        impl crate::Resettable for CCR1_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///BDTR register accessor: an alias for `Reg<BDTR_SPEC>`
    pub type BDTR = crate::Reg<bdtr::BDTR_SPEC>;
    ///break and dead-time register
    pub mod bdtr {
        ///Register `BDTR` reader
        pub struct R(crate::R<BDTR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<BDTR_SPEC>> for R {
            fn from(reader: crate::R<BDTR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `BDTR` writer
        pub struct W(crate::W<BDTR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<BDTR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<BDTR_SPEC>> for W {
            fn from(writer: crate::W<BDTR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `MOE` reader - Main output enable
        pub struct MOE_R(crate::FieldReader<bool, bool>);
        impl MOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                MOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for MOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `MOE` writer - Main output enable
        pub struct MOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> MOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 15)) | ((value as u32 & 0x01) << 15);
                self.w
            }
        }
        ///Field `AOE` reader - Automatic output enable
        pub struct AOE_R(crate::FieldReader<bool, bool>);
        impl AOE_R {
            pub(crate) fn new(bits: bool) -> Self {
                AOE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for AOE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `AOE` writer - Automatic output enable
        pub struct AOE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> AOE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 14)) | ((value as u32 & 0x01) << 14);
                self.w
            }
        }
        ///Field `BKP` reader - Break polarity
        pub struct BKP_R(crate::FieldReader<bool, bool>);
        impl BKP_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKP_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKP_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKP` writer - Break polarity
        pub struct BKP_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKP_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 13)) | ((value as u32 & 0x01) << 13);
                self.w
            }
        }
        ///Field `BKE` reader - Break enable
        pub struct BKE_R(crate::FieldReader<bool, bool>);
        impl BKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BKE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BKE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BKE` writer - Break enable
        pub struct BKE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BKE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        ///Field `OSSR` reader - Off-state selection for Run mode
        pub struct OSSR_R(crate::FieldReader<bool, bool>);
        impl OSSR_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OSSR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSR` writer - Off-state selection for Run mode
        pub struct OSSR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `OSSI` reader - Off-state selection for Idle mode
        pub struct OSSI_R(crate::FieldReader<bool, bool>);
        impl OSSI_R {
            pub(crate) fn new(bits: bool) -> Self {
                OSSI_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OSSI_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OSSI` writer - Off-state selection for Idle mode
        pub struct OSSI_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OSSI_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `LOCK` reader - Lock configuration
        pub struct LOCK_R(crate::FieldReader<u8, u8>);
        impl LOCK_R {
            pub(crate) fn new(bits: u8) -> Self {
                LOCK_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LOCK_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LOCK` writer - Lock configuration
        pub struct LOCK_W<'a> {
            w: &'a mut W,
        }
        impl<'a> LOCK_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x03 << 8)) | ((value as u32 & 0x03) << 8);
                self.w
            }
        }
        ///Field `DTG` reader - Dead-time generator setup
        pub struct DTG_R(crate::FieldReader<u8, u8>);
        impl DTG_R {
            pub(crate) fn new(bits: u8) -> Self {
                DTG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DTG_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DTG` writer - Dead-time generator setup
        pub struct DTG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DTG_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&self) -> MOE_R {
                MOE_R::new(((self.bits >> 15) & 0x01) != 0)
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&self) -> AOE_R {
                AOE_R::new(((self.bits >> 14) & 0x01) != 0)
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&self) -> BKP_R {
                BKP_R::new(((self.bits >> 13) & 0x01) != 0)
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&self) -> BKE_R {
                BKE_R::new(((self.bits >> 12) & 0x01) != 0)
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&self) -> OSSR_R {
                OSSR_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&self) -> OSSI_R {
                OSSI_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&self) -> LOCK_R {
                LOCK_R::new(((self.bits >> 8) & 0x03) as u8)
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&self) -> DTG_R {
                DTG_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bit 15 - Main output enable
            #[inline(always)]
            pub fn moe(&mut self) -> MOE_W {
                MOE_W { w: self }
            }
            ///Bit 14 - Automatic output enable
            #[inline(always)]
            pub fn aoe(&mut self) -> AOE_W {
                AOE_W { w: self }
            }
            ///Bit 13 - Break polarity
            #[inline(always)]
            pub fn bkp(&mut self) -> BKP_W {
                BKP_W { w: self }
            }
            ///Bit 12 - Break enable
            #[inline(always)]
            pub fn bke(&mut self) -> BKE_W {
                BKE_W { w: self }
            }
            ///Bit 11 - Off-state selection for Run mode
            #[inline(always)]
            pub fn ossr(&mut self) -> OSSR_W {
                OSSR_W { w: self }
            }
            ///Bit 10 - Off-state selection for Idle mode
            #[inline(always)]
            pub fn ossi(&mut self) -> OSSI_W {
                OSSI_W { w: self }
            }
            ///Bits 8:9 - Lock configuration
            #[inline(always)]
            pub fn lock(&mut self) -> LOCK_W {
                LOCK_W { w: self }
            }
            ///Bits 0:7 - Dead-time generator setup
            #[inline(always)]
            pub fn dtg(&mut self) -> DTG_W {
                DTG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///break and dead-time register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [bdtr](index.html) module
        pub struct BDTR_SPEC;
        impl crate::RegisterSpec for BDTR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [bdtr::R](R) reader structure
        impl crate::Readable for BDTR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [bdtr::W](W) writer structure
        impl crate::Writable for BDTR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets BDTR to value 0
        impl crate::Resettable for BDTR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DCR register accessor: an alias for `Reg<DCR_SPEC>`
    pub type DCR = crate::Reg<dcr::DCR_SPEC>;
    ///DMA control register
    pub mod dcr {
        ///Register `DCR` reader
        pub struct R(crate::R<DCR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DCR_SPEC>> for R {
            fn from(reader: crate::R<DCR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DCR` writer
        pub struct W(crate::W<DCR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DCR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DCR_SPEC>> for W {
            fn from(writer: crate::W<DCR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DBL` reader - DMA burst length
        pub struct DBL_R(crate::FieldReader<u8, u8>);
        impl DBL_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBL_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBL_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBL` writer - DMA burst length
        pub struct DBL_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBL_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x1f << 8)) | ((value as u32 & 0x1f) << 8);
                self.w
            }
        }
        ///Field `DBA` reader - DMA base address
        pub struct DBA_R(crate::FieldReader<u8, u8>);
        impl DBA_R {
            pub(crate) fn new(bits: u8) -> Self {
                DBA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DBA_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DBA` writer - DMA base address
        pub struct DBA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DBA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x1f) | (value as u32 & 0x1f);
                self.w
            }
        }
        impl R {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&self) -> DBL_R {
                DBL_R::new(((self.bits >> 8) & 0x1f) as u8)
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&self) -> DBA_R {
                DBA_R::new((self.bits & 0x1f) as u8)
            }
        }
        impl W {
            ///Bits 8:12 - DMA burst length
            #[inline(always)]
            pub fn dbl(&mut self) -> DBL_W {
                DBL_W { w: self }
            }
            ///Bits 0:4 - DMA base address
            #[inline(always)]
            pub fn dba(&mut self) -> DBA_W {
                DBA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dcr](index.html) module
        pub struct DCR_SPEC;
        impl crate::RegisterSpec for DCR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dcr::R](R) reader structure
        impl crate::Readable for DCR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dcr::W](W) writer structure
        impl crate::Writable for DCR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DCR to value 0
        impl crate::Resettable for DCR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///DMAR register accessor: an alias for `Reg<DMAR_SPEC>`
    pub type DMAR = crate::Reg<dmar::DMAR_SPEC>;
    ///DMA address for full transfer
    pub mod dmar {
        ///Register `DMAR` reader
        pub struct R(crate::R<DMAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<DMAR_SPEC>> for R {
            fn from(reader: crate::R<DMAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `DMAR` writer
        pub struct W(crate::W<DMAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<DMAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<DMAR_SPEC>> for W {
            fn from(writer: crate::W<DMAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DMAB` reader - DMA register for burst accesses
        pub struct DMAB_R(crate::FieldReader<u16, u16>);
        impl DMAB_R {
            pub(crate) fn new(bits: u16) -> Self {
                DMAB_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DMAB_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DMAB` writer - DMA register for burst accesses
        pub struct DMAB_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DMAB_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xffff) | (value as u32 & 0xffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&self) -> DMAB_R {
                DMAB_R::new((self.bits & 0xffff) as u16)
            }
        }
        impl W {
            ///Bits 0:15 - DMA register for burst accesses
            #[inline(always)]
            pub fn dmab(&mut self) -> DMAB_W {
                DMAB_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///DMA address for full transfer
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [dmar](index.html) module
        pub struct DMAR_SPEC;
        impl crate::RegisterSpec for DMAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [dmar::R](R) reader structure
        impl crate::Readable for DMAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [dmar::W](W) writer structure
        impl crate::Writable for DMAR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets DMAR to value 0
        impl crate::Resettable for DMAR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///General-purpose-timers
pub struct TIM17 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for TIM17 {}
impl TIM17 {
    ///Pointer to the register block
    pub const PTR: *const tim16::RegisterBlock = 0x4001_4800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const tim16::RegisterBlock {
        Self::PTR
    }
}
impl Deref for TIM17 {
    type Target = tim16::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for TIM17 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("TIM17").finish()
    }
}
///HDMI-CEC controller
pub struct CEC {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for CEC {}
impl CEC {
    ///Pointer to the register block
    pub const PTR: *const cec::RegisterBlock = 0x4000_7800 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const cec::RegisterBlock {
        Self::PTR
    }
}
impl Deref for CEC {
    type Target = cec::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for CEC {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("CEC").finish()
    }
}
///HDMI-CEC controller
pub mod cec {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - configuration register
        pub cfgr: crate::Reg<cfgr::CFGR_SPEC>,
        ///0x04 - CEC own address register
        pub oar: crate::Reg<oar::OAR_SPEC>,
        ///0x08 - Rx Data Register
        pub pres: crate::Reg<pres::PRES_SPEC>,
        ///0x0c - CEC error status register
        pub esr: crate::Reg<esr::ESR_SPEC>,
        ///0x10 - CEC control and status register
        pub csr: crate::Reg<csr::CSR_SPEC>,
        ///0x14 - CEC Tx data register
        pub txd: crate::Reg<txd::TXD_SPEC>,
        ///0x18 - CEC Rx data register
        pub rxd: crate::Reg<rxd::RXD_SPEC>,
    }
    ///CFGR register accessor: an alias for `Reg<CFGR_SPEC>`
    pub type CFGR = crate::Reg<cfgr::CFGR_SPEC>;
    ///configuration register
    pub mod cfgr {
        ///Register `CFGR` reader
        pub struct R(crate::R<CFGR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CFGR_SPEC>> for R {
            fn from(reader: crate::R<CFGR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CFGR` writer
        pub struct W(crate::W<CFGR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CFGR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CFGR_SPEC>> for W {
            fn from(writer: crate::W<CFGR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PE` reader - Peripheral enable
        pub struct PE_R(crate::FieldReader<bool, bool>);
        impl PE_R {
            pub(crate) fn new(bits: bool) -> Self {
                PE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PE` writer - Peripheral enable
        pub struct PE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `IE` reader - Interrupt enable
        pub struct IE_R(crate::FieldReader<bool, bool>);
        impl IE_R {
            pub(crate) fn new(bits: bool) -> Self {
                IE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for IE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `IE` writer - Interrupt enable
        pub struct IE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> IE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `BTEM` reader - Bit timing error mode
        pub struct BTEM_R(crate::FieldReader<bool, bool>);
        impl BTEM_R {
            pub(crate) fn new(bits: bool) -> Self {
                BTEM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BTEM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BTEM` writer - Bit timing error mode
        pub struct BTEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BTEM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `BPEM` reader - Bit period error mode
        pub struct BPEM_R(crate::FieldReader<bool, bool>);
        impl BPEM_R {
            pub(crate) fn new(bits: bool) -> Self {
                BPEM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BPEM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BPEM` writer - Bit period error mode
        pub struct BPEM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> BPEM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&self) -> PE_R {
                PE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Interrupt enable
            #[inline(always)]
            pub fn ie(&self) -> IE_R {
                IE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Bit timing error mode
            #[inline(always)]
            pub fn btem(&self) -> BTEM_R {
                BTEM_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Bit period error mode
            #[inline(always)]
            pub fn bpem(&self) -> BPEM_R {
                BPEM_R::new(((self.bits >> 3) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Peripheral enable
            #[inline(always)]
            pub fn pe(&mut self) -> PE_W {
                PE_W { w: self }
            }
            ///Bit 1 - Interrupt enable
            #[inline(always)]
            pub fn ie(&mut self) -> IE_W {
                IE_W { w: self }
            }
            ///Bit 2 - Bit timing error mode
            #[inline(always)]
            pub fn btem(&mut self) -> BTEM_W {
                BTEM_W { w: self }
            }
            ///Bit 3 - Bit period error mode
            #[inline(always)]
            pub fn bpem(&mut self) -> BPEM_W {
                BPEM_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///configuration register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [cfgr](index.html) module
        pub struct CFGR_SPEC;
        impl crate::RegisterSpec for CFGR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [cfgr::R](R) reader structure
        impl crate::Readable for CFGR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [cfgr::W](W) writer structure
        impl crate::Writable for CFGR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CFGR to value 0
        impl crate::Resettable for CFGR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///OAR register accessor: an alias for `Reg<OAR_SPEC>`
    pub type OAR = crate::Reg<oar::OAR_SPEC>;
    ///CEC own address register
    pub mod oar {
        ///Register `OAR` reader
        pub struct R(crate::R<OAR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<OAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<OAR_SPEC>> for R {
            fn from(reader: crate::R<OAR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `OAR` writer
        pub struct W(crate::W<OAR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<OAR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<OAR_SPEC>> for W {
            fn from(writer: crate::W<OAR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `OA` reader - Own address
        pub struct OA_R(crate::FieldReader<u8, u8>);
        impl OA_R {
            pub(crate) fn new(bits: u8) -> Self {
                OA_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for OA_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `OA` writer - Own address
        pub struct OA_W<'a> {
            w: &'a mut W,
        }
        impl<'a> OA_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x0f) | (value as u32 & 0x0f);
                self.w
            }
        }
        impl R {
            ///Bits 0:3 - Own address
            #[inline(always)]
            pub fn oa(&self) -> OA_R {
                OA_R::new((self.bits & 0x0f) as u8)
            }
        }
        impl W {
            ///Bits 0:3 - Own address
            #[inline(always)]
            pub fn oa(&mut self) -> OA_W {
                OA_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CEC own address register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [oar](index.html) module
        pub struct OAR_SPEC;
        impl crate::RegisterSpec for OAR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [oar::R](R) reader structure
        impl crate::Readable for OAR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [oar::W](W) writer structure
        impl crate::Writable for OAR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets OAR to value 0
        impl crate::Resettable for OAR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///PRES register accessor: an alias for `Reg<PRES_SPEC>`
    pub type PRES = crate::Reg<pres::PRES_SPEC>;
    ///Rx Data Register
    pub mod pres {
        ///Register `PRES` reader
        pub struct R(crate::R<PRES_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<PRES_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<PRES_SPEC>> for R {
            fn from(reader: crate::R<PRES_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `PRES` writer
        pub struct W(crate::W<PRES_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<PRES_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<PRES_SPEC>> for W {
            fn from(writer: crate::W<PRES_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `PRESC` reader - CEC Rx Data Register
        pub struct PRESC_R(crate::FieldReader<u16, u16>);
        impl PRESC_R {
            pub(crate) fn new(bits: u16) -> Self {
                PRESC_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for PRESC_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `PRESC` writer - CEC Rx Data Register
        pub struct PRESC_W<'a> {
            w: &'a mut W,
        }
        impl<'a> PRESC_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x3fff) | (value as u32 & 0x3fff);
                self.w
            }
        }
        impl R {
            ///Bits 0:13 - CEC Rx Data Register
            #[inline(always)]
            pub fn presc(&self) -> PRESC_R {
                PRESC_R::new((self.bits & 0x3fff) as u16)
            }
        }
        impl W {
            ///Bits 0:13 - CEC Rx Data Register
            #[inline(always)]
            pub fn presc(&mut self) -> PRESC_W {
                PRESC_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Rx Data Register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [pres](index.html) module
        pub struct PRES_SPEC;
        impl crate::RegisterSpec for PRES_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [pres::R](R) reader structure
        impl crate::Readable for PRES_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [pres::W](W) writer structure
        impl crate::Writable for PRES_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets PRES to value 0
        impl crate::Resettable for PRES_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///ESR register accessor: an alias for `Reg<ESR_SPEC>`
    pub type ESR = crate::Reg<esr::ESR_SPEC>;
    ///CEC error status register
    pub mod esr {
        ///Register `ESR` reader
        pub struct R(crate::R<ESR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ESR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ESR_SPEC>> for R {
            fn from(reader: crate::R<ESR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `BTE` reader - Bit timing error
        pub struct BTE_R(crate::FieldReader<bool, bool>);
        impl BTE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BTE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BTE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `BPE` reader - Bit period error
        pub struct BPE_R(crate::FieldReader<bool, bool>);
        impl BPE_R {
            pub(crate) fn new(bits: bool) -> Self {
                BPE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for BPE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RBTFE` reader - Rx block transfer finished error
        pub struct RBTFE_R(crate::FieldReader<bool, bool>);
        impl RBTFE_R {
            pub(crate) fn new(bits: bool) -> Self {
                RBTFE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RBTFE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `SBE` reader - Start bit error
        pub struct SBE_R(crate::FieldReader<bool, bool>);
        impl SBE_R {
            pub(crate) fn new(bits: bool) -> Self {
                SBE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for SBE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ACKE` reader - Block acknowledge error
        pub struct ACKE_R(crate::FieldReader<bool, bool>);
        impl ACKE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ACKE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ACKE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `LINE` reader - Line error
        pub struct LINE_R(crate::FieldReader<bool, bool>);
        impl LINE_R {
            pub(crate) fn new(bits: bool) -> Self {
                LINE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for LINE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TBTFE` reader - Tx block transfer finished error
        pub struct TBTFE_R(crate::FieldReader<bool, bool>);
        impl TBTFE_R {
            pub(crate) fn new(bits: bool) -> Self {
                TBTFE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TBTFE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bit 0 - Bit timing error
            #[inline(always)]
            pub fn bte(&self) -> BTE_R {
                BTE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Bit period error
            #[inline(always)]
            pub fn bpe(&self) -> BPE_R {
                BPE_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Rx block transfer finished error
            #[inline(always)]
            pub fn rbtfe(&self) -> RBTFE_R {
                RBTFE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Start bit error
            #[inline(always)]
            pub fn sbe(&self) -> SBE_R {
                SBE_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Block acknowledge error
            #[inline(always)]
            pub fn acke(&self) -> ACKE_R {
                ACKE_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Line error
            #[inline(always)]
            pub fn line(&self) -> LINE_R {
                LINE_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Tx block transfer finished error
            #[inline(always)]
            pub fn tbtfe(&self) -> TBTFE_R {
                TBTFE_R::new(((self.bits >> 6) & 0x01) != 0)
            }
        }
        ///CEC error status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [esr](index.html) module
        pub struct ESR_SPEC;
        impl crate::RegisterSpec for ESR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [esr::R](R) reader structure
        impl crate::Readable for ESR_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets ESR to value 0
        impl crate::Resettable for ESR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CSR register accessor: an alias for `Reg<CSR_SPEC>`
    pub type CSR = crate::Reg<csr::CSR_SPEC>;
    ///CEC control and status register
    pub mod csr {
        ///Register `CSR` reader
        pub struct R(crate::R<CSR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CSR_SPEC>> for R {
            fn from(reader: crate::R<CSR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CSR` writer
        pub struct W(crate::W<CSR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CSR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CSR_SPEC>> for W {
            fn from(writer: crate::W<CSR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TSOM` reader - Tx start of message
        pub struct TSOM_R(crate::FieldReader<bool, bool>);
        impl TSOM_R {
            pub(crate) fn new(bits: bool) -> Self {
                TSOM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TSOM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TSOM` writer - Tx start of message
        pub struct TSOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TSOM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `TEOM` reader - Tx end of message
        pub struct TEOM_R(crate::FieldReader<bool, bool>);
        impl TEOM_R {
            pub(crate) fn new(bits: bool) -> Self {
                TEOM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TEOM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TEOM` writer - Tx end of message
        pub struct TEOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TEOM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `TERR` reader - Tx error
        pub struct TERR_R(crate::FieldReader<bool, bool>);
        impl TERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                TERR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TERR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TERR` writer - Tx error
        pub struct TERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TERR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `TBTRF` reader - Tx byte transfer request or block transfer finished
        pub struct TBTRF_R(crate::FieldReader<bool, bool>);
        impl TBTRF_R {
            pub(crate) fn new(bits: bool) -> Self {
                TBTRF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TBTRF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TBTRF` writer - Tx byte transfer request or block transfer finished
        pub struct TBTRF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TBTRF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 3)) | ((value as u32 & 0x01) << 3);
                self.w
            }
        }
        ///Field `RSOM` reader - Rx start of message
        pub struct RSOM_R(crate::FieldReader<bool, bool>);
        impl RSOM_R {
            pub(crate) fn new(bits: bool) -> Self {
                RSOM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RSOM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RSOM` writer - Rx start of message
        pub struct RSOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RSOM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 4)) | ((value as u32 & 0x01) << 4);
                self.w
            }
        }
        ///Field `REOM` reader - Rx end of message
        pub struct REOM_R(crate::FieldReader<bool, bool>);
        impl REOM_R {
            pub(crate) fn new(bits: bool) -> Self {
                REOM_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for REOM_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `REOM` writer - Rx end of message
        pub struct REOM_W<'a> {
            w: &'a mut W,
        }
        impl<'a> REOM_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 5)) | ((value as u32 & 0x01) << 5);
                self.w
            }
        }
        ///Field `RERR` reader - Rx error
        pub struct RERR_R(crate::FieldReader<bool, bool>);
        impl RERR_R {
            pub(crate) fn new(bits: bool) -> Self {
                RERR_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RERR_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RERR` writer - Rx error
        pub struct RERR_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RERR_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 6)) | ((value as u32 & 0x01) << 6);
                self.w
            }
        }
        ///Field `RBTF` reader - Rx byte/block transfer finished
        pub struct RBTF_R(crate::FieldReader<bool, bool>);
        impl RBTF_R {
            pub(crate) fn new(bits: bool) -> Self {
                RBTF_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RBTF_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RBTF` writer - Rx byte/block transfer finished
        pub struct RBTF_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RBTF_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 7)) | ((value as u32 & 0x01) << 7);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Tx start of message
            #[inline(always)]
            pub fn tsom(&self) -> TSOM_R {
                TSOM_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - Tx end of message
            #[inline(always)]
            pub fn teom(&self) -> TEOM_R {
                TEOM_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Tx error
            #[inline(always)]
            pub fn terr(&self) -> TERR_R {
                TERR_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 3 - Tx byte transfer request or block transfer finished
            #[inline(always)]
            pub fn tbtrf(&self) -> TBTRF_R {
                TBTRF_R::new(((self.bits >> 3) & 0x01) != 0)
            }
            ///Bit 4 - Rx start of message
            #[inline(always)]
            pub fn rsom(&self) -> RSOM_R {
                RSOM_R::new(((self.bits >> 4) & 0x01) != 0)
            }
            ///Bit 5 - Rx end of message
            #[inline(always)]
            pub fn reom(&self) -> REOM_R {
                REOM_R::new(((self.bits >> 5) & 0x01) != 0)
            }
            ///Bit 6 - Rx error
            #[inline(always)]
            pub fn rerr(&self) -> RERR_R {
                RERR_R::new(((self.bits >> 6) & 0x01) != 0)
            }
            ///Bit 7 - Rx byte/block transfer finished
            #[inline(always)]
            pub fn rbtf(&self) -> RBTF_R {
                RBTF_R::new(((self.bits >> 7) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Tx start of message
            #[inline(always)]
            pub fn tsom(&mut self) -> TSOM_W {
                TSOM_W { w: self }
            }
            ///Bit 1 - Tx end of message
            #[inline(always)]
            pub fn teom(&mut self) -> TEOM_W {
                TEOM_W { w: self }
            }
            ///Bit 2 - Tx error
            #[inline(always)]
            pub fn terr(&mut self) -> TERR_W {
                TERR_W { w: self }
            }
            ///Bit 3 - Tx byte transfer request or block transfer finished
            #[inline(always)]
            pub fn tbtrf(&mut self) -> TBTRF_W {
                TBTRF_W { w: self }
            }
            ///Bit 4 - Rx start of message
            #[inline(always)]
            pub fn rsom(&mut self) -> RSOM_W {
                RSOM_W { w: self }
            }
            ///Bit 5 - Rx end of message
            #[inline(always)]
            pub fn reom(&mut self) -> REOM_W {
                REOM_W { w: self }
            }
            ///Bit 6 - Rx error
            #[inline(always)]
            pub fn rerr(&mut self) -> RERR_W {
                RERR_W { w: self }
            }
            ///Bit 7 - Rx byte/block transfer finished
            #[inline(always)]
            pub fn rbtf(&mut self) -> RBTF_W {
                RBTF_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CEC control and status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [csr](index.html) module
        pub struct CSR_SPEC;
        impl crate::RegisterSpec for CSR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [csr::R](R) reader structure
        impl crate::Readable for CSR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [csr::W](W) writer structure
        impl crate::Writable for CSR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CSR to value 0
        impl crate::Resettable for CSR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///TXD register accessor: an alias for `Reg<TXD_SPEC>`
    pub type TXD = crate::Reg<txd::TXD_SPEC>;
    ///CEC Tx data register
    pub mod txd {
        ///Register `TXD` reader
        pub struct R(crate::R<TXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<TXD_SPEC>> for R {
            fn from(reader: crate::R<TXD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `TXD` writer
        pub struct W(crate::W<TXD_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<TXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<TXD_SPEC>> for W {
            fn from(writer: crate::W<TXD_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TXD` reader - Tx Data register
        pub struct TXD_R(crate::FieldReader<u8, u8>);
        impl TXD_R {
            pub(crate) fn new(bits: u8) -> Self {
                TXD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TXD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TXD` writer - Tx Data register
        pub struct TXD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TXD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u8) -> &'a mut W {
                self.w.bits = (self.w.bits & !0xff) | (value as u32 & 0xff);
                self.w
            }
        }
        impl R {
            ///Bits 0:7 - Tx Data register
            #[inline(always)]
            pub fn txd(&self) -> TXD_R {
                TXD_R::new((self.bits & 0xff) as u8)
            }
        }
        impl W {
            ///Bits 0:7 - Tx Data register
            #[inline(always)]
            pub fn txd(&mut self) -> TXD_W {
                TXD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///CEC Tx data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [txd](index.html) module
        pub struct TXD_SPEC;
        impl crate::RegisterSpec for TXD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [txd::R](R) reader structure
        impl crate::Readable for TXD_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [txd::W](W) writer structure
        impl crate::Writable for TXD_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets TXD to value 0
        impl crate::Resettable for TXD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///RXD register accessor: an alias for `Reg<RXD_SPEC>`
    pub type RXD = crate::Reg<rxd::RXD_SPEC>;
    ///CEC Rx data register
    pub mod rxd {
        ///Register `RXD` reader
        pub struct R(crate::R<RXD_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<RXD_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<RXD_SPEC>> for R {
            fn from(reader: crate::R<RXD_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Field `RXD` reader - Rx data
        pub struct RXD_R(crate::FieldReader<u8, u8>);
        impl RXD_R {
            pub(crate) fn new(bits: u8) -> Self {
                RXD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RXD_R {
            type Target = crate::FieldReader<u8, u8>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl R {
            ///Bits 0:7 - Rx data
            #[inline(always)]
            pub fn rxd(&self) -> RXD_R {
                RXD_R::new((self.bits & 0xff) as u8)
            }
        }
        ///CEC Rx data register
        ///
        ///This register you can [`read`](crate::generic::Reg::read). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [rxd](index.html) module
        pub struct RXD_SPEC;
        impl crate::RegisterSpec for RXD_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [rxd::R](R) reader structure
        impl crate::Readable for RXD_SPEC {
            type Reader = R;
        }
        ///`reset()` method sets RXD to value 0
        impl crate::Resettable for RXD_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///System control block ACTLR
pub struct SCB_ACTRL {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for SCB_ACTRL {}
impl SCB_ACTRL {
    ///Pointer to the register block
    pub const PTR: *const scb_actrl::RegisterBlock = 0xe000_e008 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const scb_actrl::RegisterBlock {
        Self::PTR
    }
}
impl Deref for SCB_ACTRL {
    type Target = scb_actrl::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for SCB_ACTRL {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("SCB_ACTRL").finish()
    }
}
///System control block ACTLR
pub mod scb_actrl {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Auxiliary control register
        pub actrl: crate::Reg<actrl::ACTRL_SPEC>,
    }
    ///ACTRL register accessor: an alias for `Reg<ACTRL_SPEC>`
    pub type ACTRL = crate::Reg<actrl::ACTRL_SPEC>;
    ///Auxiliary control register
    pub mod actrl {
        ///Register `ACTRL` reader
        pub struct R(crate::R<ACTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<ACTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<ACTRL_SPEC>> for R {
            fn from(reader: crate::R<ACTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `ACTRL` writer
        pub struct W(crate::W<ACTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<ACTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<ACTRL_SPEC>> for W {
            fn from(writer: crate::W<ACTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `DISFOLD` reader - DISFOLD
        pub struct DISFOLD_R(crate::FieldReader<bool, bool>);
        impl DISFOLD_R {
            pub(crate) fn new(bits: bool) -> Self {
                DISFOLD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DISFOLD_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DISFOLD` writer - DISFOLD
        pub struct DISFOLD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISFOLD_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `FPEXCODIS` reader - FPEXCODIS
        pub struct FPEXCODIS_R(crate::FieldReader<bool, bool>);
        impl FPEXCODIS_R {
            pub(crate) fn new(bits: bool) -> Self {
                FPEXCODIS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for FPEXCODIS_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `FPEXCODIS` writer - FPEXCODIS
        pub struct FPEXCODIS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> FPEXCODIS_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 10)) | ((value as u32 & 0x01) << 10);
                self.w
            }
        }
        ///Field `DISRAMODE` reader - DISRAMODE
        pub struct DISRAMODE_R(crate::FieldReader<bool, bool>);
        impl DISRAMODE_R {
            pub(crate) fn new(bits: bool) -> Self {
                DISRAMODE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DISRAMODE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DISRAMODE` writer - DISRAMODE
        pub struct DISRAMODE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISRAMODE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 11)) | ((value as u32 & 0x01) << 11);
                self.w
            }
        }
        ///Field `DISITMATBFLUSH` reader - DISITMATBFLUSH
        pub struct DISITMATBFLUSH_R(crate::FieldReader<bool, bool>);
        impl DISITMATBFLUSH_R {
            pub(crate) fn new(bits: bool) -> Self {
                DISITMATBFLUSH_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for DISITMATBFLUSH_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `DISITMATBFLUSH` writer - DISITMATBFLUSH
        pub struct DISITMATBFLUSH_W<'a> {
            w: &'a mut W,
        }
        impl<'a> DISITMATBFLUSH_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 12)) | ((value as u32 & 0x01) << 12);
                self.w
            }
        }
        impl R {
            ///Bit 2 - DISFOLD
            #[inline(always)]
            pub fn disfold(&self) -> DISFOLD_R {
                DISFOLD_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 10 - FPEXCODIS
            #[inline(always)]
            pub fn fpexcodis(&self) -> FPEXCODIS_R {
                FPEXCODIS_R::new(((self.bits >> 10) & 0x01) != 0)
            }
            ///Bit 11 - DISRAMODE
            #[inline(always)]
            pub fn disramode(&self) -> DISRAMODE_R {
                DISRAMODE_R::new(((self.bits >> 11) & 0x01) != 0)
            }
            ///Bit 12 - DISITMATBFLUSH
            #[inline(always)]
            pub fn disitmatbflush(&self) -> DISITMATBFLUSH_R {
                DISITMATBFLUSH_R::new(((self.bits >> 12) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 2 - DISFOLD
            #[inline(always)]
            pub fn disfold(&mut self) -> DISFOLD_W {
                DISFOLD_W { w: self }
            }
            ///Bit 10 - FPEXCODIS
            #[inline(always)]
            pub fn fpexcodis(&mut self) -> FPEXCODIS_W {
                FPEXCODIS_W { w: self }
            }
            ///Bit 11 - DISRAMODE
            #[inline(always)]
            pub fn disramode(&mut self) -> DISRAMODE_W {
                DISRAMODE_W { w: self }
            }
            ///Bit 12 - DISITMATBFLUSH
            #[inline(always)]
            pub fn disitmatbflush(&mut self) -> DISITMATBFLUSH_W {
                DISITMATBFLUSH_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Auxiliary control register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [actrl](index.html) module
        pub struct ACTRL_SPEC;
        impl crate::RegisterSpec for ACTRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [actrl::R](R) reader structure
        impl crate::Readable for ACTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [actrl::W](W) writer structure
        impl crate::Writable for ACTRL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets ACTRL to value 0
        impl crate::Resettable for ACTRL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///Nested vectored interrupt controller
pub struct NVIC_STIR {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for NVIC_STIR {}
impl NVIC_STIR {
    ///Pointer to the register block
    pub const PTR: *const nvic_stir::RegisterBlock = 0xe000_ef00 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const nvic_stir::RegisterBlock {
        Self::PTR
    }
}
impl Deref for NVIC_STIR {
    type Target = nvic_stir::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for NVIC_STIR {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("NVIC_STIR").finish()
    }
}
///Nested vectored interrupt controller
pub mod nvic_stir {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - Software trigger interrupt register
        pub stir: crate::Reg<stir::STIR_SPEC>,
    }
    ///STIR register accessor: an alias for `Reg<STIR_SPEC>`
    pub type STIR = crate::Reg<stir::STIR_SPEC>;
    ///Software trigger interrupt register
    pub mod stir {
        ///Register `STIR` reader
        pub struct R(crate::R<STIR_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<STIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<STIR_SPEC>> for R {
            fn from(reader: crate::R<STIR_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `STIR` writer
        pub struct W(crate::W<STIR_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<STIR_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<STIR_SPEC>> for W {
            fn from(writer: crate::W<STIR_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `INTID` reader - Software generated interrupt ID
        pub struct INTID_R(crate::FieldReader<u16, u16>);
        impl INTID_R {
            pub(crate) fn new(bits: u16) -> Self {
                INTID_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for INTID_R {
            type Target = crate::FieldReader<u16, u16>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `INTID` writer - Software generated interrupt ID
        pub struct INTID_W<'a> {
            w: &'a mut W,
        }
        impl<'a> INTID_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u16) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01ff) | (value as u32 & 0x01ff);
                self.w
            }
        }
        impl R {
            ///Bits 0:8 - Software generated interrupt ID
            #[inline(always)]
            pub fn intid(&self) -> INTID_R {
                INTID_R::new((self.bits & 0x01ff) as u16)
            }
        }
        impl W {
            ///Bits 0:8 - Software generated interrupt ID
            #[inline(always)]
            pub fn intid(&mut self) -> INTID_W {
                INTID_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///Software trigger interrupt register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [stir](index.html) module
        pub struct STIR_SPEC;
        impl crate::RegisterSpec for STIR_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [stir::R](R) reader structure
        impl crate::Readable for STIR_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [stir::W](W) writer structure
        impl crate::Writable for STIR_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets STIR to value 0
        impl crate::Resettable for STIR_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
///SysTick timer
pub struct STK {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for STK {}
impl STK {
    ///Pointer to the register block
    pub const PTR: *const stk::RegisterBlock = 0xe000_e010 as *const _;
    ///Return the pointer to the register block
    #[inline(always)]
    pub const fn ptr() -> *const stk::RegisterBlock {
        Self::PTR
    }
}
impl Deref for STK {
    type Target = stk::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for STK {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("STK").finish()
    }
}
///SysTick timer
pub mod stk {
    ///Register block
    #[repr(C)]
    pub struct RegisterBlock {
        ///0x00 - SysTick control and status register
        pub ctrl: crate::Reg<ctrl::CTRL_SPEC>,
        ///0x04 - SysTick reload value register
        pub load_: crate::Reg<load_::LOAD__SPEC>,
        ///0x08 - SysTick current value register
        pub val: crate::Reg<val::VAL_SPEC>,
        ///0x0c - SysTick calibration value register
        pub calib: crate::Reg<calib::CALIB_SPEC>,
    }
    ///CTRL register accessor: an alias for `Reg<CTRL_SPEC>`
    pub type CTRL = crate::Reg<ctrl::CTRL_SPEC>;
    ///SysTick control and status register
    pub mod ctrl {
        ///Register `CTRL` reader
        pub struct R(crate::R<CTRL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CTRL_SPEC>> for R {
            fn from(reader: crate::R<CTRL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CTRL` writer
        pub struct W(crate::W<CTRL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CTRL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CTRL_SPEC>> for W {
            fn from(writer: crate::W<CTRL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `ENABLE` reader - Counter enable
        pub struct ENABLE_R(crate::FieldReader<bool, bool>);
        impl ENABLE_R {
            pub(crate) fn new(bits: bool) -> Self {
                ENABLE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for ENABLE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `ENABLE` writer - Counter enable
        pub struct ENABLE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> ENABLE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x01) | (value as u32 & 0x01);
                self.w
            }
        }
        ///Field `TICKINT` reader - SysTick exception request enable
        pub struct TICKINT_R(crate::FieldReader<bool, bool>);
        impl TICKINT_R {
            pub(crate) fn new(bits: bool) -> Self {
                TICKINT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TICKINT_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TICKINT` writer - SysTick exception request enable
        pub struct TICKINT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TICKINT_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 1)) | ((value as u32 & 0x01) << 1);
                self.w
            }
        }
        ///Field `CLKSOURCE` reader - Clock source selection
        pub struct CLKSOURCE_R(crate::FieldReader<bool, bool>);
        impl CLKSOURCE_R {
            pub(crate) fn new(bits: bool) -> Self {
                CLKSOURCE_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CLKSOURCE_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CLKSOURCE` writer - Clock source selection
        pub struct CLKSOURCE_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CLKSOURCE_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 2)) | ((value as u32 & 0x01) << 2);
                self.w
            }
        }
        ///Field `COUNTFLAG` reader - COUNTFLAG
        pub struct COUNTFLAG_R(crate::FieldReader<bool, bool>);
        impl COUNTFLAG_R {
            pub(crate) fn new(bits: bool) -> Self {
                COUNTFLAG_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for COUNTFLAG_R {
            type Target = crate::FieldReader<bool, bool>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `COUNTFLAG` writer - COUNTFLAG
        pub struct COUNTFLAG_W<'a> {
            w: &'a mut W,
        }
        impl<'a> COUNTFLAG_W<'a> {
            ///Sets the field bit
            #[inline(always)]
            pub fn set_bit(self) -> &'a mut W {
                self.bit(true)
            }
            ///Clears the field bit
            #[inline(always)]
            pub fn clear_bit(self) -> &'a mut W {
                self.bit(false)
            }
            ///Writes raw bits to the field
            #[inline(always)]
            pub fn bit(self, value: bool) -> &'a mut W {
                self.w.bits = (self.w.bits & !(0x01 << 16)) | ((value as u32 & 0x01) << 16);
                self.w
            }
        }
        impl R {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn enable(&self) -> ENABLE_R {
                ENABLE_R::new((self.bits & 0x01) != 0)
            }
            ///Bit 1 - SysTick exception request enable
            #[inline(always)]
            pub fn tickint(&self) -> TICKINT_R {
                TICKINT_R::new(((self.bits >> 1) & 0x01) != 0)
            }
            ///Bit 2 - Clock source selection
            #[inline(always)]
            pub fn clksource(&self) -> CLKSOURCE_R {
                CLKSOURCE_R::new(((self.bits >> 2) & 0x01) != 0)
            }
            ///Bit 16 - COUNTFLAG
            #[inline(always)]
            pub fn countflag(&self) -> COUNTFLAG_R {
                COUNTFLAG_R::new(((self.bits >> 16) & 0x01) != 0)
            }
        }
        impl W {
            ///Bit 0 - Counter enable
            #[inline(always)]
            pub fn enable(&mut self) -> ENABLE_W {
                ENABLE_W { w: self }
            }
            ///Bit 1 - SysTick exception request enable
            #[inline(always)]
            pub fn tickint(&mut self) -> TICKINT_W {
                TICKINT_W { w: self }
            }
            ///Bit 2 - Clock source selection
            #[inline(always)]
            pub fn clksource(&mut self) -> CLKSOURCE_W {
                CLKSOURCE_W { w: self }
            }
            ///Bit 16 - COUNTFLAG
            #[inline(always)]
            pub fn countflag(&mut self) -> COUNTFLAG_W {
                COUNTFLAG_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick control and status register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [ctrl](index.html) module
        pub struct CTRL_SPEC;
        impl crate::RegisterSpec for CTRL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [ctrl::R](R) reader structure
        impl crate::Readable for CTRL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [ctrl::W](W) writer structure
        impl crate::Writable for CTRL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CTRL to value 0
        impl crate::Resettable for CTRL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///LOAD_ register accessor: an alias for `Reg<LOAD__SPEC>`
    pub type LOAD_ = crate::Reg<load_::LOAD__SPEC>;
    ///SysTick reload value register
    pub mod load_ {
        ///Register `LOAD_` reader
        pub struct R(crate::R<LOAD__SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<LOAD__SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<LOAD__SPEC>> for R {
            fn from(reader: crate::R<LOAD__SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `LOAD_` writer
        pub struct W(crate::W<LOAD__SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<LOAD__SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<LOAD__SPEC>> for W {
            fn from(writer: crate::W<LOAD__SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `RELOAD` reader - RELOAD value
        pub struct RELOAD_R(crate::FieldReader<u32, u32>);
        impl RELOAD_R {
            pub(crate) fn new(bits: u32) -> Self {
                RELOAD_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for RELOAD_R {
            type Target = crate::FieldReader<u32, u32>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `RELOAD` writer - RELOAD value
        pub struct RELOAD_W<'a> {
            w: &'a mut W,
        }
        impl<'a> RELOAD_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | (value as u32 & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:23 - RELOAD value
            #[inline(always)]
            pub fn reload(&self) -> RELOAD_R {
                RELOAD_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:23 - RELOAD value
            #[inline(always)]
            pub fn reload(&mut self) -> RELOAD_W {
                RELOAD_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick reload value register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [load_](index.html) module
        pub struct LOAD__SPEC;
        impl crate::RegisterSpec for LOAD__SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [load_::R](R) reader structure
        impl crate::Readable for LOAD__SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [load_::W](W) writer structure
        impl crate::Writable for LOAD__SPEC {
            type Writer = W;
        }
        ///`reset()` method sets LOAD_ to value 0
        impl crate::Resettable for LOAD__SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///VAL register accessor: an alias for `Reg<VAL_SPEC>`
    pub type VAL = crate::Reg<val::VAL_SPEC>;
    ///SysTick current value register
    pub mod val {
        ///Register `VAL` reader
        pub struct R(crate::R<VAL_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<VAL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<VAL_SPEC>> for R {
            fn from(reader: crate::R<VAL_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `VAL` writer
        pub struct W(crate::W<VAL_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<VAL_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<VAL_SPEC>> for W {
            fn from(writer: crate::W<VAL_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `CURRENT` reader - Current counter value
        pub struct CURRENT_R(crate::FieldReader<u32, u32>);
        impl CURRENT_R {
            pub(crate) fn new(bits: u32) -> Self {
                CURRENT_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for CURRENT_R {
            type Target = crate::FieldReader<u32, u32>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `CURRENT` writer - Current counter value
        pub struct CURRENT_W<'a> {
            w: &'a mut W,
        }
        impl<'a> CURRENT_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | (value as u32 & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:23 - Current counter value
            #[inline(always)]
            pub fn current(&self) -> CURRENT_R {
                CURRENT_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:23 - Current counter value
            #[inline(always)]
            pub fn current(&mut self) -> CURRENT_W {
                CURRENT_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick current value register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [val](index.html) module
        pub struct VAL_SPEC;
        impl crate::RegisterSpec for VAL_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [val::R](R) reader structure
        impl crate::Readable for VAL_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [val::W](W) writer structure
        impl crate::Writable for VAL_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets VAL to value 0
        impl crate::Resettable for VAL_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
    ///CALIB register accessor: an alias for `Reg<CALIB_SPEC>`
    pub type CALIB = crate::Reg<calib::CALIB_SPEC>;
    ///SysTick calibration value register
    pub mod calib {
        ///Register `CALIB` reader
        pub struct R(crate::R<CALIB_SPEC>);
        impl core::ops::Deref for R {
            type Target = crate::R<CALIB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::convert::From<crate::R<CALIB_SPEC>> for R {
            fn from(reader: crate::R<CALIB_SPEC>) -> Self {
                R(reader)
            }
        }
        ///Register `CALIB` writer
        pub struct W(crate::W<CALIB_SPEC>);
        impl core::ops::Deref for W {
            type Target = crate::W<CALIB_SPEC>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        impl core::ops::DerefMut for W {
            #[inline(always)]
            fn deref_mut(&mut self) -> &mut Self::Target {
                &mut self.0
            }
        }
        impl core::convert::From<crate::W<CALIB_SPEC>> for W {
            fn from(writer: crate::W<CALIB_SPEC>) -> Self {
                W(writer)
            }
        }
        ///Field `TENMS` reader - Calibration value
        pub struct TENMS_R(crate::FieldReader<u32, u32>);
        impl TENMS_R {
            pub(crate) fn new(bits: u32) -> Self {
                TENMS_R(crate::FieldReader::new(bits))
            }
        }
        impl core::ops::Deref for TENMS_R {
            type Target = crate::FieldReader<u32, u32>;
            #[inline(always)]
            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }
        ///Field `TENMS` writer - Calibration value
        pub struct TENMS_W<'a> {
            w: &'a mut W,
        }
        impl<'a> TENMS_W<'a> {
            ///Writes raw bits to the field
            #[inline(always)]
            pub unsafe fn bits(self, value: u32) -> &'a mut W {
                self.w.bits = (self.w.bits & !0x00ff_ffff) | (value as u32 & 0x00ff_ffff);
                self.w
            }
        }
        impl R {
            ///Bits 0:23 - Calibration value
            #[inline(always)]
            pub fn tenms(&self) -> TENMS_R {
                TENMS_R::new((self.bits & 0x00ff_ffff) as u32)
            }
        }
        impl W {
            ///Bits 0:23 - Calibration value
            #[inline(always)]
            pub fn tenms(&mut self) -> TENMS_W {
                TENMS_W { w: self }
            }
            ///Writes raw bits to the register.
            pub unsafe fn bits(&mut self, bits: u32) -> &mut Self {
                self.0.bits(bits);
                self
            }
        }
        ///SysTick calibration value register
        ///
        ///This register you can [`read`](crate::generic::Reg::read), [`write_with_zero`](crate::generic::Reg::write_with_zero), [`reset`](crate::generic::Reg::reset), [`write`](crate::generic::Reg::write), [`modify`](crate::generic::Reg::modify). See [API](https://docs.rs/svd2rust/#read--modify--write-api).
        ///
        ///For information about available fields see [calib](index.html) module
        pub struct CALIB_SPEC;
        impl crate::RegisterSpec for CALIB_SPEC {
            type Ux = u32;
        }
        ///`read()` method returns [calib::R](R) reader structure
        impl crate::Readable for CALIB_SPEC {
            type Reader = R;
        }
        ///`write(|w| ..)` method takes [calib::W](W) writer structure
        impl crate::Writable for CALIB_SPEC {
            type Writer = W;
        }
        ///`reset()` method sets CALIB to value 0
        impl crate::Resettable for CALIB_SPEC {
            #[inline(always)]
            fn reset_value() -> Self::Ux {
                0
            }
        }
    }
}
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
///All the peripherals
#[allow(non_snake_case)]
pub struct Peripherals {
    ///FSMC
    pub FSMC: FSMC,
    ///PWR
    pub PWR: PWR,
    ///RCC
    pub RCC: RCC,
    ///GPIOA
    pub GPIOA: GPIOA,
    ///GPIOB
    pub GPIOB: GPIOB,
    ///GPIOC
    pub GPIOC: GPIOC,
    ///GPIOD
    pub GPIOD: GPIOD,
    ///GPIOE
    pub GPIOE: GPIOE,
    ///GPIOF
    pub GPIOF: GPIOF,
    ///GPIOG
    pub GPIOG: GPIOG,
    ///AFIO
    pub AFIO: AFIO,
    ///EXTI
    pub EXTI: EXTI,
    ///DMA1
    pub DMA1: DMA1,
    ///DMA2
    pub DMA2: DMA2,
    ///RTC
    pub RTC: RTC,
    ///BKP
    pub BKP: BKP,
    ///IWDG
    pub IWDG: IWDG,
    ///WWDG
    pub WWDG: WWDG,
    ///TIM1
    pub TIM1: TIM1,
    ///TIM2
    pub TIM2: TIM2,
    ///TIM3
    pub TIM3: TIM3,
    ///TIM4
    pub TIM4: TIM4,
    ///TIM5
    pub TIM5: TIM5,
    ///TIM12
    pub TIM12: TIM12,
    ///TIM13
    pub TIM13: TIM13,
    ///TIM14
    pub TIM14: TIM14,
    ///TIM6
    pub TIM6: TIM6,
    ///TIM7
    pub TIM7: TIM7,
    ///I2C1
    pub I2C1: I2C1,
    ///I2C2
    pub I2C2: I2C2,
    ///SPI1
    pub SPI1: SPI1,
    ///SPI2
    pub SPI2: SPI2,
    ///SPI3
    pub SPI3: SPI3,
    ///USART1
    pub USART1: USART1,
    ///USART2
    pub USART2: USART2,
    ///USART3
    pub USART3: USART3,
    ///ADC1
    pub ADC1: ADC1,
    ///DAC
    pub DAC: DAC,
    ///DBGMCU
    pub DBGMCU: DBGMCU,
    ///UART4
    pub UART4: UART4,
    ///UART5
    pub UART5: UART5,
    ///CRC
    pub CRC: CRC,
    ///FLASH
    pub FLASH: FLASH,
    ///TIM15
    pub TIM15: TIM15,
    ///TIM16
    pub TIM16: TIM16,
    ///TIM17
    pub TIM17: TIM17,
    ///CEC
    pub CEC: CEC,
    ///SCB_ACTRL
    pub SCB_ACTRL: SCB_ACTRL,
    ///NVIC_STIR
    pub NVIC_STIR: NVIC_STIR,
    ///STK
    pub STK: STK,
}
impl Peripherals {
    ///Returns all the peripherals *once*
    #[inline]
    pub fn take() -> Option<Self> {
        cortex_m::interrupt::free(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                None
            } else {
                Some(unsafe { Peripherals::steal() })
            }
        })
    }
    ///Unchecked version of `Peripherals::take`
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            FSMC: FSMC {
                _marker: PhantomData,
            },
            PWR: PWR {
                _marker: PhantomData,
            },
            RCC: RCC {
                _marker: PhantomData,
            },
            GPIOA: GPIOA {
                _marker: PhantomData,
            },
            GPIOB: GPIOB {
                _marker: PhantomData,
            },
            GPIOC: GPIOC {
                _marker: PhantomData,
            },
            GPIOD: GPIOD {
                _marker: PhantomData,
            },
            GPIOE: GPIOE {
                _marker: PhantomData,
            },
            GPIOF: GPIOF {
                _marker: PhantomData,
            },
            GPIOG: GPIOG {
                _marker: PhantomData,
            },
            AFIO: AFIO {
                _marker: PhantomData,
            },
            EXTI: EXTI {
                _marker: PhantomData,
            },
            DMA1: DMA1 {
                _marker: PhantomData,
            },
            DMA2: DMA2 {
                _marker: PhantomData,
            },
            RTC: RTC {
                _marker: PhantomData,
            },
            BKP: BKP {
                _marker: PhantomData,
            },
            IWDG: IWDG {
                _marker: PhantomData,
            },
            WWDG: WWDG {
                _marker: PhantomData,
            },
            TIM1: TIM1 {
                _marker: PhantomData,
            },
            TIM2: TIM2 {
                _marker: PhantomData,
            },
            TIM3: TIM3 {
                _marker: PhantomData,
            },
            TIM4: TIM4 {
                _marker: PhantomData,
            },
            TIM5: TIM5 {
                _marker: PhantomData,
            },
            TIM12: TIM12 {
                _marker: PhantomData,
            },
            TIM13: TIM13 {
                _marker: PhantomData,
            },
            TIM14: TIM14 {
                _marker: PhantomData,
            },
            TIM6: TIM6 {
                _marker: PhantomData,
            },
            TIM7: TIM7 {
                _marker: PhantomData,
            },
            I2C1: I2C1 {
                _marker: PhantomData,
            },
            I2C2: I2C2 {
                _marker: PhantomData,
            },
            SPI1: SPI1 {
                _marker: PhantomData,
            },
            SPI2: SPI2 {
                _marker: PhantomData,
            },
            SPI3: SPI3 {
                _marker: PhantomData,
            },
            USART1: USART1 {
                _marker: PhantomData,
            },
            USART2: USART2 {
                _marker: PhantomData,
            },
            USART3: USART3 {
                _marker: PhantomData,
            },
            ADC1: ADC1 {
                _marker: PhantomData,
            },
            DAC: DAC {
                _marker: PhantomData,
            },
            DBGMCU: DBGMCU {
                _marker: PhantomData,
            },
            UART4: UART4 {
                _marker: PhantomData,
            },
            UART5: UART5 {
                _marker: PhantomData,
            },
            CRC: CRC {
                _marker: PhantomData,
            },
            FLASH: FLASH {
                _marker: PhantomData,
            },
            TIM15: TIM15 {
                _marker: PhantomData,
            },
            TIM16: TIM16 {
                _marker: PhantomData,
            },
            TIM17: TIM17 {
                _marker: PhantomData,
            },
            CEC: CEC {
                _marker: PhantomData,
            },
            SCB_ACTRL: SCB_ACTRL {
                _marker: PhantomData,
            },
            NVIC_STIR: NVIC_STIR {
                _marker: PhantomData,
            },
            STK: STK {
                _marker: PhantomData,
            },
        }
    }
}
